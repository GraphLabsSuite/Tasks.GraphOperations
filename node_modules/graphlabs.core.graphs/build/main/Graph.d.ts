import { IVertex } from "../types/IVertex";
import { IEdge } from "../types/IEdge";
import { IGraph } from "../types/IGraph";
import { Vertex } from "./Vertex";
import { Edge } from "./Edge";
/** @classdesc
 * Graph implementation of the IGraph interface */
export declare class Graph<T extends Vertex, K extends Edge> implements IGraph<T, K> {
    /** @property
     *  @private
     * Mark shows whether graph edges are directed or not */
    private _isDirected;
    /** @property
     *  @private
     * Mark shows whether it is possible to have more
     * than one edge between two vertices or not */
    private _allowMultipleEdges;
    /** @property
     *  @private
     * The list of vertices in the graph */
    private _vertices;
    /** @property
     *  @private
     * The list of edges in the graph */
    private _edges;
    /** @property
     *  @public
     *  Getter for _isDirected field
     *  @returns {boolean}
     *  */
    get isDirected(): boolean;
    /** @property
     *  @public
     *  Getter for _allowMultipleEdges field
     *  @returns {boolean}
     */
    get allowMultipleEdges(): boolean;
    /**
     * @property
     * @public
     * Getter for _vertices field
     * @return {T[]}
     */
    get vertices(): T[];
    /**
     * @property
     * @public
     * Getter for _edges field
     * @return {K[]}
     */
    get edges(): K[];
    /**
     * @constructor
     */
    constructor(directed?: boolean);
    clear(): void;
    /**
     * Adds the edge to the graph
     * @param edge
     */
    addEdge(edge: K): void;
    /**
     * Removes the edge from the graph
     * @param edge
     */
    removeEdge(edge: K): void;
    /**
     * Gets the edge between the two vertices incident to it
     * @param vertexOne
     * @param vertexTwo
     */
    getEdge(vertexOne: T, vertexTwo: T): K[];
    /**
     * Get the vertex by its name
     * @param name
     * @returns {T[]}
     */
    getVertex(name: string): T[];
    /**
     * Adds the vertex to the graph
     * @param vertex
     */
    addVertex(vertex: T): void;
    /**
     * Removes the vertex from the graph
     * @param vertex
     */
    removeVertex(vertex: T): void;
    /**
     * Returns the result of union operation for N graphs
     * @param graphs
     * @returns {Graph<T,K>}
     */
    static unionN(graphs: IGraph<IVertex, IEdge>[]): IGraph<IVertex, IEdge>;
    /**
     * Returns the result of intersect operation for N graphs
     * @param graphs
     * @returns {IGraph<T,K>}
     */
    static intersectN(graphs: IGraph<IVertex, IEdge>[]): IGraph<IVertex, IEdge>;
    /**
     * @static
     * Static builder for the directed weighted graph
     * @param verticesNumber
     * @return {DirectedWeightedGraph}
     */
    static createEmpty(verticesNumber: number): IGraph<IVertex, IEdge>;
    /**
     * Returns the result of union operation
     * @param graph
     * @returns {Graph<T, K>}
     */
    union(graph: IGraph<IVertex, IEdge>): IGraph<IVertex, IEdge>;
    /**
     * Returns the result of intersect operation
     * @param graph
     * @returns {IGraph}
     */
    intersect(graph: IGraph<IVertex, IEdge>): IGraph<IVertex, IEdge>;
    /**
     * Returns a complement graph to the given one
     * @returns {IGraph}
     */
    complement(): IGraph<IVertex, IEdge>;
    /**
     * Checks if the second graph is isomorphic to the given one
     * @param graph
     * @returns {boolean}
     */
    checkIsomorphism(graph: IGraph<IVertex, IEdge>): boolean;
    /**
     * Returns strongly connected components of the given graph
     * @returns {IGraph[]}
     */
    buildSCC(): IGraph<IVertex, IEdge>[];
    print(): void;
    toString(): string;
    /**
     * Deep graph-cloning
     */
    clone(): IGraph<IVertex, IEdge>;
    /**
     * Get subgraph of graph
     * input: vertives
     */
    getSubgraph(subVertices: T[]): IGraph<IVertex, IEdge>;
    /**
     * Get neighbourhood
     */
    getNeighbourhood(vertex: Vertex): Vertex[];
    /**
     * Get non-neighbourhood
     */
    getNonNeighbourhood(vertex: Vertex): Vertex[];
    /**
     * Get vertex's degree
     */
    getVertexDegree(vertex: Vertex): number;
    /**
     * Get vertex with minimum degree
     */
    getVertexWithMinDegree(): Vertex | null;
    /**
     * Checks if the graph is connected
     */
    isConnected(graph: IGraph<IVertex, IEdge>): boolean;
}
