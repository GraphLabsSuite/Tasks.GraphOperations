"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @classdesc
 * Checkers for dominating and minimal dominating sets
 */
var CheckSet = /** @class */ (function () {
    function CheckSet() {
    }
    /**
     * Checker for a dominating set
     * @param vSet
     * @param givenGraph
     * @returns {boolean}
     * @constructor
     */
    CheckSet.prototype.isExternalStability = function (vSet, givenGraph) {
        var extendedSetofVertex = [];
        for (var _i = 0, vSet_1 = vSet; _i < vSet_1.length; _i++) {
            var vertex = vSet_1[_i];
            extendedSetofVertex.push(vertex);
        }
        //We add vertices adjacent with the chosen one into extended set of vertices
        for (var _a = 0, vSet_2 = vSet; _a < vSet_2.length; _a++) {
            var vertex = vSet_2[_a];
            var _loop_1 = function (edge) {
                if ((edge.vertexOne == vertex) && !extendedSetofVertex.filter(function (v) { return v.equals(edge.vertexTwo); })[0]) {
                    extendedSetofVertex.push(edge.vertexTwo);
                }
                if ((edge.vertexTwo == vertex) && !extendedSetofVertex.filter(function (v) { return v.equals(edge.vertexOne); })[0]) {
                    extendedSetofVertex.push(edge.vertexOne);
                }
            };
            for (var _b = 0, _c = givenGraph.edges; _b < _c.length; _b++) {
                var edge = _c[_b];
                _loop_1(edge);
            }
        }
        var _loop_2 = function (vertex) {
            if (!extendedSetofVertex.filter(function (v) { return v.equals(vertex); })[0])
                return { value: false };
        };
        //We check whether the graph has vertices that are not adjacent to the ones in the extended set
        for (var _d = 0, _e = givenGraph.vertices; _d < _e.length; _d++) {
            var vertex = _e[_d];
            var state_1 = _loop_2(vertex);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return true;
    };
    /**
     * Checker for minimal dominating set
     * @param setEs
     * @param givenGraph
     * @returns {boolean}
     */
    CheckSet.prototype.isMinimal = function (setEs, givenGraph) {
        var leadFlag = true;
        var flag = true;
        var _loop_3 = function (vertex) {
            var newSet = [];
            setEs.forEach(function (v) {
                if (!v.equals(vertex))
                    newSet.push(v);
            });
            flag = this_1.isExternalStability(newSet, givenGraph);
            if (flag)
                leadFlag = false;
        };
        var this_1 = this;
        for (var _i = 0, setEs_1 = setEs; _i < setEs_1.length; _i++) {
            var vertex = setEs_1[_i];
            _loop_3(vertex);
        }
        return leadFlag;
    };
    return CheckSet;
}());
exports.CheckSet = CheckSet;
//# sourceMappingURL=CheckSet.js.map