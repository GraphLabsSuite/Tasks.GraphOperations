{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/home/ilya/UIR/test_5/src/App.tsx\";\nimport React from 'react';\nimport './App.css';\nimport { GraphVisualizer, Template, Toolbar, store, StudentMark, init, graphModel, Console } from \"graphlabs.core.template\";\nimport { Vertex, Edge, GraphGenerator, SccBuilder } from \"graphlabs.core.graphs\";\nimport styles from './Template.module.scss';\nimport 'graphlabs.core.template/dist/main.css';\nimport { init1, graphModel1, init2, graphModel2, initres } from './ForMyGraphModel';\n\nclass App extends Template {\n  componentWillMount() {\n    let graph;\n    graph = GraphGenerator.generate(0);\n    init(graph);\n    let graph1;\n    graph1 = this.GetNewRandomGraph(5);\n    init1(graph1);\n    let graph2;\n    graph2 = this.GetNewRandomGraphForThatOne(5, graph1);\n    init2(graph2);\n    let graphres = this.ChooseTask();\n    initres(graphres);\n    this.scc_count = SccBuilder.findComponents(graphres).length;\n  } //Для меня в будующем: проблема невозможности удать ребро заключается в том, что я создаю два других, тем саммы ломая себе всё.\n  //Это нужно проверить и внести определённые правки. Также нужно узнать как мой модуль добавить на сайт, а не только на гитхаб.\n\n\n  ChooseTask() {\n    this.num_0 = Math.round(Math.random() * 100) % 7;\n\n    switch (this.num_0) {\n      case 0:\n        this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n        return this.Uni(graphModel1, graphModel2);\n\n      case 1:\n        this.message_0 = \"Постройте граф, являющийся результатом соединения двух графов.\";\n        return this.Joint(graphModel1, graphModel2);\n\n      case 2:\n        this.message_0 = \"Постройте граф, являющийся результатом произведения двух графов.\";\n        return this.Product(graphModel1, graphModel2);\n\n      case 3:\n        this.message_0 = \"Постройте граф, являющийся результатом композиции двух графов.\";\n        return this.Composition(graphModel1, graphModel2);\n\n      case 4:\n        this.message_0 = \"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\"; // Объединение по Зыкову\n\n        return this.Uni_Z(graphModel1, graphModel2);\n\n      case 5:\n        this.message_0 = \"Постройте граф, являющийся результатом пересечения двух графов.\"; // Пересечение\n\n        return this.Cross(graphModel1, graphModel2);\n\n      case 6:\n        this.message_0 = \"Постройте граф, являющийся дополнением графа.\"; // Дополнение\n\n        return this.Addition(graphModel1);\n\n      case 7:\n        this.message_0 = \"Постройте граф, являющийся результатом декартового произведения двух графов.\"; // Декартово произведение\n\n        return this.Cartesian_Product(graphModel1, graphModel2);\n\n      default:\n        this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n        return this.Uni(graphModel1, graphModel2);\n    }\n  }\n\n  GetNewRandomGraph(num) {\n    // рандомный граф\n    let graph;\n    graph = GraphGenerator.generate(0);\n    var arr = [];\n\n    for (var i = 0; i < num; i++) {\n      arr.push(Math.round(Math.random()));\n\n      if (arr[i] === 1) {\n        let vert = new Vertex(`${i}`);\n        graph.addVertex(vert);\n      }\n    }\n\n    for (var i = 0; i < num - 1; i++) {\n      if (arr[i] === 1) {\n        for (var j = i + 1; j < num; j++) {\n          if (arr[j] === 1 && Math.random() > 0.45) {\n            // 55% chance what is edge i+j\n            let edge = new Edge(graph.getVertex(`${i}`)[0], graph.getVertex(`${j}`)[0], `${i}+${j}`);\n            graph.addEdge(edge);\n          }\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  GetNewRandomGraphForThatOne(num, graph1) {\n    // рандомный, не имеющий общих вершин с первым\n    let graph;\n    graph = GraphGenerator.generate(0);\n    var arr = [];\n    let length = graph1.vertices.length + 1;\n\n    for (var i = 0; i < num; i++) {\n      arr.push(Math.round(Math.random()));\n\n      if (arr[i] === 1) {\n        let vert = new Vertex(`${i + length}`);\n        graph.addVertex(vert);\n      }\n    }\n\n    for (var i = 0; i < num - 1; i++) {\n      if (arr[i] === 1) {\n        for (var j = i + 1; j < num; j++) {\n          if (arr[j] === 1 && Math.random() > 0.45) {\n            // 55% chance what is edge i+j\n            let edge = new Edge(graph.getVertex(`${i + length}`)[0], graph.getVertex(`${j + length}`)[0], `${i + length}+${j + length}`);\n            graph.addEdge(edge);\n          }\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  Uni(graph1, graph2) {\n    // объединение\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.vertices.forEach(v => {\n      if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n        // если нет таких же по имени вершин\n        graphres.addVertex(v);\n      }\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph1.edges.forEach(e => {\n      let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n      let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n      let e_new;\n      e_new = new Edge(vv1, vv2);\n      graphres.addEdge(e_new);\n    });\n    graph2.edges.forEach(e => {\n      let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n      let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n      let e_new;\n      e_new = new Edge(vv1, vv2);\n      graphres.addEdge(e_new);\n    });\n    return graphres;\n  }\n\n  Operation2(graph1, graph2) {\n    // соединение по  (это и есть простое соединение)\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.vertices.forEach(v => {\n      if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n        // если нет таких же по имени вершин\n        graphres.addVertex(v);\n        graph1.vertices.forEach(v1 => {\n          // дополнение к объединению\n          if (!(graphres.getEdge(v, v1).length > 0)) {\n            let e;\n            e = new Edge(v, v1);\n            graphres.addEdge(e);\n          }\n        });\n      }\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    return graphres;\n  }\n\n  Joint(graph1, graph2) {\n    // соединение !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n      graph2.vertices.forEach(v1 => {\n        if (!(graphres.getVertex(`${v1.name}`).length > 0)) graphres.addVertex(v1);\n        let e;\n        e = new Edge(v, v1);\n        graphres.addEdge(e);\n      });\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    return graphres;\n  }\n\n  Product(graph1, graph2) {\n    // Произведение !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graph2.vertices.forEach(v1 => {\n        let v_res;\n        v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n        graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n        //graphres.addVertex(v_res);\n      });\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        graph1.vertices.forEach(u1 => {\n          graph2.vertices.forEach(u2 => {\n            if (u1.name != v1.name || u2.name != v2.name) {\n              if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              } else if (u2.name === v2.name && v1.isAdjacent(graph1, u1)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              }\n            }\n          });\n        });\n      });\n    });\n    return graphres;\n  }\n\n  Composition(graph1, graph2) {\n    // Композиция !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graph2.vertices.forEach(v1 => {\n        let v_res;\n        v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n        graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n        //graphres.addVertex(v_res);\n      });\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        graph1.vertices.forEach(u1 => {\n          graph2.vertices.forEach(u2 => {\n            if (u1.name != v1.name || u2.name != v2.name) {\n              let e_0;\n              e_0 = new Edge(v1, v2);\n\n              if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n                //graph2.getEdge(v2,u2).length>0 ){\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              } else if (v1.isAdjacent(graph1, u1)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              }\n            }\n          });\n        });\n      });\n    });\n    return graphres;\n  }\n\n  Uni_Z(graph1, graph2) {\n    // объединение по Зыкову\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.vertices.forEach(v => {\n      if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n        // если нет таких же по имени вершин\n        graphres.addVertex(v);\n      }\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        if (!graphres.getVertex(v1.name)[0].isAdjacent(graphres, graphres.getVertex(v2.name)[0])) {\n          let vv1 = graphres.getVertex(`${v1.name}`)[0];\n          let vv2 = graphres.getVertex(`${v2.name}`)[0];\n          let e;\n          e = new Edge(vv1, vv2);\n          graphres.addEdge(e);\n        }\n      });\n    });\n    return graphres;\n  }\n\n  Cross(graph1, graph2) {\n    // Пересечение\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        if (v1.name == v2.name) {\n          let v_res;\n          v_res = new Vertex(`${v1.name}`);\n          graphres.addVertex(v_res);\n        }\n      });\n    });\n    graph1.edges.forEach(u1 => {\n      graph2.edges.forEach(u2 => {\n        if (u1.vertexOne.name == u2.vertexOne.name && u1.vertexTwo.name == u2.vertexTwo.name || u1.vertexOne.name == u2.vertexTwo.name && u1.vertexTwo.name == u2.vertexOne.name) {\n          let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n          let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n          let e;\n          e = new Edge(v1[0], v2[0]);\n          graphres.addEdge(e);\n        }\n      });\n    });\n    return graphres;\n  }\n\n  Addition(graph1) {\n    // Дополнение\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v1 => {\n      let v_res;\n      v_res = new Vertex(`${v1.name}`);\n      graphres.addVertex(v_res);\n    });\n    graph1.vertices.forEach(v1 => {\n      graph1.vertices.forEach(v2 => {\n        let vv1 = v1.name;\n        let vv2 = v2.name;\n\n        if (v1.name != v2.name && !v1.isAdjacent(graph1, v2) && !graphres.getVertex(v1.name)[0].isAdjacent(graphres, graphres.getVertex(v2.name)[0])) {\n          let v1 = graphres.getVertex(`${vv1}`);\n          let v2 = graphres.getVertex(`${vv2}`);\n          let e;\n          e = new Edge(v1[0], v2[0]);\n          graphres.addEdge(e);\n        }\n      });\n    });\n    let graph2;\n    graph2 = this.GetNewRandomGraph(0);\n    init2(graph2);\n    return graphres;\n  }\n\n  Cartesian_Product(graph1, graph2) {\n    // Декартово произведение !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graph2.vertices.forEach(v1 => {\n        let v_res;\n        v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n        graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n        //graphres.addVertex(v_res);\n      });\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        graph1.vertices.forEach(u1 => {\n          graph2.vertices.forEach(u2 => {\n            if (u1.name != v1.name || u2.name != v2.name) {\n              let e_0;\n              e_0 = new Edge(v1, v2);\n\n              if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n                //graph2.getEdge(v2,u2).length>0 ){\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              } else if (v1.isAdjacent(graph1, u1)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              }\n            }\n          });\n        });\n      });\n    });\n    return graphres;\n  }\n\n  constructor(props) {\n    super(props);\n    this.message_0 = \"\";\n    this.num_0 = 0;\n    this.state = {\n      status: store.getState().app.status\n    };\n    store.subscribe(() => {\n      if (store.getState().app.status !== this.state.status) {\n        this.setState({\n          status: store.getState().app.status\n        });\n      }\n    });\n    this.task = this.task.bind(this);\n    this.getTaskToolbar = this.getTaskToolbar.bind(this);\n  }\n\n  render() {\n    const Task = this.task();\n    const Toolbar = this.getTaskToolbar();\n    const Area = this.getArea();\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.App,\n      id: \"wrap\",\n      children: this.state.status ? /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"\\u0417\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0432\\u044B\\u043F\\u043E\\u043B\\u043D\\u0435\\u043D\\u043E. \\u041E\\u0436\\u0438\\u0434\\u0430\\u0439\\u0442\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0430 \\u043E\\u0442 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 474,\n        columnNumber: 23\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: styles.MainRow,\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: styles.GraphCell,\n            children: /*#__PURE__*/_jsxDEV(Area, {}, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 479,\n              columnNumber: 37\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 478,\n            columnNumber: 33\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: styles.ToolCell,\n            children: /*#__PURE__*/_jsxDEV(Toolbar, {}, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 482,\n              columnNumber: 37\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 481,\n            columnNumber: 33\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: styles.TaskCell,\n            children: [/*#__PURE__*/_jsxDEV(\"p\", {\n              children: \"\\u0417\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 485,\n              columnNumber: 37\n            }, this), /*#__PURE__*/_jsxDEV(Task, {}, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 486,\n              columnNumber: 37\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 484,\n            columnNumber: 33\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 477,\n          columnNumber: 29\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: styles.LeftBottom,\n          children: /*#__PURE__*/_jsxDEV(StudentMark, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 490,\n            columnNumber: 33\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 489,\n          columnNumber: 29\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: styles.LowRow,\n          children: /*#__PURE__*/_jsxDEV(Console, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 493,\n            columnNumber: 33\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 492,\n          columnNumber: 29\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 476,\n        columnNumber: 25\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 472,\n      columnNumber: 13\n    }, this);\n  } //<Task/>\n\n\n  getTaskToolbar() {\n    return Toolbar;\n  }\n\n  getArea() {\n    return () => /*#__PURE__*/_jsxDEV(GraphVisualizer, {\n      graph: graphModel,\n      adapterType: 'writable',\n      namedEdges: false,\n      vertexNaming: true,\n      withoutDragging: true,\n      edgeNaming: false,\n      incidentEdges: false\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 505,\n      columnNumber: 22\n    }, this); //return () =>\n    //    <GraphVisualizer\n    //        graph={graphModelres}\n    //        adapterType={'readable'}\n    //        namedEdges={false}\n    //        vertexNaming={false}\n    //        withoutDragging={false}\n    //        edgeNaming={false}\n    //        incidentEdges={false}\n    //    />\n  }\n\n  task() {\n    graphModel.vertices.forEach(v => console.log(`id = ${v.id}; label = ${v.label}; name = ${v.name}; wawe=${v.wave}.\\n`));\n    return () => /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: this.message_0\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 530,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(\"p\", {\n          children: /*#__PURE__*/_jsxDEV(GraphVisualizer, {\n            graph: graphModel1,\n            adapterType: 'readable',\n            namedEdges: false,\n            vertexNaming: false,\n            withoutDragging: true,\n            edgeNaming: false,\n            incidentEdges: false\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 535,\n            columnNumber: 25\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 534,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: /*#__PURE__*/_jsxDEV(GraphVisualizer, {\n            graph: graphModel2,\n            adapterType: 'readable',\n            namedEdges: false,\n            vertexNaming: false,\n            withoutDragging: true,\n            edgeNaming: false,\n            incidentEdges: false\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 546,\n            columnNumber: 25\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 545,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 533,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 529,\n      columnNumber: 13\n    }, this);\n  }\n\n}\n\nexport default App;","map":{"version":3,"sources":["/home/ilya/UIR/test_5/src/App.tsx"],"names":["React","GraphVisualizer","Template","Toolbar","store","StudentMark","init","graphModel","Console","Vertex","Edge","GraphGenerator","SccBuilder","styles","init1","graphModel1","init2","graphModel2","initres","App","componentWillMount","graph","generate","graph1","GetNewRandomGraph","graph2","GetNewRandomGraphForThatOne","graphres","ChooseTask","scc_count","findComponents","length","num_0","Math","round","random","message_0","Uni","Joint","Product","Composition","Uni_Z","Cross","Addition","Cartesian_Product","num","arr","i","push","vert","addVertex","j","edge","getVertex","addEdge","vertices","forEach","v","edges","e","name","vv1","vertexOne","vv2","vertexTwo","e_new","Operation2","v1","getEdge","v_res","v2","u1","u2","isAdjacent","e_0","constructor","props","state","status","getState","app","subscribe","setState","task","bind","getTaskToolbar","render","Task","Area","getArea","MainRow","GraphCell","ToolCell","TaskCell","LeftBottom","LowRow","console","log","id","label","wave"],"mappings":"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","sourcesContent":["import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { GraphVisualizer, IGraphView, Template, Toolbar, ToolButtonList, store, IMatrixView, INGraphsView, graphActionCreators, StudentMark, init, graphModel, Console, State } from \"graphlabs.core.template\";\nimport { IGraph, IVertex, IEdge, Graph, Vertex, Edge, GraphGenerator, SccBuilder } from \"graphlabs.core.graphs\";\nimport styles from './Template.module.scss';\nimport 'graphlabs.core.template/dist/main.css';\n\nimport { Component, SFC} from 'react';\nimport { init1, graphModel1, init2, graphModel2, initres, graphModelres } from './ForMyGraphModel';\n\nclass App extends Template {\n    protected message_0 = \"\";\n    protected num_0 = 0;\n\n    public state = {\n        status: store.getState().app.status,\n    };\n\n    componentWillMount() {\n        let graph: IGraph<IVertex, IEdge>;\n\n        graph = GraphGenerator.generate(0);\n        init(graph);\n\n        let graph1: IGraph<IVertex, IEdge>;\n        graph1 = this.GetNewRandomGraph(5);\n        init1(graph1);\n\n        let graph2: IGraph<IVertex, IEdge>;\n        graph2 = this.GetNewRandomGraphForThatOne(5,graph1);\n        init2(graph2);\n\n        let graphres = this.ChooseTask();\n        initres(graphres);\n        this.scc_count = SccBuilder.findComponents(graphres).length;\n    }\n\n\n        //Для меня в будующем: проблема невозможности удать ребро заключается в том, что я создаю два других, тем саммы ломая себе всё.\n        //Это нужно проверить и внести определённые правки. Также нужно узнать как мой модуль добавить на сайт, а не только на гитхаб.\n\n\n    protected ChooseTask(){\n        this.num_0 = Math.round(Math.random() * 100)%7;\n        switch (this.num_0) {\n            case 0:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n                return this.Uni(graphModel1,graphModel2);\n            case 1:\n                this.message_0 = \"Постройте граф, являющийся результатом соединения двух графов.\";\n                return this.Joint(graphModel1,graphModel2);\n            case 2:\n                this.message_0 = \"Постройте граф, являющийся результатом произведения двух графов.\";\n                return this.Product(graphModel1,graphModel2);\n            case 3:\n                this.message_0 = \"Постройте граф, являющийся результатом композиции двух графов.\";\n                return this.Composition(graphModel1,graphModel2);\n            case 4:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\"; // Объединение по Зыкову\n                return this.Uni_Z(graphModel1,graphModel2);\n            case 5:\n                this.message_0 = \"Постройте граф, являющийся результатом пересечения двух графов.\"; // Пересечение\n                return this.Cross(graphModel1,graphModel2);\n            case 6:\n                this.message_0 = \"Постройте граф, являющийся дополнением графа.\"; // Дополнение\n                return this.Addition(graphModel1);\n            case 7:\n                this.message_0 = \"Постройте граф, являющийся результатом декартового произведения двух графов.\"; // Декартово произведение\n                return this.Cartesian_Product(graphModel1,graphModel2);\n            default:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n                return this.Uni(graphModel1,graphModel2);\n        }\n    }\n\n    protected GetNewRandomGraph (num:number){ // рандомный граф\n        let graph: IGraph<IVertex, IEdge>;\n        graph = GraphGenerator.generate(0);\n        var arr = [];\n        for(var i = 0; i<num; i++ ){\n            arr.push(Math.round(Math.random()));\n            if(arr[i]===1){\n                let vert = new Vertex(`${i}`);\n                graph.addVertex(vert);\n            }\n        }\n        for(var i=0;i<num-1;i++){\n            if(arr[i]===1) {\n                for(var j = i+1;j<num;j++){\n                    if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge i+j\n                        let edge = new Edge(graph.getVertex(`${i}`)[0],graph.getVertex(`${j}`)[0],`${i}+${j}`);\n                        graph.addEdge(edge);\n                    }\n                }\n            }\n        }\n        return graph;\n    }\n\n    protected GetNewRandomGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>){ // рандомный, не имеющий общих вершин с первым\n        let graph: IGraph<IVertex, IEdge>;\n        graph = GraphGenerator.generate(0);\n        var arr = [];\n        let length = graph1.vertices.length+1;\n        for(var i = 0; i<num; i++ ){\n            arr.push(Math.round(Math.random()));\n            if(arr[i]===1){\n                let vert = new Vertex(`${i+length}`);\n                graph.addVertex(vert);\n            }\n        }\n        for(var i=0;i<num-1;i++){\n            if(arr[i]===1) {\n                for(var j = i+1;j<num;j++){\n                    if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge i+j\n                        let edge = new Edge(graph.getVertex(`${i+length}`)[0],graph.getVertex(`${j+length}`)[0],`${i+length}+${j+length}`);\n                        graph.addEdge(edge);\n                    }\n                }\n            }\n        }\n        return graph;\n    }\n\n\n\n    protected Uni(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph1.edges.forEach((e: any)=> {\n            let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n            let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n            let e_new: IEdge;\n            e_new = new Edge(vv1,vv2);\n            graphres.addEdge(e_new);\n        });\n        graph2.edges.forEach((e: any)=> {\n            let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n            let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n            let e_new: IEdge;\n            e_new = new Edge(vv1,vv2);\n            graphres.addEdge(e_new);\n        });\n        return graphres;\n    }\n\n    protected Operation2(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение по  (это и есть простое соединение)\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n\n                graph1.vertices.forEach((v1:any)=>{ // дополнение к объединению\n                    if(!(graphres.getEdge(v,v1).length>0)){\n                        let e: IEdge;\n                        e = new Edge(v,v1);\n                        graphres.addEdge(e);\n                    }\n                });\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        return graphres;\n    }\n\n    protected Joint(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach(v=>{\n            graphres.addVertex(v);\n            graph2.vertices.forEach(v1=>{\n                if(!(graphres.getVertex(`${v1.name}`).length>0))\n                    graphres.addVertex(v1);\n                let e: IEdge;\n                e = new Edge(v,v1);\n                graphres.addEdge(e);\n            });\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        return graphres;\n    }\n\n    protected Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Произведение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!=v1.name||u2.name!=v2.name){\n                            if((u1.name===v1.name)&&(v2.isAdjacent(graph2,u2))){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if((u2.name===v2.name)&&(v1.isAdjacent(graph1,u1))){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Composition(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Композиция !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!=v1.name || u2.name!=v2.name){\n                            let e_0: IEdge;\n                            e_0=new Edge(v1,v2)\n                            if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if(v1.isAdjacent(graph1,u1)){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Uni_Z(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение по Зыкову\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph1.vertices.forEach((v1: any)=> {\n            graph2.vertices.forEach((v2: any)=> {\n                if (!(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                    let vv1 = graphres.getVertex(`${v1.name}`)[0];\n                    let vv2 = graphres.getVertex(`${v2.name}`)[0];\n\n                    let e: IEdge;\n                    e = new Edge(vv1,vv2);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n        return graphres;\n    }\n\n    protected Cross(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Пересечение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                if (v1.name == v2.name){\n                    let v_res: IVertex;\n                    v_res = new Vertex(`${v1.name}`);\n                    graphres.addVertex(v_res);\n                }\n            });\n        });\n\n        graph1.edges.forEach(u1=>{\n            graph2.edges.forEach(u2=>{\n                if ((u1.vertexOne.name == u2.vertexOne.name && u1.vertexTwo.name == u2.vertexTwo.name) || (u1.vertexOne.name == u2.vertexTwo.name && u1.vertexTwo.name == u2.vertexOne.name)){\n                    let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n                    let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n\n                    let e: IEdge;\n                    e = new Edge(v1[0],v2[0]);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Addition(graph1: IGraph<IVertex, IEdge>){ // Дополнение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v1.name}`);\n            graphres.addVertex(v_res);\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph1.vertices.forEach(v2=>{\n                let vv1 = v1.name;\n                let vv2 = v2.name;\n                if (v1.name != v2.name && !(v1.isAdjacent(graph1,v2)) && !(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                    let v1 = graphres.getVertex(`${vv1}`);\n                    let v2 = graphres.getVertex(`${vv2}`);\n\n                    let e: IEdge;\n                    e = new Edge(v1[0],v2[0]);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n\n        let graph2: IGraph<IVertex, IEdge>;\n        graph2 = this.GetNewRandomGraph(0);\n        init2(graph2);\n\n\n        return graphres;\n    }\n\n    protected Cartesian_Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Декартово произведение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!=v1.name || u2.name!=v2.name){\n                            let e_0: IEdge;\n                            e_0=new Edge(v1,v2)\n                            if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if(v1.isAdjacent(graph1,u1)){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    public constructor(props: {}) {\n        super(props);\n        store.subscribe(() => {\n            if (store.getState().app.status !== this.state.status) {\n                this.setState({\n                    status: store.getState().app.status,\n                });\n            }\n        });\n        this.task = this.task.bind(this);\n        this.getTaskToolbar = this.getTaskToolbar.bind(this);\n    }\n\n    public render() {\n        const Task: any = this.task();\n        const Toolbar = this.getTaskToolbar();\n        const Area = this.getArea();\n        return (\n            <div className={styles.App} id=\"wrap\">\n                {this.state.status\n                    ? <p>Задание выполнено. Ожидайте ответа от сервера...</p>\n                    : (\n                        <div>\n                            <div className={styles.MainRow}>\n                                <div className={styles.GraphCell}>\n                                    <Area/>\n                                </div>\n                                <div className={styles.ToolCell}>\n                                    <Toolbar/>\n                                </div>\n                                <div className={styles.TaskCell}>\n                                    <p>Задание</p>\n                                    <Task/>\n                                </div>\n                            </div>\n                            <div className={styles.LeftBottom}>\n                                <StudentMark/>\n                            </div>\n                            <div className={styles.LowRow}>\n                                <Console/>\n                            </div>\n                        </div>)}\n            </div>\n        );\n    }//<Task/>\n\n    protected getTaskToolbar() {\n        return Toolbar;\n    }\n\n    protected getArea(): SFC<{}> {\n        return () => <GraphVisualizer\n            graph={graphModel}\n            adapterType={'writable'}\n            namedEdges={false}\n            vertexNaming={true}\n            withoutDragging={true}\n            edgeNaming={false}\n            incidentEdges={false}\n        />;\n        //return () =>\n        //    <GraphVisualizer\n        //        graph={graphModelres}\n        //        adapterType={'readable'}\n        //        namedEdges={false}\n        //        vertexNaming={false}\n        //        withoutDragging={false}\n        //        edgeNaming={false}\n        //        incidentEdges={false}\n        //    />\n    }\n\n    protected task(): SFC<{}> {\n        graphModel.vertices.forEach(v => (console.log(`id = ${v.id}; label = ${v.label}; name = ${v.name}; wawe=${v.wave}.\\n`)));\n        return () =>\n            <div>\n                <p>\n                    {this.message_0}\n                </p>\n                <div>\n                    <p>\n                        <GraphVisualizer\n                            graph={graphModel1}\n                            adapterType={'readable'}\n                            namedEdges={false}\n                            vertexNaming={false}\n                            withoutDragging={true}\n                            edgeNaming={false}\n                            incidentEdges={false}\n                        />\n                    </p>\n                    <p>\n                        <GraphVisualizer\n                            graph={graphModel2}\n                            adapterType={'readable'}\n                            namedEdges={false}\n                            vertexNaming={false}\n                            withoutDragging={true}\n                            edgeNaming={false}\n                            incidentEdges={false}\n                        />\n                    </p>\n                </div>\n            </div>\n    }\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}