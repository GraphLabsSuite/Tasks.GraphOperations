import { StateColor } from "../enums/StateColor";
import { IVertex } from "../types/IVertex";
import { UndirectedGraph } from "../main/UndirectedGraph";
/**
 * State of the graph within recursion
 */
export declare class State {
    /**
     * Vertex colors
     */
    private _vertexColors;
    /**
     * Vertex neighbors
     */
    private _vertexNeighbors;
    /**
     * Dominant number
     */
    private _vertexDominatedNumber;
    /**
     * Number of possible dominants
     */
    private _vertexPossibleDominatingNumber;
    /**
     * Temporal dominating set
     */
    private _tempDs;
    /**
     * Auxiliary list of vertices
     */
    private _verticesList;
    /**
     * Number of vertices being dominated
     */
    nDominated: number;
    /**
     * Level of the recursion
     */
    level: number;
    get tempDs(): IVertex[];
    vertexColor(vertex: IVertex): StateColor;
    setVertexColor(vertex: IVertex, color: StateColor): void;
    vertexNeighbors(vertex: IVertex): IVertex[];
    vertexDominatedNumber(vertex: IVertex): number;
    decrementVertexDominatedNumber(vertex: IVertex): void;
    incrementVertexDominatedNumber(vertex: IVertex): void;
    vertexDominatedNumberValues(): number[];
    vertexPossibleDominatingNumber(vertex: IVertex): number;
    vertexPossibleDominatingNumberValues(): number[];
    decrementVertexPossibleDominatingNumber(vertex: IVertex): void;
    incrementVertexPossibleDominatingNumber(vertex: IVertex): void;
    /**
     * Clones the state for the recursion process
     * @returns {State}
     */
    clone(): State;
    /**
     * @constructor
     * Initialising parameters for the algorithm
     * @param graph
     * @param prototype
     */
    constructor(graph?: UndirectedGraph, prototype?: State);
}
