{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Vertex_1 = require(\"./Vertex\");\n\nvar DirectedWeightedEdge_1 = require(\"./DirectedWeightedEdge\");\n\nvar Graph_1 = require(\"./Graph\");\n\nvar DirectedWeightedGraph =\n/** @class */\nfunction (_super) {\n  __extends(DirectedWeightedGraph, _super);\n  /**\r\n   * @constructor\r\n   */\n\n\n  function DirectedWeightedGraph() {\n    return _super.call(this, true) || this;\n  }\n  /**\r\n   * @static\r\n   * Static builder for the directed weighted graph\r\n   * @param verticesNumber\r\n   * @return {DirectedWeightedGraph}\r\n   */\n\n\n  DirectedWeightedGraph.createEmpty = function (verticesNumber) {\n    var newGraph = new DirectedWeightedGraph();\n\n    for (var i = 0; i < verticesNumber; ++i) newGraph.addVertex(new Vertex_1.Vertex(i.toString(verticesNumber)));\n\n    return newGraph;\n  };\n\n  Object.defineProperty(DirectedWeightedGraph.prototype, \"isDirected\", {\n    /**\r\n     * @override\r\n     * @property\r\n     * @public\r\n     * Shows the graph is directed\r\n     * @return {boolean}\r\n     */\n    get: function () {\n      return true;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectedWeightedGraph.prototype, \"allowMultipleEdges\", {\n    /**\r\n     * @override\r\n     * @property\r\n     * @public\r\n     * Shows the graph is not able to have multiple edges\r\n     * @return {boolean}\r\n     */\n    get: function () {\n      return false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @public\r\n   * Gets the edge by two vertices incident to it\r\n   * @param vertexOne\r\n   * @param vertexTwo\r\n   */\n\n  DirectedWeightedGraph.prototype.getEdge = function (vertexOne, vertexTwo) {\n    return this.edges.filter(function (a) {\n      return a.vertexTwo.equals(vertexTwo) && a.vertexOne.equals(vertexOne);\n    }); //TODO: why IWeightedEdge is not compatible to DirectedWeightedEdge?\n  };\n  /**\r\n   * @override\r\n   * Deep graph-cloning\r\n   * @returns {DirectedWeightedGraph}\r\n   */\n\n\n  DirectedWeightedGraph.prototype.clone = function () {\n    var clone = new DirectedWeightedGraph();\n    this.vertices.forEach(function (v) {\n      return clone.addVertex(new Vertex_1.Vertex(v.name));\n    });\n    this.edges.forEach(function (e) {\n      var dwe = e;\n      var v1 = clone.vertices.filter(function (v) {\n        return v.equals(e.vertexOne);\n      })[0]; //Single\n\n      var v2 = clone.vertices.filter(function (v) {\n        return v.equals(e.vertexTwo);\n      })[0]; //First\n\n      clone.addEdge(new DirectedWeightedEdge_1.DirectedWeightedEdge(v1, v2, dwe.weight));\n    });\n    return clone;\n  };\n\n  return DirectedWeightedGraph;\n}(Graph_1.Graph);\n\nexports.DirectedWeightedGraph = DirectedWeightedGraph;","map":{"version":3,"sources":["../../src/main/DirectedWeightedGraph.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Vertex_1 = require(\"./Vertex\");\r\nvar DirectedWeightedEdge_1 = require(\"./DirectedWeightedEdge\");\r\nvar Graph_1 = require(\"./Graph\");\r\nvar DirectedWeightedGraph = /** @class */ (function (_super) {\r\n    __extends(DirectedWeightedGraph, _super);\r\n    /**\r\n     * @constructor\r\n     */\r\n    function DirectedWeightedGraph() {\r\n        return _super.call(this, true) || this;\r\n    }\r\n    /**\r\n     * @static\r\n     * Static builder for the directed weighted graph\r\n     * @param verticesNumber\r\n     * @return {DirectedWeightedGraph}\r\n     */\r\n    DirectedWeightedGraph.createEmpty = function (verticesNumber) {\r\n        var newGraph = new DirectedWeightedGraph();\r\n        for (var i = 0; i < verticesNumber; ++i)\r\n            newGraph.addVertex(new Vertex_1.Vertex(i.toString(verticesNumber)));\r\n        return newGraph;\r\n    };\r\n    Object.defineProperty(DirectedWeightedGraph.prototype, \"isDirected\", {\r\n        /**\r\n         * @override\r\n         * @property\r\n         * @public\r\n         * Shows the graph is directed\r\n         * @return {boolean}\r\n         */\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DirectedWeightedGraph.prototype, \"allowMultipleEdges\", {\r\n        /**\r\n         * @override\r\n         * @property\r\n         * @public\r\n         * Shows the graph is not able to have multiple edges\r\n         * @return {boolean}\r\n         */\r\n        get: function () {\r\n            return false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @public\r\n     * Gets the edge by two vertices incident to it\r\n     * @param vertexOne\r\n     * @param vertexTwo\r\n     */\r\n    DirectedWeightedGraph.prototype.getEdge = function (vertexOne, vertexTwo) {\r\n        return this.edges.filter(function (a) { return a.vertexTwo.equals(vertexTwo) && a.vertexOne.equals(vertexOne); });\r\n        //TODO: why IWeightedEdge is not compatible to DirectedWeightedEdge?\r\n    };\r\n    /**\r\n     * @override\r\n     * Deep graph-cloning\r\n     * @returns {DirectedWeightedGraph}\r\n     */\r\n    DirectedWeightedGraph.prototype.clone = function () {\r\n        var clone = new DirectedWeightedGraph();\r\n        this.vertices.forEach(function (v) { return clone.addVertex(new Vertex_1.Vertex(v.name)); });\r\n        this.edges.forEach(function (e) {\r\n            var dwe = e;\r\n            var v1 = clone.vertices.filter(function (v) { return v.equals(e.vertexOne); })[0]; //Single\r\n            var v2 = clone.vertices.filter(function (v) { return v.equals(e.vertexTwo); })[0]; //First\r\n            clone.addEdge(new DirectedWeightedEdge_1.DirectedWeightedEdge(v1, v2, dwe.weight));\r\n        });\r\n        return clone;\r\n    };\r\n    return DirectedWeightedGraph;\r\n}(Graph_1.Graph));\r\nexports.DirectedWeightedGraph = DirectedWeightedGraph;\r\n//# sourceMappingURL=DirectedWeightedGraph.js.map"]},"metadata":{},"sourceType":"script"}