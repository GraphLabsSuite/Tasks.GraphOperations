{"ast":null,"code":"import './App.css';\nimport { Vertex, Edge, GraphGenerator } from \"graphlabs.core.graphs\";\nimport 'graphlabs.core.template/dist/main.css';\nimport {\n/*initres, graphModelres, init, graphModel, init1,*/\ngraphModel1, init2, graphModel2 } from './ForMyGraphModel';\nimport { num_0, num_0_changing, message_0_changing } from './ForMeVars'; //Для меня в будующем: проблема невозможности удать ребро заключается в том, что я создаю два других, тем саммы ломая себе всё.\n//Это нужно проверить и внести определённые правки. Также нужно узнать как мой модуль добавить на сайт, а не только на гитхаб.\n\nfunction ChooseTask() {\n  num_0_changing(Math.round(Math.random() * 100) % 7);\n\n  switch (num_0) {\n    case 0:\n      message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\");\n      return Uni(graphModel1, graphModel2);\n\n    case 1:\n      message_0_changing(\"Постройте граф, являющийся результатом соединения двух графов.\");\n      return Joint(graphModel1, graphModel2);\n\n    case 2:\n      message_0_changing(\"Постройте граф, являющийся результатом произведения двух графов.\");\n      return Product(graphModel1, graphModel2);\n\n    case 3:\n      message_0_changing(\"Постройте граф, являющийся результатом композиции двух графов.\");\n      return Composition(graphModel1, graphModel2);\n\n    case 4:\n      message_0_changing(\"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\"); // Объединение по Зыкову\n\n      return Uni_Z(graphModel1, graphModel2);\n\n    case 5:\n      message_0_changing(\"Постройте граф, являющийся результатом пересечения двух графов.\"); // Пересечение\n\n      return Cross(graphModel1, graphModel2);\n\n    case 6:\n      message_0_changing(\"Постройте граф, являющийся дополнением графа.\"); // Дополнение\n\n      return Addition(graphModel1);\n\n    case 7:\n      message_0_changing(\"Постройте граф, являющийся результатом декартового произведения двух графов.\"); // Декартово произведение\n\n      return Cartesian_Product(graphModel1, graphModel2);\n\n    default:\n      message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\");\n      return Uni(graphModel1, graphModel2);\n  }\n}\n\n_c = ChooseTask;\n\nfunction GetNewRandomGraph(num) {\n  // рандомный граф\n  let graph;\n  graph = GraphGenerator.generate(0);\n  var arr = [];\n\n  for (var i = 0; i < num; i++) {\n    arr.push(Math.round(Math.random()));\n\n    if (arr[i] === 1) {\n      let vert = new Vertex(`${i}`);\n      graph.addVertex(vert);\n    }\n  }\n\n  for (var k = 0; k < num - 1; k++) {\n    if (arr[k] === 1) {\n      for (var j = k + 1; j < num; j++) {\n        if (arr[j] === 1 && Math.random() > 0.45) {\n          // 55% chance what is edge k+j\n          let edge = new Edge(graph.getVertex(`${k}`)[0], graph.getVertex(`${j}`)[0], `${k}+${j}`);\n          graph.addEdge(edge);\n        }\n      }\n    }\n  }\n\n  return graph;\n}\n\n_c2 = GetNewRandomGraph;\n\nfunction GetNewRandomGraphForThatOne(num, graph1) {\n  // рандомный, не имеющий общих вершин с первым\n  let graph;\n  graph = GraphGenerator.generate(0);\n  var arr = [];\n  let length = graph1.vertices.length + 1;\n\n  for (var i = 0; i < num; i++) {\n    arr.push(Math.round(Math.random()));\n\n    if (arr[i] === 1) {\n      let vert = new Vertex(`${i + length}`);\n      graph.addVertex(vert);\n    }\n  }\n\n  for (var k = 0; k < num - 1; k++) {\n    if (arr[k] === 1) {\n      for (var j = k + 1; j < num; j++) {\n        if (arr[j] === 1 && Math.random() > 0.45) {\n          // 55% chance what is edge k+j\n          let edge = new Edge(graph.getVertex(`${k + length}`)[0], graph.getVertex(`${j + length}`)[0], `${k + length}+${j + length}`);\n          graph.addEdge(edge);\n        }\n      }\n    }\n  }\n\n  return graph;\n}\n\n_c3 = GetNewRandomGraphForThatOne;\n\nfunction Uni(graph1, graph2) {\n  // объединение\n  let graphres;\n  graphres = GraphGenerator.generate(0);\n  graph1.vertices.forEach(v => {\n    graphres.addVertex(v);\n  });\n  graph1.edges.forEach(e => {\n    graphres.addEdge(e);\n  });\n  graph2.vertices.forEach(v => {\n    if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n      // если нет таких же по имени вершин\n      graphres.addVertex(v);\n    }\n  });\n  graph2.edges.forEach(e => {\n    graphres.addEdge(e);\n  });\n  graph1.edges.forEach(e => {\n    let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n    let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n    let e_new;\n    e_new = new Edge(vv1, vv2);\n    graphres.addEdge(e_new);\n  });\n  graph2.edges.forEach(e => {\n    let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n    let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n    let e_new;\n    e_new = new Edge(vv1, vv2);\n    graphres.addEdge(e_new);\n  });\n  return graphres;\n}\n\n_c4 = Uni;\n\nfunction Joint(graph1, graph2) {\n  // соединение !!!!! без пересечения вершин !!!!!\n  let graphres;\n  graphres = GraphGenerator.generate(0);\n  graph1.vertices.forEach(v => {\n    graphres.addVertex(v);\n    graph2.vertices.forEach(v1 => {\n      if (!(graphres.getVertex(`${v1.name}`).length > 0)) graphres.addVertex(v1);\n      let e;\n      e = new Edge(v, v1);\n      graphres.addEdge(e);\n    });\n  });\n  graph1.edges.forEach(e => {\n    graphres.addEdge(e);\n  });\n  graph2.edges.forEach(e => {\n    graphres.addEdge(e);\n  });\n  return graphres;\n}\n\n_c5 = Joint;\n\nfunction Product(graph1, graph2) {\n  // Произведение !!!!! без пересечения вершин !!!!!\n  let graphres;\n  graphres = GraphGenerator.generate(0);\n  graph1.vertices.forEach(v => {\n    graph2.vertices.forEach(v1 => {\n      let v_res;\n      v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n      graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n      //graphres.addVertex(v_res);\n    });\n  });\n  graph1.vertices.forEach(v1 => {\n    graph2.vertices.forEach(v2 => {\n      graph1.vertices.forEach(u1 => {\n        graph2.vertices.forEach(u2 => {\n          if (u1.name !== v1.name || u2.name !== v2.name) {\n            if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n              let e;\n              e = new Edge(vv1[0], vv2[0]);\n              graphres.addEdge(e);\n            } else if (u2.name === v2.name && v1.isAdjacent(graph1, u1)) {\n              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n              let e;\n              e = new Edge(vv1[0], vv2[0]);\n              graphres.addEdge(e);\n            }\n          }\n        });\n      });\n    });\n  });\n  return graphres;\n}\n\n_c6 = Product;\n\nfunction Composition(graph1, graph2) {\n  // Композиция !!!!! без пересечения вершин !!!!!\n  let graphres;\n  graphres = GraphGenerator.generate(0);\n  graph1.vertices.forEach(v => {\n    graph2.vertices.forEach(v1 => {\n      let v_res;\n      v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n      graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n      //graphres.addVertex(v_res);\n    });\n  });\n  graph1.vertices.forEach(v1 => {\n    graph2.vertices.forEach(v2 => {\n      graph1.vertices.forEach(u1 => {\n        graph2.vertices.forEach(u2 => {\n          if (u1.name !== v1.name || u2.name !== v2.name) {\n            //let e_0: IEdge;\n            //e_0=new Edge(v1,v2)\n            if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n              //graph2.getEdge(v2,u2).length>0 ){\n              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n              let e;\n              e = new Edge(vv1[0], vv2[0]);\n              graphres.addEdge(e);\n            } else if (v1.isAdjacent(graph1, u1)) {\n              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n              let e;\n              e = new Edge(vv1[0], vv2[0]);\n              graphres.addEdge(e);\n            }\n          }\n        });\n      });\n    });\n  });\n  return graphres;\n}\n\n_c7 = Composition;\n\nfunction Uni_Z(graph1, graph2) {\n  // объединение по Зыкову\n  let graphres;\n  graphres = GraphGenerator.generate(0);\n  graph1.vertices.forEach(v => {\n    graphres.addVertex(v);\n  });\n  graph1.edges.forEach(e => {\n    graphres.addEdge(e);\n  });\n  graph2.vertices.forEach(v => {\n    if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n      // если нет таких же по имени вершин\n      graphres.addVertex(v);\n    }\n  });\n  graph2.edges.forEach(e => {\n    graphres.addEdge(e);\n  });\n  graph1.vertices.forEach(v1 => {\n    graph2.vertices.forEach(v2 => {\n      if (!graphres.getVertex(v1.name)[0].isAdjacent(graphres, graphres.getVertex(v2.name)[0])) {\n        let vv1 = graphres.getVertex(`${v1.name}`)[0];\n        let vv2 = graphres.getVertex(`${v2.name}`)[0];\n        let e;\n        e = new Edge(vv1, vv2);\n        graphres.addEdge(e);\n      }\n    });\n  });\n  return graphres;\n}\n\n_c8 = Uni_Z;\n\nfunction Cross(graph1, graph2) {\n  // Пересечение\n  let graphres;\n  graphres = GraphGenerator.generate(0);\n  graph1.vertices.forEach(v1 => {\n    graph2.vertices.forEach(v2 => {\n      if (v1.name === v2.name) {\n        let v_res;\n        v_res = new Vertex(`${v1.name}`);\n        graphres.addVertex(v_res);\n      }\n    });\n  });\n  graph1.edges.forEach(u1 => {\n    graph2.edges.forEach(u2 => {\n      if (u1.vertexOne.name === u2.vertexOne.name && u1.vertexTwo.name === u2.vertexTwo.name || u1.vertexOne.name === u2.vertexTwo.name && u1.vertexTwo.name === u2.vertexOne.name) {\n        let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n        let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n        let e;\n        e = new Edge(v1[0], v2[0]);\n        graphres.addEdge(e);\n      }\n    });\n  });\n  return graphres;\n}\n\n_c9 = Cross;\n\nfunction Addition(graph1) {\n  // Дополнение\n  let graphres;\n  graphres = GraphGenerator.generate(0);\n  graph1.vertices.forEach(v1 => {\n    let v_res;\n    v_res = new Vertex(`${v1.name}`);\n    graphres.addVertex(v_res);\n  });\n  graph1.vertices.forEach(v1 => {\n    graph1.vertices.forEach(v2 => {\n      let vv1 = v1.name;\n      let vv2 = v2.name;\n\n      if (v1.name !== v2.name && !v1.isAdjacent(graph1, v2) && !graphres.getVertex(v1.name)[0].isAdjacent(graphres, graphres.getVertex(v2.name)[0])) {\n        let v1 = graphres.getVertex(`${vv1}`);\n        let v2 = graphres.getVertex(`${vv2}`);\n        let e;\n        e = new Edge(v1[0], v2[0]);\n        graphres.addEdge(e);\n      }\n    });\n  });\n  let graph2;\n  graph2 = GetNewRandomGraph(0);\n  init2(graph2);\n  return graphres;\n}\n\n_c10 = Addition;\n\nfunction Cartesian_Product(graph1, graph2) {\n  // Декартово произведение !!!!! без пересечения вершин !!!!!\n  let graphres;\n  graphres = GraphGenerator.generate(0);\n  graph1.vertices.forEach(v => {\n    graph2.vertices.forEach(v1 => {\n      let v_res;\n      v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n      graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n      //graphres.addVertex(v_res);\n    });\n  });\n  graph1.vertices.forEach(v1 => {\n    graph2.vertices.forEach(v2 => {\n      graph1.vertices.forEach(u1 => {\n        graph2.vertices.forEach(u2 => {\n          if (u1.name !== v1.name || u2.name !== v2.name) {\n            //let e_0: IEdge;\n            //e_0=new Edge(v1,v2)\n            if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n              //graph2.getEdge(v2,u2).length>0 ){\n              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n              let e;\n              e = new Edge(vv1[0], vv2[0]);\n              graphres.addEdge(e);\n            } else if (v1.isAdjacent(graph1, u1)) {\n              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n              let e;\n              e = new Edge(vv1[0], vv2[0]);\n              graphres.addEdge(e);\n            }\n          }\n        });\n      });\n    });\n  });\n  return graphres;\n}\n\n_c11 = Cartesian_Product;\nexport { GetNewRandomGraph, GetNewRandomGraphForThatOne, ChooseTask };\n\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;\n\n$RefreshReg$(_c, \"ChooseTask\");\n$RefreshReg$(_c2, \"GetNewRandomGraph\");\n$RefreshReg$(_c3, \"GetNewRandomGraphForThatOne\");\n$RefreshReg$(_c4, \"Uni\");\n$RefreshReg$(_c5, \"Joint\");\n$RefreshReg$(_c6, \"Product\");\n$RefreshReg$(_c7, \"Composition\");\n$RefreshReg$(_c8, \"Uni_Z\");\n$RefreshReg$(_c9, \"Cross\");\n$RefreshReg$(_c10, \"Addition\");\n$RefreshReg$(_c11, \"Cartesian_Product\");","map":{"version":3,"sources":["/home/ilya/UIR/test_5/src/Ops.ts"],"names":["Vertex","Edge","GraphGenerator","graphModel1","init2","graphModel2","num_0","num_0_changing","message_0_changing","ChooseTask","Math","round","random","Uni","Joint","Product","Composition","Uni_Z","Cross","Addition","Cartesian_Product","GetNewRandomGraph","num","graph","generate","arr","i","push","vert","addVertex","k","j","edge","getVertex","addEdge","GetNewRandomGraphForThatOne","graph1","length","vertices","graph2","graphres","forEach","v","edges","e","name","vv1","vertexOne","vv2","vertexTwo","e_new","v1","v_res","v2","u1","u2","isAdjacent"],"mappings":"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","sourcesContent":["import './App.css';\nimport {  IGraph, IVertex, IEdge, Vertex, Edge, GraphGenerator } from \"graphlabs.core.graphs\";\nimport 'graphlabs.core.template/dist/main.css';\n\nimport { /*initres, graphModelres, init, graphModel, init1,*/ graphModel1, init2, graphModel2 } from './ForMyGraphModel';\nimport { num_0, num_0_changing, message_0_changing } from './ForMeVars';\n\n\n    //Для меня в будующем: проблема невозможности удать ребро заключается в том, что я создаю два других, тем саммы ломая себе всё.\n    //Это нужно проверить и внести определённые правки. Также нужно узнать как мой модуль добавить на сайт, а не только на гитхаб.\n\n\nfunction ChooseTask(){\n    num_0_changing(Math.round(Math.random() * 100)%7);\n    switch (num_0) {\n        case 0:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\");\n            return Uni(graphModel1,graphModel2);\n        case 1:\n            message_0_changing(\"Постройте граф, являющийся результатом соединения двух графов.\");\n            return Joint(graphModel1,graphModel2);\n        case 2:\n            message_0_changing(\"Постройте граф, являющийся результатом произведения двух графов.\");\n            return Product(graphModel1,graphModel2);\n        case 3:\n            message_0_changing(\"Постройте граф, являющийся результатом композиции двух графов.\");\n            return Composition(graphModel1,graphModel2);\n        case 4:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\");// Объединение по Зыкову\n            return Uni_Z(graphModel1,graphModel2);\n        case 5:\n            message_0_changing(\"Постройте граф, являющийся результатом пересечения двух графов.\");// Пересечение\n            return Cross(graphModel1,graphModel2);\n        case 6:\n            message_0_changing(\"Постройте граф, являющийся дополнением графа.\"); // Дополнение\n            return Addition(graphModel1);\n        case 7:\n            message_0_changing(\"Постройте граф, являющийся результатом декартового произведения двух графов.\");// Декартово произведение\n            return Cartesian_Product(graphModel1,graphModel2);\n        default:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\");\n            return Uni(graphModel1,graphModel2);\n    }\n}\n\n\nfunction GetNewRandomGraph (num:number){ // рандомный граф\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    var arr = [];\n    for(var i = 0; i<num; i++ ){\n        arr.push(Math.round(Math.random()));\n        if(arr[i]===1){\n            let vert = new Vertex(`${i}`);\n            graph.addVertex(vert);\n        }\n    }\n    for(var k=0;k<num-1;k++){\n        if(arr[k]===1) {\n            for(var j = k+1;j<num;j++){\n                if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge k+j\n                    let edge = new Edge(graph.getVertex(`${k}`)[0],graph.getVertex(`${j}`)[0],`${k}+${j}`);\n                    graph.addEdge(edge);\n                }\n            }\n        }\n    }\n    return graph;\n}\n\nfunction GetNewRandomGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>){ // рандомный, не имеющий общих вершин с первым\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    var arr = [];\n    let length = graph1.vertices.length+1;\n    for(var i = 0; i<num; i++ ){\n        arr.push(Math.round(Math.random()));\n        if(arr[i]===1){\n            let vert = new Vertex(`${i+length}`);\n            graph.addVertex(vert);\n        }\n    }\n    for(var k=0;k<num-1;k++){\n        if(arr[k]===1) {\n            for(var j = k+1;j<num;j++){\n                if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge k+j\n                    let edge = new Edge(graph.getVertex(`${k+length}`)[0],graph.getVertex(`${j+length}`)[0],`${k+length}+${j+length}`);\n                    graph.addEdge(edge);\n                }\n            }\n        }\n    }\n    return graph;\n}\n\nfunction Uni(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach((v:any)=>{\n        graphres.addVertex(v);\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.vertices.forEach((v: any)=>{\n        if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n            graphres.addVertex(v);\n        }\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph1.edges.forEach((e: any)=> {\n        let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n        let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n        let e_new: IEdge;\n        e_new = new Edge(vv1,vv2);\n        graphres.addEdge(e_new);\n    });\n    graph2.edges.forEach((e: any)=> {\n        let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n        let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n        let e_new: IEdge;\n        e_new = new Edge(vv1,vv2);\n        graphres.addEdge(e_new);\n    });\n    return graphres;\n}\n\nfunction Joint(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v=>{\n        graphres.addVertex(v);\n        graph2.vertices.forEach(v1=>{\n            if(!(graphres.getVertex(`${v1.name}`).length>0))\n                graphres.addVertex(v1);\n            let e: IEdge;\n            e = new Edge(v,v1);\n            graphres.addEdge(e);\n        });\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    return graphres;\n}\n\nfunction Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Произведение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name||u2.name!==v2.name){\n                        if((u1.name===v1.name)&&(v2.isAdjacent(graph2,u2))){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if((u2.name===v2.name)&&(v1.isAdjacent(graph1,u1))){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nfunction Composition(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Композиция !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name || u2.name!==v2.name){\n                        //let e_0: IEdge;\n                        //e_0=new Edge(v1,v2)\n                        if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if(v1.isAdjacent(graph1,u1)){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nfunction Uni_Z(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение по Зыкову\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach((v:any)=>{\n        graphres.addVertex(v);\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.vertices.forEach((v: any)=>{\n        if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n            graphres.addVertex(v);\n        }\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph1.vertices.forEach((v1: any)=> {\n        graph2.vertices.forEach((v2: any)=> {\n            if (!(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                let vv1 = graphres.getVertex(`${v1.name}`)[0];\n                let vv2 = graphres.getVertex(`${v2.name}`)[0];\n\n                let e: IEdge;\n                e = new Edge(vv1,vv2);\n                graphres.addEdge(e);\n            }\n        });\n    });\n    return graphres;\n}\n\nfunction Cross(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Пересечение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            if (v1.name === v2.name){\n                let v_res: IVertex;\n                v_res = new Vertex(`${v1.name}`);\n                graphres.addVertex(v_res);\n            }\n        });\n    });\n\n    graph1.edges.forEach(u1=>{\n        graph2.edges.forEach(u2=>{\n            if ((u1.vertexOne.name === u2.vertexOne.name && u1.vertexTwo.name === u2.vertexTwo.name) || (u1.vertexOne.name === u2.vertexTwo.name && u1.vertexTwo.name === u2.vertexOne.name)){\n                let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n                let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n\n                let e: IEdge;\n                e = new Edge(v1[0],v2[0]);\n                graphres.addEdge(e);\n            }\n        });\n    });\n\n    return graphres;\n}\n\nfunction Addition(graph1: IGraph<IVertex, IEdge>){ // Дополнение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v1=>{\n        let v_res: IVertex;\n        v_res = new Vertex(`${v1.name}`);\n        graphres.addVertex(v_res);\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph1.vertices.forEach(v2=>{\n            let vv1 = v1.name;\n            let vv2 = v2.name;\n            if (v1.name !== v2.name && !(v1.isAdjacent(graph1,v2)) && !(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                let v1 = graphres.getVertex(`${vv1}`);\n                let v2 = graphres.getVertex(`${vv2}`);\n\n                let e: IEdge;\n                e = new Edge(v1[0],v2[0]);\n                graphres.addEdge(e);\n            }\n        });\n    });\n\n    let graph2: IGraph<IVertex, IEdge>;\n    graph2 = GetNewRandomGraph(0);\n    init2(graph2);\n\n\n    return graphres;\n}\n\nfunction Cartesian_Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Декартово произведение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name || u2.name!==v2.name){\n                        //let e_0: IEdge;\n                        //e_0=new Edge(v1,v2)\n                        if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if(v1.isAdjacent(graph1,u1)){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nexport { GetNewRandomGraph, GetNewRandomGraphForThatOne, ChooseTask };"]},"metadata":{},"sourceType":"module"}