"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CircleVertexVisualizer_1 = require("./CircleVertexVisualizer");
var GeometricGraph_1 = require("../geometrics/GeometricGraph");
var EdgeVisualizer_1 = require("./EdgeVisualizer");
var CircleGraphVisualizer = /** @class */ (function () {
    function CircleGraphVisualizer(graph) {
        this.geometric = new GeometricGraph_1.GeometricGraph(graph);
        this.width = graph.vertices.length * 100;
        this.height = graph.vertices.length * 100;
    }
    /**
     * Function of calculating coordinates of the geometric graph
     */
    CircleGraphVisualizer.prototype.calculate = function () {
        this.geometric.vertices = [];
        this.geometric.edges = [];
        var vertexAmount = this.geometric.graph.vertices.length;
        if (vertexAmount > 1) {
            // Calculating phi angle between two vertices
            var phi = 2 * Math.PI / vertexAmount;
            //Approximating vertexRadius value
            var radius1 = (Math.min(this.width, this.height)) / 2;
            var grandCircleLength1 = radius1 * 2 * Math.PI;
            var vertexRadius1 = grandCircleLength1 / (vertexAmount * 4);
            // Get real data
            var radius = (Math.min(this.width, this.height) - vertexRadius1 * 2) / 2;
            var grandCircleLength = radius * 2 * Math.PI;
            var vertexRadius = grandCircleLength / (vertexAmount * 4);
            // Calculating radius of the vertex circle (10 - default radius, 2 * 10 - diametr, x2 - between two vertices
            // const radius: number = (vertexAmount * 4 * 10) / (2 * Math.PI);
            var x_center = this.width / 2;
            var y_center = this.height / 2;
            var n = 0;
            for (var _i = 0, _a = this.geometric.graph.vertices; _i < _a.length; _i++) {
                var vertex = _a[_i];
                var y = radius * Math.cos(n * phi) + y_center;
                var x = radius * Math.sin(n * phi) + x_center;
                this.geometric.vertices.push(CircleVertexVisualizer_1.CircleVertexVisualizer.calculate(vertex, x, y, vertexRadius));
                n++;
            }
            var _loop_1 = function (edge) {
                var p1 = this_1.geometric.vertices.filter(function (v) { return v.label == edge.vertexOne.name; })[0].center;
                var p2 = this_1.geometric.vertices.filter(function (v) { return v.label == edge.vertexTwo.name; })[0].center;
                this_1.geometric.edges.push(EdgeVisualizer_1.EdgeVisualizer.calculate(edge, p1, p2));
            };
            var this_1 = this;
            for (var _b = 0, _c = this.geometric.graph.edges; _b < _c.length; _b++) {
                var edge = _c[_b];
                _loop_1(edge);
            }
        }
        else if (vertexAmount == 1) {
            var length_1 = (Math.min(this.width, this.height)) / 2;
            var vertex = this.geometric.graph.vertices[0];
            var x_center = this.width / 2;
            var y_center = this.height / 2;
            this.geometric.vertices.push(CircleVertexVisualizer_1.CircleVertexVisualizer.calculate(vertex, x_center, y_center, length_1 / 5));
        }
    };
    return CircleGraphVisualizer;
}());
exports.CircleGraphVisualizer = CircleGraphVisualizer;
//# sourceMappingURL=CircleGraphVisualizer.js.map