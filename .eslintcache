[{"/home/ilya/UIR/Tasks.GraphOperations/src/index.tsx":"1","/home/ilya/UIR/Tasks.GraphOperations/src/reportWebVitals.ts":"2","/home/ilya/UIR/Tasks.GraphOperations/src/App.tsx":"3","/home/ilya/UIR/Tasks.GraphOperations/src/ForMyGraphModel.ts":"4","/home/ilya/UIR/Tasks.GraphOperations/src/ForMeVars.ts":"5","/home/ilya/UIR/Tasks.GraphOperations/src/Ops.ts":"6","/home/ilya/UIR/Tasks.GraphOperations/src/CheckAnswer.ts":"7","/home/ilya/UIR/Tasks.GraphOperations/src/GraphsInit.ts":"8"},{"size":500,"mtime":1612041338314,"results":"9","hashOfConfig":"10"},{"size":425,"mtime":1612041338322,"results":"11","hashOfConfig":"10"},{"size":9492,"mtime":1617497594721,"results":"12","hashOfConfig":"10"},{"size":1060,"mtime":1612104314915,"results":"13","hashOfConfig":"10"},{"size":907,"mtime":1617496421762,"results":"14","hashOfConfig":"10"},{"size":13457,"mtime":1617032804935,"results":"15","hashOfConfig":"10"},{"size":3959,"mtime":1617497679713,"results":"16","hashOfConfig":"10"},{"size":2652,"mtime":1617044805672,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"zzjyth",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"20"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32","usedDeprecatedRules":"33"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"20"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"20"},"/home/ilya/UIR/Tasks.GraphOperations/src/index.tsx",[],["40","41"],"/home/ilya/UIR/Tasks.GraphOperations/src/reportWebVitals.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/App.tsx",["42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58"],"import React, {FormEvent} from 'react';\n//import logo from './logo.svg';\nimport './App.css';\nimport {\n    ToolButton,\n    ToolButtonList,/* IGraphView, IMatrixView, INGraphsView, State, ToolButton*/\n} from \"graphlabs.core.template\";\nimport { GraphVisualizer, Template, Toolbar, store, StudentMark, Console, graphActionCreators, adapter } from \"graphlabs.core.template\";\nimport {  /*Graph, SccBuilder, Vertex, Edge,*/ IGraph, IVertex, IEdge, GraphGenerator } from \"graphlabs.core.graphs\";\nimport styles from './Template.module.scss';\nimport 'graphlabs.core.template/dist/main.css';\nimport {WritableAdapter} from \"graphlabs.core.visualizer\";\n\nimport { /*Component,*/ SFC} from 'react';\nimport { init1, graphModel1, init2, graphModel2, initres, /*graphModelres,*/ init, graphModel } from './ForMyGraphModel';\nimport {message_0, message_0_changing, num_0, num_0_changing, message_1, message_1_changing, mark_0, mark_0_changing, T_s, T_s_changing, T_s_shawing} from './ForMeVars';\nimport { ChooseTask } from './Ops';\nimport { CheckingAnswer, StartDifficult, LastCheckingAnswer } from \"./CheckAnswer\";\nimport { GraphsInit } from \"./GraphsInit\"\n\nclass App extends Template {\n\n    public state = {\n        status: store.getState().app.status,\n    };\n\n    componentWillMount() {\n        StartDifficult();\n        mark_0_changing(0);\n        GraphsInit();\n        let timerId = setInterval(()=>{T_s_changing(T_s-1);this.forceUpdate();}, 1000);\n        window.setTimeout(()=>{clearInterval(timerId);LastCheckingAnswer();},1000*45*60);\n    }\n\n    /*public constructor(props: {}) { // не совсем понимаю, почему овервайт этих функций происходит автоматически и без конструктора\n        super(props);\n        this.render = this.render.bind(this);\n        this.getArea = this.getArea.bind(this);\n        this.task = this.task.bind(this);\n        this.getTaskToolbar = this.getTaskToolbar.bind(this);\n    }*/\n\n    /*public render():JSX.Element {\n        const Task: any = this.task();\n        const Toolbar = this.getTaskToolbar();\n        const Area = this.getArea51();\n        return (\n            <div className={styles.App} id=\"wrap\">\n                {this.state.status\n                    ? <p>Задание выполнено. Ожидайте ответа от сервера...</p>\n                    : (\n                        <div>\n                            <div className={styles.MainRow}>\n                                <div className={styles.GraphCell}>\n                                    <Area/>\n                                </div>\n                                <div className={styles.ToolCell}>\n                                    <Toolbar/>\n                                </div>\n                                <div className={styles.TaskCell}>\n                                    <p>Задание</p>\n                                    <Task/>\n                                </div>\n                            </div>\n                            <div className={styles.LeftBottom}>\n                                <StudentMark/>\n                            </div>\n                            <div className={styles.LowRow}>\n                                <Console/>\n                            </div>\n                        </div>)}\n            </div>\n        );\n    }*/\n\n\n\n    // 1) разобраться со store, dispatch и др\n\n\n    protected getTaskToolbar() {\n        //super.getTaskToolbar()\n\n        Toolbar.prototype.getButtonList = () => {\n            function beforeComplete(this: App):  Promise<{ success: boolean; fee: number }> {\n                return new Promise((resolve => {\n                    resolve(LastCheckingAnswer());\n                }));\n            }\n            ToolButtonList.prototype.beforeComplete = beforeComplete.bind(this);\n            ToolButtonList.prototype.help = () => `В данном задании вы должны построить результат операции, указанной в задании в правой части экрана. Для этого вы можете добавлять любое число вершин/рёбер. Также вы можете удалять любое число вершин, не инцидентных ни одному ребру или рёбер. Оценка зависит только от того, правильно ли вы построите граф.`;\n\n            ToolButtonList.prototype.toolButtons = {\n                \"http://gl-backend.svtz.ru:5000/odata/downloadImage(name='add_vertex.png')\": () => {\n                    const start = new Date().getTime();\n                    adapter.addVertex();\n                    const end = new Date().getTime();\n                    T_s_changing(T_s - Math.round((end-start)/1000));\n                },\n                \"http://gl-backend.svtz.ru:5000/odata/downloadImage(name='add_edge.png')\": () => { //  Меняю имя всем рёбрам на адекватные - ужасный костыль\n                    const start = new Date().getTime();\n                    adapter.addEdge();\n                    graphModel.edges.forEach((e:IEdge, i=0)=>{e.name = `${i++}`;});\n                    const end = new Date().getTime();\n                    T_s_changing(T_s - Math.round((end-start)/1000));\n                },\n                \"http://gl-backend.svtz.ru:5000/odata/downloadImage(name='remove_vertex.png')\": () => { //  Меняю имя всем рёбрам на адекватные - ужасный костыль\n                    const start = new Date().getTime();\n                    adapter.removeVertex();\n                    const end = new Date().getTime();\n                    T_s_changing(T_s - Math.round((end-start)/1000));\n                },\n                \"http://gl-backend.svtz.ru:5000/odata/downloadImage(name='remove_edge.png')\": () => { //  Меняю имя всем рёбрам на адекватные - ужасный костыль\n                    const start = new Date().getTime();\n                    adapter.removeEdge();\n                    const end = new Date().getTime();\n                    T_s_changing(T_s - Math.round((end-start)/1000));\n                }\n            };\n            return ToolButtonList;\n        };\n        Toolbar.prototype.render = () => {\n            const Buttons = Toolbar.prototype.getButtonList();\n            return (\n                <div>\n                    <div>Панель инструментов</div>\n                    <Buttons/>\n                    <button type={\"button\"} style={{border: '1px double black', background: 'white', margin: '4px'}} onClick={()=>{\n                        CheckingAnswer();\n                        num_0_changing(num_0+1);\n                        GraphsInit();\n                        this.forceUpdate();\n                        if (num_0 === 7){  // удалить кнопку было бы хорошо\n                            message_1_changing(\"Завершите выполнение теста.\");\n                            this.disable();\n                        }\n                    }}>{message_1}</button>\n                    <div>Time left: {T_s_shawing()}</div>\n                </div>);\n        }\n        return Toolbar;\n    }\n\n    protected disable(){\n        let element = document.getElementsByTagName('button')[0];\n        if (element != null) {\n            element.setAttribute('disabled','disabled');\n        }\n    }\n\n    protected getArea(): SFC<{}> {\n        return () => <div>\n            <p>\n                <GraphVisualizer\n                    graph={graphModel}\n                    adapterType={'writable'}\n                    namedEdges={false}\n                    vertexNaming={true}\n                    withoutDragging={true}\n                    edgeNaming={false}\n                    incidentEdges={false}\n                />\n            </p>\n        </div>;\n\n        //return () =>\n        //    <GraphVisualizer\n        //        graph={graphModelres}\n        //        adapterType={'readable'}\n        //        namedEdges={false}\n        //        vertexNaming={false}\n        //        withoutDragging={false}\n        //        edgeNaming={false}\n        //        incidentEdges={false}\n        //    />;\n    }\n\n    protected task(): SFC<{}> {\n        return () =>\n            <div>\n                <p>\n                    {message_0}\n                </p>\n                <div>\n                    <p>\n                        {num_0!==1?\"1.\":''}<GraphVisualizer\n                            graph={graphModel1}\n                            adapterType={'readable'}\n                            namedEdges={false}\n                            vertexNaming={false}\n                            withoutDragging={true}\n                            edgeNaming={false}\n                            incidentEdges={false}\n                        />\n                        {num_0!==1?\"2.\":''}<GraphVisualizer\n                            graph={graphModel2}\n                            adapterType={'readable'}\n                            namedEdges={false}\n                            vertexNaming={false}\n                            withoutDragging={true}\n                            edgeNaming={false}\n                            incidentEdges={false}\n                        />\n                    </p>\n                </div>\n            </div>;\n    }\n}\n\nexport default App;\n","/home/ilya/UIR/Tasks.GraphOperations/src/ForMyGraphModel.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/ForMeVars.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/Ops.ts",["59"],"import './App.css';\nimport {  IGraph, IVertex, IEdge, Vertex, Edge, GraphGenerator } from \"graphlabs.core.graphs\";\nimport 'graphlabs.core.template/dist/main.css';\n\nimport { /*initres, graphModelres, init, graphModel, init1,*/ graphModel1, init2, graphModel2 } from './ForMyGraphModel';\nimport { num_0, num_0_changing, message_0_changing } from './ForMeVars';\n\nfunction ChooseTask(){\n    switch (num_0) {\n        case 0:\n            message_0_changing(\"Постройте граф, являющийся результатом пересечения двух графов.\");// вершины пересекаются\n            return Cross(graphModel1,graphModel2);\n        case 1:\n            message_0_changing(\"Постройте граф, являющийся дополнением графа.\"); // один граф\n            return Addition(graphModel1);\n        case 2:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\"); // вершины пересекаются\n            return Uni(graphModel1,graphModel2);\n        case 3:\n            message_0_changing(\"Постройте граф, являющийся результатом соединения (по Зыкову) двух графов.\"); // вершины пока не пересекаются\n            return Uni_Z(graphModel1,graphModel2);\n        case 4:\n            message_0_changing(\"Постройте граф, являющийся результатом соединения двух графов.\"); // вершины пока не пересекаются\n            return Joint(graphModel1,graphModel2);\n        case 5:\n            message_0_changing(\"Постройте граф, являющийся результатом произведения двух графов.\"); // вершины пока не пересекаются\n            return Product(graphModel1,graphModel2);\n        case 6:\n            message_0_changing(\"Постройте граф, являющийся результатом композиции двух графов.\"); // вершины пока не пересекаются\n            return Composition(graphModel1,graphModel2);\n        case 7:\n            message_0_changing(\"Постройте граф, являющийся результатом декартового произведения двух графов.\"); // вершины пока не пересекаются\n            return Cartesian_Product(graphModel1,graphModel2);\n        default:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\");\n            return Uni(graphModel1,graphModel2);\n    }\n}\n\nfunction Uni(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach((v:any)=>{\n        graphres.addVertex(v);\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.vertices.forEach((v: any)=>{\n        if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n            graphres.addVertex(v);\n        }\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph1.edges.forEach((e: any)=> {\n        let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n        let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n        let e_new: IEdge;\n        e_new = new Edge(vv1,vv2);\n        graphres.addEdge(e_new);\n    });\n    graph2.edges.forEach((e: any)=> {\n        let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n        let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n        let e_new: IEdge;\n        e_new = new Edge(vv1,vv2);\n        graphres.addEdge(e_new);\n    });\n    return graphres;\n}\n\nfunction Joint(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v=>{\n        graphres.addVertex(v);\n        graph2.vertices.forEach(v1=>{\n            if(!(graphres.getVertex(`${v1.name}`).length>0))\n                graphres.addVertex(v1);\n            let e: IEdge;\n            e = new Edge(v,v1);\n            graphres.addEdge(e);\n        });\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    return graphres;\n}\n\nfunction Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Произведение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name||u2.name!==v2.name){\n                        if((u1.name===v1.name)&&(v2.isAdjacent(graph2,u2))){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if((u2.name===v2.name)&&(v1.isAdjacent(graph1,u1))){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nfunction Composition(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Композиция !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name || u2.name!==v2.name){\n                        //let e_0: IEdge;\n                        //e_0=new Edge(v1,v2)\n                        if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if(v1.isAdjacent(graph1,u1)){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nfunction Uni_Z(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение по Зыкову\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach((v:any)=>{\n        graphres.addVertex(v);\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.vertices.forEach((v: any)=>{\n        if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n            graphres.addVertex(v);\n        }\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph1.vertices.forEach((v1: any)=> {\n        graph2.vertices.forEach((v2: any)=> {\n            if (!(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                let vv1 = graphres.getVertex(`${v1.name}`)[0];\n                let vv2 = graphres.getVertex(`${v2.name}`)[0];\n\n                let e: IEdge;\n                e = new Edge(vv1,vv2);\n                graphres.addEdge(e);\n            }\n        });\n    });\n    return graphres;\n}\n\nfunction Cross(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Пересечение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            if (v1.name === v2.name){\n                let v_res: IVertex;\n                v_res = new Vertex(`${v1.name}`);\n                graphres.addVertex(v_res);\n            }\n        });\n    });\n\n    graph1.edges.forEach(u1=>{\n        graph2.edges.forEach(u2=>{\n            if ((u1.vertexOne.name === u2.vertexOne.name && u1.vertexTwo.name === u2.vertexTwo.name) || (u1.vertexOne.name === u2.vertexTwo.name && u1.vertexTwo.name === u2.vertexOne.name)){\n                let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n                let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n\n                let e: IEdge;\n                e = new Edge(v1[0],v2[0]);\n                graphres.addEdge(e);\n            }\n        });\n    });\n\n    return graphres;\n}\n\nfunction Addition(graph1: IGraph<IVertex, IEdge>){ // Дополнение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v1=>{\n        let v_res: IVertex;\n        v_res = new Vertex(`${v1.name}`);\n        graphres.addVertex(v_res);\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph1.vertices.forEach(v2=>{\n            let vv1 = v1.name;\n            let vv2 = v2.name;\n            if (v1.name !== v2.name && !(v1.isAdjacent(graph1,v2)) && !(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                let v1 = graphres.getVertex(`${vv1}`);\n                let v2 = graphres.getVertex(`${vv2}`);\n\n                let e: IEdge;\n                e = new Edge(v1[0],v2[0]);\n                graphres.addEdge(e);\n            }\n        });\n    });\n\n    let graph2: IGraph<IVertex, IEdge>;\n    graph2 = GraphGenerator.generate(0);\n    init2(graph2);\n\n\n    return graphres;\n}\n\nfunction Cartesian_Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Декартово произведение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name || u2.name!==v2.name){\n                        //let e_0: IEdge;\n                        //e_0=new Edge(v1,v2)\n                        if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if(v1.isAdjacent(graph1,u1)){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nexport { ChooseTask };",["60","61"],"/home/ilya/UIR/Tasks.GraphOperations/src/CheckAnswer.ts",["62","63","64","65","66"],"import {graphModel, graphModelres} from \"./ForMyGraphModel\";\nimport { IVertex } from 'graphlabs.core.graphs';\nimport { store } from 'graphlabs.core.template';\nimport {message_0, message_0_changing, num_0, num_0_changing, message_1, message_1_changing, mark_0, mark_0_changing, k_s, k_s_changing} from './ForMeVars';\n\nfunction LastCheckingAnswer(){\n    mark_0_changing(Math.round(mark_0*100/(8*9+k_s[0]+k_s[1]+k_s[2]+k_s[3]+k_s[4]+k_s[5]+k_s[6]+k_s[7])));\n    window.alert(`Вы вполнили задания на оценку: ${mark_0}`);\n    //window.alert(`k_s: ${k_s}`);\n    store.getState().notifier.score = mark_0; // здесь я меняю оценку.\n    return Promise.resolve({success: mark_0 === 100, fee: mark_0});\n}\n\nfunction CheckingAnswer(){// мое добавление для проверки оценки: процент одинаковости\n    let markN = 100;\n    graphModelres.vertices.forEach((v:any)=>{ // проверка на совпадения вершин\n        if(graphModel.getVertex(v.name).length===1){\n            //markN+=50/(graphModelres.vertices.length);\n        }\n        else{\n            markN=0;\n        }\n    });\n    graphModel.vertices.forEach((v:any)=>{ // проверка на лишние вершины\n        if(graphModelres.getVertex(v.name).length===0){\n            //markN-=50/(graphModelres.vertices.length);\n            markN=0;\n        }\n    });\n\n    let num = 0;\n    graphModel.vertices.forEach((v1:IVertex)=>{\n        graphModel.vertices.forEach((v2:IVertex)=>{\n            graphModelres.vertices.forEach((u1:IVertex)=>{\n                graphModelres.vertices.forEach((u2:IVertex)=>{\n                    if( ( v1.name === u1.name && v2.name === u2.name ) || ( v1.name === u2.name && v2.name === u1.name ) ){\n                        if( v1.name !== v2.name && u1.name !== u2.name ){\n                            if( v1.isAdjacent(graphModel, v2) ){\n                                if( u1.isAdjacent(graphModelres, u2) ) {\n                                    num++;\n                                }\n                            }\n                        }\n                    }\n                });\n            });\n        });\n    });\n    num/=2*2;\n    if(num !== (graphModel.edges.length + graphModelres.edges.length)/2 ){\n        markN = 0;\n    }\n\n    if(markN===100){\n        window.alert(`Вы верно выполнили задание`);\n        mark_0_changing(mark_0+9+k_s[num_0]);\n    }\n\n    if(markN<100){\n        window.alert(`Вы неверно выполнили задание`);\n    }\n}\n\nfunction StartDifficult(){\n    let new_k_s = [0,0,0,0,0,0,0,0];\n    let all_num = 0;\n    for (let i=0; i<8; i++){\n        new_k_s = k_s;\n        new_k_s[i]+=Math.round(Math.random()*99+1);\n        all_num+=new_k_s[i];\n    }\n    let true_num=0;\n    for (let i=0; i<8; i++){\n        new_k_s[i]=Math.round(39*new_k_s[i]/all_num);\n        true_num+=new_k_s[i];\n    }\n    let max_0=0;\n    let min_0=0;\n    let schetchick=true;\n    while (true_num !==39){\n        if(true_num>39){\n            max_0 = Math.max(new_k_s[0], new_k_s[1], new_k_s[2], new_k_s[3], new_k_s[4], new_k_s[5], new_k_s[6], new_k_s[7]);\n            for (let i=0; i<8; i++){\n                if (schetchick && max_0 === new_k_s[i]){\n                    new_k_s[i]--;\n                    true_num--;\n                    schetchick = false;\n                }\n            }\n            schetchick = true;\n        }\n        else{\n            min_0 = Math.min(new_k_s[0], new_k_s[1], new_k_s[2], new_k_s[3], new_k_s[4], new_k_s[5], new_k_s[6], new_k_s[7]);\n            for (let i=0; i<8; i++){\n                if (schetchick && min_0 === new_k_s[i]){\n                    new_k_s[i]++;\n                    true_num++;\n                    schetchick = false;\n                }\n            }\n            schetchick = true;\n        }\n    }\n    k_s_changing(new_k_s);\n}\n\nexport {CheckingAnswer, StartDifficult, LastCheckingAnswer};","/home/ilya/UIR/Tasks.GraphOperations/src/GraphsInit.ts",["67","68","69","70","71","72","73","74"],"import {init, init1, init2, initres} from \"./ForMyGraphModel\";\nimport {Edge, GraphGenerator, IEdge, IGraph, IVertex, Vertex} from 'graphlabs.core.graphs';\nimport {ChooseTask} from \"./Ops\";\nimport {message_0, message_0_changing, num_0, num_0_changing, message_1, message_1_changing, mark_0, mark_0_changing, k_s, k_s_changing} from './ForMeVars';\n\nfunction GraphsInit(){\n    let graph: IGraph<IVertex, IEdge>;\n    let num_vert_plus_edg = num_0<=4?(9+k_s[num_0]):(Math.round((9+k_s[num_0])/2));\n\n    graph = GraphGenerator.generate(0);\n    init(graph);\n\n    let graph1: IGraph<IVertex, IEdge>;\n    graph1 = GetNewRandomGraph(num_vert_plus_edg);\n    init1(graph1);\n\n    let graph2: IGraph<IVertex, IEdge>;\n    graph2 = num_0<=2?GetNewRandomGraph(num_vert_plus_edg):GetNewRandomGraphForThatOne(num_vert_plus_edg, graph1);\n    init2(graph2);\n\n    let graphres = ChooseTask();\n    initres(graphres);\n}\n\nfunction GetNewRandomGraph (num:number){ // рандомный граф\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    let edge_num = num - Math.round(num/2);//Math.round((Math.random()*0.15+0.85)*num/2);\n    let vert_num = num - edge_num;\n    let vert_num_help = vert_num;\n\n    while (vert_num!==0){\n        graph.addVertex(new Vertex(`${vert_num}`));\n        vert_num--;\n    }\n\n    while (edge_num!==0){\n        let v1 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+1)}`)[0];\n        let v2 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+1)}`)[0];\n        if(!v1.isAdjacent(graph,v2)){\n            graph.addEdge(new Edge(v1,v2,`${v1.name}+${v2.name}`));\n            edge_num--;\n        }\n    }\n\n    return graph;\n}\n\nfunction GetNewRandomGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>){\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    let edge_num = num - Math.round(num/2);//Math.round((Math.random()*0.15+0.85)*num/2);\n    let vert_num = num - edge_num;\n\n    vert_num+=graph1.vertices.length;\n    edge_num+=graph1.edges.length;\n    let vert_num_help = vert_num;\n\n    while (vert_num!==graph1.vertices.length){\n        graph.addVertex(new Vertex(`${vert_num}`));\n        vert_num--;\n    }\n\n    while (edge_num!==0){\n        let v1 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+graph1.vertices.length)}`)[0];\n        let v2 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+graph1.vertices.length)}`)[0];\n        if(v1 && v2 && !v1.isAdjacent(graph,v2)){\n            graph.addEdge(new Edge(v1,v2,`${v1.name}+${v2.name}`));\n            edge_num--;\n        }\n    }\n\n    return graph;\n}\n\nexport {GraphsInit};",{"ruleId":"75","replacedBy":"76"},{"ruleId":"77","replacedBy":"78"},{"ruleId":"79","severity":1,"message":"80","line":1,"column":16,"nodeType":"81","messageId":"82","endLine":1,"endColumn":25},{"ruleId":"79","severity":1,"message":"83","line":5,"column":5,"nodeType":"81","messageId":"82","endLine":5,"endColumn":15},{"ruleId":"79","severity":1,"message":"84","line":8,"column":53,"nodeType":"81","messageId":"82","endLine":8,"endColumn":64},{"ruleId":"79","severity":1,"message":"85","line":8,"column":66,"nodeType":"81","messageId":"82","endLine":8,"endColumn":73},{"ruleId":"79","severity":1,"message":"86","line":8,"column":75,"nodeType":"81","messageId":"82","endLine":8,"endColumn":94},{"ruleId":"79","severity":1,"message":"87","line":9,"column":48,"nodeType":"81","messageId":"82","endLine":9,"endColumn":54},{"ruleId":"79","severity":1,"message":"88","line":9,"column":56,"nodeType":"81","messageId":"82","endLine":9,"endColumn":63},{"ruleId":"79","severity":1,"message":"89","line":9,"column":72,"nodeType":"81","messageId":"82","endLine":9,"endColumn":86},{"ruleId":"79","severity":1,"message":"90","line":10,"column":8,"nodeType":"81","messageId":"82","endLine":10,"endColumn":14},{"ruleId":"79","severity":1,"message":"91","line":12,"column":9,"nodeType":"81","messageId":"82","endLine":12,"endColumn":24},{"ruleId":"79","severity":1,"message":"92","line":15,"column":10,"nodeType":"81","messageId":"82","endLine":15,"endColumn":15},{"ruleId":"79","severity":1,"message":"93","line":15,"column":30,"nodeType":"81","messageId":"82","endLine":15,"endColumn":35},{"ruleId":"79","severity":1,"message":"94","line":15,"column":50,"nodeType":"81","messageId":"82","endLine":15,"endColumn":57},{"ruleId":"79","severity":1,"message":"95","line":15,"column":78,"nodeType":"81","messageId":"82","endLine":15,"endColumn":82},{"ruleId":"79","severity":1,"message":"96","line":16,"column":20,"nodeType":"81","messageId":"82","endLine":16,"endColumn":38},{"ruleId":"79","severity":1,"message":"97","line":16,"column":94,"nodeType":"81","messageId":"82","endLine":16,"endColumn":100},{"ruleId":"79","severity":1,"message":"98","line":17,"column":10,"nodeType":"81","messageId":"82","endLine":17,"endColumn":20},{"ruleId":"79","severity":1,"message":"99","line":6,"column":17,"nodeType":"81","messageId":"82","endLine":6,"endColumn":31},{"ruleId":"75","replacedBy":"100"},{"ruleId":"77","replacedBy":"101"},{"ruleId":"79","severity":1,"message":"102","line":4,"column":9,"nodeType":"81","messageId":"82","endLine":4,"endColumn":18},{"ruleId":"79","severity":1,"message":"96","line":4,"column":20,"nodeType":"81","messageId":"82","endLine":4,"endColumn":38},{"ruleId":"79","severity":1,"message":"99","line":4,"column":47,"nodeType":"81","messageId":"82","endLine":4,"endColumn":61},{"ruleId":"79","severity":1,"message":"103","line":4,"column":63,"nodeType":"81","messageId":"82","endLine":4,"endColumn":72},{"ruleId":"79","severity":1,"message":"104","line":4,"column":74,"nodeType":"81","messageId":"82","endLine":4,"endColumn":92},{"ruleId":"79","severity":1,"message":"102","line":4,"column":9,"nodeType":"81","messageId":"82","endLine":4,"endColumn":18},{"ruleId":"79","severity":1,"message":"96","line":4,"column":20,"nodeType":"81","messageId":"82","endLine":4,"endColumn":38},{"ruleId":"79","severity":1,"message":"99","line":4,"column":47,"nodeType":"81","messageId":"82","endLine":4,"endColumn":61},{"ruleId":"79","severity":1,"message":"103","line":4,"column":63,"nodeType":"81","messageId":"82","endLine":4,"endColumn":72},{"ruleId":"79","severity":1,"message":"104","line":4,"column":74,"nodeType":"81","messageId":"82","endLine":4,"endColumn":92},{"ruleId":"79","severity":1,"message":"97","line":4,"column":94,"nodeType":"81","messageId":"82","endLine":4,"endColumn":100},{"ruleId":"79","severity":1,"message":"105","line":4,"column":102,"nodeType":"81","messageId":"82","endLine":4,"endColumn":117},{"ruleId":"79","severity":1,"message":"106","line":4,"column":124,"nodeType":"81","messageId":"82","endLine":4,"endColumn":136},"no-native-reassign",["107"],"no-negated-in-lhs",["108"],"@typescript-eslint/no-unused-vars","'FormEvent' is defined but never used.","Identifier","unusedVar","'ToolButton' is defined but never used.","'StudentMark' is defined but never used.","'Console' is defined but never used.","'graphActionCreators' is defined but never used.","'IGraph' is defined but never used.","'IVertex' is defined but never used.","'GraphGenerator' is defined but never used.","'styles' is defined but never used.","'WritableAdapter' is defined but never used.","'init1' is defined but never used.","'init2' is defined but never used.","'initres' is defined but never used.","'init' is defined but never used.","'message_0_changing' is defined but never used.","'mark_0' is defined but never used.","'ChooseTask' is defined but never used.","'num_0_changing' is defined but never used.",["107"],["108"],"'message_0' is defined but never used.","'message_1' is defined but never used.","'message_1_changing' is defined but never used.","'mark_0_changing' is defined but never used.","'k_s_changing' is defined but never used.","no-global-assign","no-unsafe-negation"]