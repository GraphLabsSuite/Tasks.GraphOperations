"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var md5_1 = require("ts-md5/dist/md5");
var GraphID_1 = require("../util/GraphID");
/**
 * @classdesc
 * The vertex implementation of IVertex interface
 */
var Vertex = /** @class */ (function () {
    /**
     * @constructor
     * @param name
     * @param graph
     */
    function Vertex(name, graph) {
        this._name = name;
        this._id = GraphID_1.GraphID.generate();
        this._label = "";
        this._wave = "";
        this._graphReference = graph;
    }
    Object.defineProperty(Vertex.prototype, "id", {
        /**
         * @property
         * @public
         * Getter for the _id field
         * @returns {number}
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vertex.prototype, "name", {
        /**
         * @property
         * @public
         * Getter for _name field
         * @returns {string}
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @property
     * @private
     * Private emulated setter for _name field
     * @param theName
     */
    Vertex.prototype.setName = function (theName) {
        this._name = theName;
    };
    Object.defineProperty(Vertex.prototype, "label", {
        /**
         * @property
         * @public
         * Getter for _label field
         * @returns {string}
         */
        get: function () {
            return this._label;
        },
        /**
         * @property
         * @public
         * Setter for _label field
         * @param theLabel
         */
        set: function (theLabel) {
            this._label = theLabel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vertex.prototype, "wave", {
        /**
         * @property
         * @public
         * Getter for _wave field
         * @returns {string}
         */
        get: function () {
            return this._wave;
        },
        /**
        * @property
        * @public
        * Setter for _label field
        * @param theLabel
        */
        set: function (theWave) {
            this._wave = theWave;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @public
     * Allows to change the name field of the vertex
     * @param newName
     */
    Vertex.prototype.rename = function (newName) {
        this.setName(newName);
    };
    /**
     * @public
     * Checks whether the edge is incident to the vertex
     * @param edge
     */
    Vertex.prototype.isIncident = function (edge) {
        return edge.vertexOne.name === this.name || edge.vertexTwo.name === this.name;
    };
    /**
     * @public
     * Checks whether the vertex is adjacent to the given one
     * @param vertex
     */
    Vertex.prototype.isAdjacent = function (graph, vertex) {
        var _this = this;
        if (graph.edges.some(function (e) {
            return (vertex && _this && ((e.vertexOne.name === _this.name
                && e.vertexTwo.name === vertex.name)
                || (e.vertexOne.name === vertex.name
                    && e.vertexTwo.name === _this.name)));
        }))
            return true;
        else
            return false;
    };
    /**
     * @public
     * Return the array of incident edges for the vertex
     * @param graph
     */
    Vertex.prototype.arrOfIncidentEdges = function (graph) {
        var res = [];
        for (var i = 0; i < graph.edges.length; i++) {
            if (this.isIncident(graph.edges[i])) {
                res.push(graph.edges[i]);
            }
        }
        return res;
    };
    /**
     * @public
     * Return the array of adjacent vertices for the vertex
     * @param graph
     */
    Vertex.prototype.arrOfAdjacentVertices = function (graph) {
        var res = [];
        for (var i = 0; i < graph.vertices.length; i++) {
            if (this.isAdjacent(graph, graph.vertices[i])) {
                res.push(graph.vertices[i]);
            }
        }
        return res;
    };
    /**
     * @public
     * Returns string representation of the vertex
     * @returns {string}
     */
    Vertex.prototype.toString = function () {
        return this.name;
    };
    /**
     * @public
     * Deep vertex-cloning
     * @returns {Vertex}
     */
    Vertex.prototype.clone = function () {
        return new Vertex(this.name);
    };
    /**
     * @public
     * Calculates the hash function of the vertex
     * @returns {string}
     */
    Vertex.prototype.hash = function () {
        return md5_1.Md5.hashStr(this.id.toString());
    };
    /**
     * @public
     * Checks whether the second vertex equals with this one
     * @param vertex
     * @returns {boolean}
     */
    Vertex.prototype.equals = function (vertex) {
        if (vertex == null)
            return false;
        return this.id.equals(vertex.id);
    };
    return Vertex;
}());
exports.Vertex = Vertex;
//# sourceMappingURL=Vertex.js.map