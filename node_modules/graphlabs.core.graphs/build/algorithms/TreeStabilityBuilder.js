"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TreeNode_1 = require("../main/TreeNode");
var TreeStabilityBuilder = /** @class */ (function () {
    function TreeStabilityBuilder() {
    }
    TreeStabilityBuilder.graphToTreeNode = function (taskGraph) {
        var treeNode = new TreeNode_1.TreeNode("G", {
            nonneighbourhood: [],
            graph: taskGraph
        });
        var rootNodeId = TreeNode_1.TreeNode.lastId;
        var queue = [rootNodeId];
        var answers = [];
        var _loop_1 = function () {
            var parentNode = treeNode.getNodeById(queue.shift());
            var childrenNodes = taskGraph.getNeighbourhood(taskGraph.getVertexWithMinDegree()).concat(taskGraph.getVertexWithMinDegree());
            childrenNodes.forEach(function (node) {
                treeNode.addChild(parentNode.id, node.name, {
                    nonneighbourhood: parentNode.weight.graph.getNonNeighbourhood(node),
                    graph: taskGraph.getSubgraph(parentNode.weight.graph.getNonNeighbourhood(node))
                });
                var newGraph = treeNode.getNodeById(TreeNode_1.TreeNode.lastId).weight.graph;
                if (newGraph.vertices.length) {
                    var answer = [];
                    var id = TreeNode_1.TreeNode.lastId;
                    while (id !== rootNodeId) {
                        var n = treeNode.getNodeById(id);
                        answer.push(n.label);
                        id = n.parentId;
                    }
                    answers.push(answer);
                }
                else {
                    queue.push(TreeNode_1.TreeNode.lastId);
                }
            });
        };
        while (queue.length) {
            _loop_1();
        }
        return TreeStabilityBuilder.cleanAnswer(answers);
    };
    TreeStabilityBuilder.cleanAnswer = function (answers) {
        var newAnswer = [];
        answers.forEach(function (a) {
            if (newAnswer.some(function (e) { return TreeStabilityBuilder.arrayIsEqual(e, a); }))
                return;
            newAnswer.push(a);
        });
        return newAnswer;
    };
    TreeStabilityBuilder.arrayIsEqual = function (array1, array2) {
        if (array1.length !== array2.length)
            return false;
        return array1.every(function (e1) { return array2.some(function (e2) { return e1 === e2; }); });
    };
    return TreeStabilityBuilder;
}());
exports.TreeStabilityBuilder = TreeStabilityBuilder;
//# sourceMappingURL=TreeStabilityBuilder.js.map