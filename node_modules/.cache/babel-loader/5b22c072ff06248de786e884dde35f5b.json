{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/home/ilya/UIR/test_5/src/App.tsx\";\nimport React from 'react'; //import logo from './logo.svg';\n\nimport './App.css'; //import { IGraphView, ToolButtonList, IMatrixView, INGraphsView, graphActionCreators, State } from \"graphlabs.core.template\";\n\nimport { GraphVisualizer, Template, Toolbar, store, StudentMark, Console } from \"graphlabs.core.template\";\nimport {\n/*Graph, SccBuilder,*/\nVertex, Edge, GraphGenerator } from \"graphlabs.core.graphs\";\nimport styles from './Template.module.scss';\nimport 'graphlabs.core.template/dist/main.css';\nimport { init1, graphModel1, init2, graphModel2, initres\n/*graphModelres,*/\n, init, graphModel } from './ForMyGraphModel';\n\nclass App extends Template {\n  componentWillMount() {\n    let graph;\n    graph = GraphGenerator.generate(0);\n    init(graph);\n    let graph1;\n    graph1 = this.GetNewRandomGraph(5);\n    init1(graph1);\n    let graph2;\n    graph2 = this.GetNewRandomGraphForThatOne(5, graph1);\n    init2(graph2);\n    let graphres = this.ChooseTask();\n    initres(graphres); //this.scc_count = SccBuilder.findComponents(graphres).length;\n  } //Для меня в будующем: проблема невозможности удать ребро заключается в том, что я создаю два других, тем саммы ломая себе всё.\n  //Это нужно проверить и внести определённые правки. Также нужно узнать как мой модуль добавить на сайт, а не только на гитхаб.\n\n\n  ChooseTask() {\n    this.num_0 = Math.round(Math.random() * 100) % 7;\n\n    switch (this.num_0) {\n      case 0:\n        this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n        return this.Uni(graphModel1, graphModel2);\n\n      case 1:\n        this.message_0 = \"Постройте граф, являющийся результатом соединения двух графов.\";\n        return this.Joint(graphModel1, graphModel2);\n\n      case 2:\n        this.message_0 = \"Постройте граф, являющийся результатом произведения двух графов.\";\n        return this.Product(graphModel1, graphModel2);\n\n      case 3:\n        this.message_0 = \"Постройте граф, являющийся результатом композиции двух графов.\";\n        return this.Composition(graphModel1, graphModel2);\n\n      case 4:\n        this.message_0 = \"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\"; // Объединение по Зыкову\n\n        return this.Uni_Z(graphModel1, graphModel2);\n\n      case 5:\n        this.message_0 = \"Постройте граф, являющийся результатом пересечения двух графов.\"; // Пересечение\n\n        return this.Cross(graphModel1, graphModel2);\n\n      case 6:\n        this.message_0 = \"Постройте граф, являющийся дополнением графа.\"; // Дополнение\n\n        return this.Addition(graphModel1);\n\n      case 7:\n        this.message_0 = \"Постройте граф, являющийся результатом декартового произведения двух графов.\"; // Декартово произведение\n\n        return this.Cartesian_Product(graphModel1, graphModel2);\n\n      default:\n        this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n        return this.Uni(graphModel1, graphModel2);\n    }\n  }\n\n  GetNewRandomGraph(num) {\n    // рандомный граф\n    let graph;\n    graph = GraphGenerator.generate(0);\n    var arr = [];\n\n    for (var i = 0; i < num; i++) {\n      arr.push(Math.round(Math.random()));\n\n      if (arr[i] === 1) {\n        let vert = new Vertex(`${i}`);\n        graph.addVertex(vert);\n      }\n    }\n\n    for (var k = 0; k < num - 1; k++) {\n      if (arr[k] === 1) {\n        for (var j = k + 1; j < num; j++) {\n          if (arr[j] === 1 && Math.random() > 0.45) {\n            // 55% chance what is edge k+j\n            let edge = new Edge(graph.getVertex(`${k}`)[0], graph.getVertex(`${j}`)[0], `${k}+${j}`);\n            graph.addEdge(edge);\n          }\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  GetNewRandomGraphForThatOne(num, graph1) {\n    // рандомный, не имеющий общих вершин с первым\n    let graph;\n    graph = GraphGenerator.generate(0);\n    var arr = [];\n    let length = graph1.vertices.length + 1;\n\n    for (var i = 0; i < num; i++) {\n      arr.push(Math.round(Math.random()));\n\n      if (arr[i] === 1) {\n        let vert = new Vertex(`${i + length}`);\n        graph.addVertex(vert);\n      }\n    }\n\n    for (var k = 0; k < num - 1; k++) {\n      if (arr[k] === 1) {\n        for (var j = k + 1; j < num; j++) {\n          if (arr[j] === 1 && Math.random() > 0.45) {\n            // 55% chance what is edge k+j\n            let edge = new Edge(graph.getVertex(`${k + length}`)[0], graph.getVertex(`${j + length}`)[0], `${k + length}+${j + length}`);\n            graph.addEdge(edge);\n          }\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  Uni(graph1, graph2) {\n    // объединение\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.vertices.forEach(v => {\n      if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n        // если нет таких же по имени вершин\n        graphres.addVertex(v);\n      }\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph1.edges.forEach(e => {\n      let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n      let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n      let e_new;\n      e_new = new Edge(vv1, vv2);\n      graphres.addEdge(e_new);\n    });\n    graph2.edges.forEach(e => {\n      let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n      let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n      let e_new;\n      e_new = new Edge(vv1, vv2);\n      graphres.addEdge(e_new);\n    });\n    return graphres;\n  }\n\n  Operation2(graph1, graph2) {\n    // соединение по  (это и есть простое соединение)\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.vertices.forEach(v => {\n      if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n        // если нет таких же по имени вершин\n        graphres.addVertex(v);\n        graph1.vertices.forEach(v1 => {\n          // дополнение к объединению\n          if (!(graphres.getEdge(v, v1).length > 0)) {\n            let e;\n            e = new Edge(v, v1);\n            graphres.addEdge(e);\n          }\n        });\n      }\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    return graphres;\n  }\n\n  Joint(graph1, graph2) {\n    // соединение !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n      graph2.vertices.forEach(v1 => {\n        if (!(graphres.getVertex(`${v1.name}`).length > 0)) graphres.addVertex(v1);\n        let e;\n        e = new Edge(v, v1);\n        graphres.addEdge(e);\n      });\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    return graphres;\n  }\n\n  Product(graph1, graph2) {\n    // Произведение !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graph2.vertices.forEach(v1 => {\n        let v_res;\n        v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n        graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n        //graphres.addVertex(v_res);\n      });\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        graph1.vertices.forEach(u1 => {\n          graph2.vertices.forEach(u2 => {\n            if (u1.name !== v1.name || u2.name !== v2.name) {\n              if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              } else if (u2.name === v2.name && v1.isAdjacent(graph1, u1)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              }\n            }\n          });\n        });\n      });\n    });\n    return graphres;\n  }\n\n  Composition(graph1, graph2) {\n    // Композиция !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graph2.vertices.forEach(v1 => {\n        let v_res;\n        v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n        graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n        //graphres.addVertex(v_res);\n      });\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        graph1.vertices.forEach(u1 => {\n          graph2.vertices.forEach(u2 => {\n            if (u1.name !== v1.name || u2.name !== v2.name) {\n              //let e_0: IEdge;\n              //e_0=new Edge(v1,v2)\n              if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n                //graph2.getEdge(v2,u2).length>0 ){\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              } else if (v1.isAdjacent(graph1, u1)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              }\n            }\n          });\n        });\n      });\n    });\n    return graphres;\n  }\n\n  Uni_Z(graph1, graph2) {\n    // объединение по Зыкову\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.vertices.forEach(v => {\n      if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n        // если нет таких же по имени вершин\n        graphres.addVertex(v);\n      }\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        if (!graphres.getVertex(v1.name)[0].isAdjacent(graphres, graphres.getVertex(v2.name)[0])) {\n          let vv1 = graphres.getVertex(`${v1.name}`)[0];\n          let vv2 = graphres.getVertex(`${v2.name}`)[0];\n          let e;\n          e = new Edge(vv1, vv2);\n          graphres.addEdge(e);\n        }\n      });\n    });\n    return graphres;\n  }\n\n  Cross(graph1, graph2) {\n    // Пересечение\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        if (v1.name === v2.name) {\n          let v_res;\n          v_res = new Vertex(`${v1.name}`);\n          graphres.addVertex(v_res);\n        }\n      });\n    });\n    graph1.edges.forEach(u1 => {\n      graph2.edges.forEach(u2 => {\n        if (u1.vertexOne.name === u2.vertexOne.name && u1.vertexTwo.name === u2.vertexTwo.name || u1.vertexOne.name === u2.vertexTwo.name && u1.vertexTwo.name === u2.vertexOne.name) {\n          let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n          let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n          let e;\n          e = new Edge(v1[0], v2[0]);\n          graphres.addEdge(e);\n        }\n      });\n    });\n    return graphres;\n  }\n\n  Addition(graph1) {\n    // Дополнение\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v1 => {\n      let v_res;\n      v_res = new Vertex(`${v1.name}`);\n      graphres.addVertex(v_res);\n    });\n    graph1.vertices.forEach(v1 => {\n      graph1.vertices.forEach(v2 => {\n        let vv1 = v1.name;\n        let vv2 = v2.name;\n\n        if (v1.name !== v2.name && !v1.isAdjacent(graph1, v2) && !graphres.getVertex(v1.name)[0].isAdjacent(graphres, graphres.getVertex(v2.name)[0])) {\n          let v1 = graphres.getVertex(`${vv1}`);\n          let v2 = graphres.getVertex(`${vv2}`);\n          let e;\n          e = new Edge(v1[0], v2[0]);\n          graphres.addEdge(e);\n        }\n      });\n    });\n    let graph2;\n    graph2 = this.GetNewRandomGraph(0);\n    init2(graph2);\n    return graphres;\n  }\n\n  Cartesian_Product(graph1, graph2) {\n    // Декартово произведение !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graph2.vertices.forEach(v1 => {\n        let v_res;\n        v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n        graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n        //graphres.addVertex(v_res);\n      });\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        graph1.vertices.forEach(u1 => {\n          graph2.vertices.forEach(u2 => {\n            if (u1.name !== v1.name || u2.name !== v2.name) {\n              //let e_0: IEdge;\n              //e_0=new Edge(v1,v2)\n              if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n                //graph2.getEdge(v2,u2).length>0 ){\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              } else if (v1.isAdjacent(graph1, u1)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              }\n            }\n          });\n        });\n      });\n    });\n    return graphres;\n  }\n\n  constructor(props) {\n    super(props); //this.render = this.render.bind(this);\n    //this.getArea = this.getArea.bind(this);\n\n    /*store.subscribe(() => {\n        if (store.getState().app.status !== this.state.status) {\n            this.setState({\n                status: store.getState().app.status,\n            });\n        }\n    });*/\n    //this.task = this.task.bind(this);\n\n    this.message_0 = \"\";\n    this.num_0 = 0;\n    this.state = {\n      status: store.getState().app.status\n    };\n    this.getTaskToolbar = this.getTaskToolbar.bind(this);\n  }\n\n  render() {\n    const Task = this.task();\n    const Toolbar = this.getTaskToolbar();\n    const Area = this.getArea();\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.App,\n      id: \"wrap\",\n      children: this.state.status ? /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"\\u0417\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0432\\u044B\\u043F\\u043E\\u043B\\u043D\\u0435\\u043D\\u043E. \\u041E\\u0436\\u0438\\u0434\\u0430\\u0439\\u0442\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0430 \\u043E\\u0442 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 477,\n        columnNumber: 23\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: styles.MainRow,\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: styles.GraphCell,\n            children: /*#__PURE__*/_jsxDEV(Area, {}, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 482,\n              columnNumber: 37\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 481,\n            columnNumber: 33\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: styles.ToolCell,\n            children: /*#__PURE__*/_jsxDEV(Toolbar, {}, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 485,\n              columnNumber: 37\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 484,\n            columnNumber: 33\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: styles.TaskCell,\n            children: [/*#__PURE__*/_jsxDEV(\"p\", {\n              children: \"\\u0417\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 488,\n              columnNumber: 37\n            }, this), /*#__PURE__*/_jsxDEV(Task, {}, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 489,\n              columnNumber: 37\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 487,\n            columnNumber: 33\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 480,\n          columnNumber: 29\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: styles.LeftBottom,\n          children: /*#__PURE__*/_jsxDEV(StudentMark, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 493,\n            columnNumber: 33\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 492,\n          columnNumber: 29\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: styles.LowRow,\n          children: /*#__PURE__*/_jsxDEV(Console, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 496,\n            columnNumber: 33\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 495,\n          columnNumber: 29\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 479,\n        columnNumber: 25\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 475,\n      columnNumber: 13\n    }, this);\n  } //<Task/>\n\n\n  getTaskToolbar() {\n    return Toolbar;\n  }\n\n  getArea() {\n    return () => /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: /*#__PURE__*/_jsxDEV(GraphVisualizer, {\n          graph: graphModel,\n          adapterType: 'writable',\n          namedEdges: false,\n          vertexNaming: true,\n          withoutDragging: true,\n          edgeNaming: false,\n          incidentEdges: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 510,\n          columnNumber: 17\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 509,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 508,\n      columnNumber: 22\n    }, this); //return () =>\n    //    <GraphVisualizer\n    //        graph={graphModelres}\n    //        adapterType={'readable'}\n    //        namedEdges={false}\n    //        vertexNaming={false}\n    //        withoutDragging={false}\n    //        edgeNaming={false}\n    //        incidentEdges={false}\n    //    />;\n  }\n\n  task() {\n    graphModel.vertices.forEach(v => console.log(`id = ${v.id}; label = ${v.label}; name = ${v.name}; wawe=${v.wave}.\\n`));\n    return () => /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: this.message_0\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 538,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(\"p\", {\n          children: /*#__PURE__*/_jsxDEV(GraphVisualizer, {\n            graph: graphModel1,\n            adapterType: 'readable',\n            namedEdges: false,\n            vertexNaming: false,\n            withoutDragging: true,\n            edgeNaming: false,\n            incidentEdges: false\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 543,\n            columnNumber: 25\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 542,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: /*#__PURE__*/_jsxDEV(GraphVisualizer, {\n            graph: graphModel2,\n            adapterType: 'readable',\n            namedEdges: false,\n            vertexNaming: false,\n            withoutDragging: true,\n            edgeNaming: false,\n            incidentEdges: false\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 554,\n            columnNumber: 25\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 553,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 541,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 537,\n      columnNumber: 13\n    }, this);\n  }\n\n}\n\nexport default App;","map":{"version":3,"sources":["/home/ilya/UIR/test_5/src/App.tsx"],"names":["React","GraphVisualizer","Template","Toolbar","store","StudentMark","Console","Vertex","Edge","GraphGenerator","styles","init1","graphModel1","init2","graphModel2","initres","init","graphModel","App","componentWillMount","graph","generate","graph1","GetNewRandomGraph","graph2","GetNewRandomGraphForThatOne","graphres","ChooseTask","num_0","Math","round","random","message_0","Uni","Joint","Product","Composition","Uni_Z","Cross","Addition","Cartesian_Product","num","arr","i","push","vert","addVertex","k","j","edge","getVertex","addEdge","length","vertices","forEach","v","edges","e","name","vv1","vertexOne","vv2","vertexTwo","e_new","Operation2","v1","getEdge","v_res","v2","u1","u2","isAdjacent","constructor","props","state","status","getState","app","getTaskToolbar","bind","render","Task","task","Area","getArea","MainRow","GraphCell","ToolCell","TaskCell","LeftBottom","LowRow","console","log","id","label","wave"],"mappings":"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","sourcesContent":["import React from 'react';\n//import logo from './logo.svg';\nimport './App.css';\n//import { IGraphView, ToolButtonList, IMatrixView, INGraphsView, graphActionCreators, State } from \"graphlabs.core.template\";\nimport { GraphVisualizer, Template, Toolbar, store, StudentMark, Console } from \"graphlabs.core.template\";\nimport {  /*Graph, SccBuilder,*/ IGraph, IVertex, IEdge, Vertex, Edge, GraphGenerator } from \"graphlabs.core.graphs\";\nimport styles from './Template.module.scss';\nimport 'graphlabs.core.template/dist/main.css';\n\nimport { /*Component,*/ SFC} from 'react';\nimport { init1, graphModel1, init2, graphModel2, initres, /*graphModelres,*/ init, graphModel } from './ForMyGraphModel';\n\nclass App extends Template {\n    protected message_0 = \"\";\n    protected num_0 = 0;\n\n    public state = {\n        status: store.getState().app.status,\n    };\n\n    componentWillMount() {\n        let graph: IGraph<IVertex, IEdge>;\n\n        graph = GraphGenerator.generate(0);\n        init(graph);\n\n        let graph1: IGraph<IVertex, IEdge>;\n        graph1 = this.GetNewRandomGraph(5);\n        init1(graph1);\n\n        let graph2: IGraph<IVertex, IEdge>;\n        graph2 = this.GetNewRandomGraphForThatOne(5,graph1);\n        init2(graph2);\n\n        let graphres = this.ChooseTask();\n        initres(graphres);\n        //this.scc_count = SccBuilder.findComponents(graphres).length;\n    }\n\n\n        //Для меня в будующем: проблема невозможности удать ребро заключается в том, что я создаю два других, тем саммы ломая себе всё.\n        //Это нужно проверить и внести определённые правки. Также нужно узнать как мой модуль добавить на сайт, а не только на гитхаб.\n\n\n    protected ChooseTask(){\n        this.num_0 = Math.round(Math.random() * 100)%7;\n        switch (this.num_0) {\n            case 0:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n                return this.Uni(graphModel1,graphModel2);\n            case 1:\n                this.message_0 = \"Постройте граф, являющийся результатом соединения двух графов.\";\n                return this.Joint(graphModel1,graphModel2);\n            case 2:\n                this.message_0 = \"Постройте граф, являющийся результатом произведения двух графов.\";\n                return this.Product(graphModel1,graphModel2);\n            case 3:\n                this.message_0 = \"Постройте граф, являющийся результатом композиции двух графов.\";\n                return this.Composition(graphModel1,graphModel2);\n            case 4:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\"; // Объединение по Зыкову\n                return this.Uni_Z(graphModel1,graphModel2);\n            case 5:\n                this.message_0 = \"Постройте граф, являющийся результатом пересечения двух графов.\"; // Пересечение\n                return this.Cross(graphModel1,graphModel2);\n            case 6:\n                this.message_0 = \"Постройте граф, являющийся дополнением графа.\"; // Дополнение\n                return this.Addition(graphModel1);\n            case 7:\n                this.message_0 = \"Постройте граф, являющийся результатом декартового произведения двух графов.\"; // Декартово произведение\n                return this.Cartesian_Product(graphModel1,graphModel2);\n            default:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n                return this.Uni(graphModel1,graphModel2);\n        }\n    }\n\n    protected GetNewRandomGraph (num:number){ // рандомный граф\n        let graph: IGraph<IVertex, IEdge>;\n        graph = GraphGenerator.generate(0);\n        var arr = [];\n        for(var i = 0; i<num; i++ ){\n            arr.push(Math.round(Math.random()));\n            if(arr[i]===1){\n                let vert = new Vertex(`${i}`);\n                graph.addVertex(vert);\n            }\n        }\n        for(var k=0;k<num-1;k++){\n            if(arr[k]===1) {\n                for(var j = k+1;j<num;j++){\n                    if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge k+j\n                        let edge = new Edge(graph.getVertex(`${k}`)[0],graph.getVertex(`${j}`)[0],`${k}+${j}`);\n                        graph.addEdge(edge);\n                    }\n                }\n            }\n        }\n        return graph;\n    }\n\n    protected GetNewRandomGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>){ // рандомный, не имеющий общих вершин с первым\n        let graph: IGraph<IVertex, IEdge>;\n        graph = GraphGenerator.generate(0);\n        var arr = [];\n        let length = graph1.vertices.length+1;\n        for(var i = 0; i<num; i++ ){\n            arr.push(Math.round(Math.random()));\n            if(arr[i]===1){\n                let vert = new Vertex(`${i+length}`);\n                graph.addVertex(vert);\n            }\n        }\n        for(var k=0;k<num-1;k++){\n            if(arr[k]===1) {\n                for(var j = k+1;j<num;j++){\n                    if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge k+j\n                        let edge = new Edge(graph.getVertex(`${k+length}`)[0],graph.getVertex(`${j+length}`)[0],`${k+length}+${j+length}`);\n                        graph.addEdge(edge);\n                    }\n                }\n            }\n        }\n        return graph;\n    }\n\n    protected Uni(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph1.edges.forEach((e: any)=> {\n            let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n            let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n            let e_new: IEdge;\n            e_new = new Edge(vv1,vv2);\n            graphres.addEdge(e_new);\n        });\n        graph2.edges.forEach((e: any)=> {\n            let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n            let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n            let e_new: IEdge;\n            e_new = new Edge(vv1,vv2);\n            graphres.addEdge(e_new);\n        });\n        return graphres;\n    }\n\n    protected Operation2(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение по  (это и есть простое соединение)\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n\n                graph1.vertices.forEach((v1:any)=>{ // дополнение к объединению\n                    if(!(graphres.getEdge(v,v1).length>0)){\n                        let e: IEdge;\n                        e = new Edge(v,v1);\n                        graphres.addEdge(e);\n                    }\n                });\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        return graphres;\n    }\n\n    protected Joint(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach(v=>{\n            graphres.addVertex(v);\n            graph2.vertices.forEach(v1=>{\n                if(!(graphres.getVertex(`${v1.name}`).length>0))\n                    graphres.addVertex(v1);\n                let e: IEdge;\n                e = new Edge(v,v1);\n                graphres.addEdge(e);\n            });\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        return graphres;\n    }\n\n    protected Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Произведение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!==v1.name||u2.name!==v2.name){\n                            if((u1.name===v1.name)&&(v2.isAdjacent(graph2,u2))){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if((u2.name===v2.name)&&(v1.isAdjacent(graph1,u1))){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Composition(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Композиция !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!==v1.name || u2.name!==v2.name){\n                            //let e_0: IEdge;\n                            //e_0=new Edge(v1,v2)\n                            if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if(v1.isAdjacent(graph1,u1)){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Uni_Z(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение по Зыкову\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph1.vertices.forEach((v1: any)=> {\n            graph2.vertices.forEach((v2: any)=> {\n                if (!(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                    let vv1 = graphres.getVertex(`${v1.name}`)[0];\n                    let vv2 = graphres.getVertex(`${v2.name}`)[0];\n\n                    let e: IEdge;\n                    e = new Edge(vv1,vv2);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n        return graphres;\n    }\n\n    protected Cross(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Пересечение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                if (v1.name === v2.name){\n                    let v_res: IVertex;\n                    v_res = new Vertex(`${v1.name}`);\n                    graphres.addVertex(v_res);\n                }\n            });\n        });\n\n        graph1.edges.forEach(u1=>{\n            graph2.edges.forEach(u2=>{\n                if ((u1.vertexOne.name === u2.vertexOne.name && u1.vertexTwo.name === u2.vertexTwo.name) || (u1.vertexOne.name === u2.vertexTwo.name && u1.vertexTwo.name === u2.vertexOne.name)){\n                    let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n                    let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n\n                    let e: IEdge;\n                    e = new Edge(v1[0],v2[0]);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Addition(graph1: IGraph<IVertex, IEdge>){ // Дополнение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v1.name}`);\n            graphres.addVertex(v_res);\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph1.vertices.forEach(v2=>{\n                let vv1 = v1.name;\n                let vv2 = v2.name;\n                if (v1.name !== v2.name && !(v1.isAdjacent(graph1,v2)) && !(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                    let v1 = graphres.getVertex(`${vv1}`);\n                    let v2 = graphres.getVertex(`${vv2}`);\n\n                    let e: IEdge;\n                    e = new Edge(v1[0],v2[0]);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n\n        let graph2: IGraph<IVertex, IEdge>;\n        graph2 = this.GetNewRandomGraph(0);\n        init2(graph2);\n\n\n        return graphres;\n    }\n\n    protected Cartesian_Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Декартово произведение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!==v1.name || u2.name!==v2.name){\n                            //let e_0: IEdge;\n                            //e_0=new Edge(v1,v2)\n                            if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if(v1.isAdjacent(graph1,u1)){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    public constructor(props: {}) {\n        super(props);\n        //this.render = this.render.bind(this);\n        //this.getArea = this.getArea.bind(this);\n        /*store.subscribe(() => {\n            if (store.getState().app.status !== this.state.status) {\n                this.setState({\n                    status: store.getState().app.status,\n                });\n            }\n        });*/\n\n        //this.task = this.task.bind(this);\n        this.getTaskToolbar = this.getTaskToolbar.bind(this);\n\n    }\n\n    public render():JSX.Element {\n        const Task: any = this.task();\n        const Toolbar = this.getTaskToolbar();\n        const Area = this.getArea();\n        return (\n            <div className={styles.App} id=\"wrap\">\n                {this.state.status\n                    ? <p>Задание выполнено. Ожидайте ответа от сервера...</p>\n                    : (\n                        <div>\n                            <div className={styles.MainRow}>\n                                <div className={styles.GraphCell}>\n                                    <Area/>\n                                </div>\n                                <div className={styles.ToolCell}>\n                                    <Toolbar/>\n                                </div>\n                                <div className={styles.TaskCell}>\n                                    <p>Задание</p>\n                                    <Task/>\n                                </div>\n                            </div>\n                            <div className={styles.LeftBottom}>\n                                <StudentMark/>\n                            </div>\n                            <div className={styles.LowRow}>\n                                <Console/>\n                            </div>\n                        </div>)}\n            </div>\n        );\n    }//<Task/>\n\n    protected getTaskToolbar() {\n        return Toolbar;\n    }\n\n    protected getArea(): React.SFC<{}> {\n        return () => <div>\n            <p>\n                <GraphVisualizer\n                    graph={graphModel}\n                    adapterType={'writable'}\n                    namedEdges={false}\n                    vertexNaming={true}\n                    withoutDragging={true}\n                    edgeNaming={false}\n                    incidentEdges={true}\n                />\n            </p>\n        </div>;\n\n        //return () =>\n        //    <GraphVisualizer\n        //        graph={graphModelres}\n        //        adapterType={'readable'}\n        //        namedEdges={false}\n        //        vertexNaming={false}\n        //        withoutDragging={false}\n        //        edgeNaming={false}\n        //        incidentEdges={false}\n        //    />;\n    }\n\n    protected task(): SFC<{}> {\n        graphModel.vertices.forEach(v => (console.log(`id = ${v.id}; label = ${v.label}; name = ${v.name}; wawe=${v.wave}.\\n`)));\n        return () =>\n            <div>\n                <p>\n                    {this.message_0}\n                </p>\n                <div>\n                    <p>\n                        <GraphVisualizer\n                            graph={graphModel1}\n                            adapterType={'readable'}\n                            namedEdges={false}\n                            vertexNaming={false}\n                            withoutDragging={true}\n                            edgeNaming={false}\n                            incidentEdges={false}\n                        />\n                    </p>\n                    <p>\n                        <GraphVisualizer\n                            graph={graphModel2}\n                            adapterType={'readable'}\n                            namedEdges={false}\n                            vertexNaming={false}\n                            withoutDragging={true}\n                            edgeNaming={false}\n                            incidentEdges={false}\n                        />\n                    </p>\n                </div>\n            </div>\n    }\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}