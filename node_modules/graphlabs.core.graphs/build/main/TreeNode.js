"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @classdesc
 * TreeNode<T> implementation of the ITreeNode interface
 */
var TreeNode = /** @class */ (function () {
    /**
     * @constructor
     */
    function TreeNode(label, weight) {
        /**
         * @property
         * @public
         * The list of node's children
         */
        this.children = [];
        this.id = TreeNode.lastId++;
        this.label = label;
        this.weight = weight;
        this.children = [];
    }
    /**
     * @public
     * Gets the node's unique identifier
     */
    TreeNode.prototype.getId = function () {
        return this.id;
    };
    /**
     * @public
     * Gets the node's label
     */
    TreeNode.prototype.getLabel = function () {
        return this.label;
    };
    /**
     * @public
     * Gets the node's position on canvas
     * @returns {number; number}
     */
    TreeNode.prototype.getPosition = function () {
        if (this.position === void 0) {
            throw Error("Position wasn't specified");
        }
        return this.position;
    };
    /**
     * @public
     * Sets the new node's position
     * @param pos
     */
    TreeNode.prototype.setPosition = function (pos) {
        if (this.position === void 0) {
            this.position = pos;
        }
        if (pos.x !== this.position.x) {
            this.position.x = pos.x;
        }
        if (pos.y !== this.position.y) {
            this.position.y = pos.y;
        }
    };
    /**
     * @public
     * Adds the new node's child
     * @param parentId
     * @param label
     * @param weight
     * @param position
     */
    TreeNode.prototype.addChild = function (parentId, label, weight) {
        var node = this.getNodeById(parentId);
        node.children.push(new TreeNode(label, weight));
    };
    /**
     * @public
     * Removes node
     * @param nodeId
     */
    TreeNode.prototype.removeNode = function (nodeId) {
        var parentNode = this.deepNodeSearch(function (n) { return n.children.some(function (e) { return e.id === nodeId; }); });
        if (parentNode === void 0) {
            throw Error("Root cannot be removed.");
        }
        parentNode.children = parentNode.children.filter(function (e) { return e.id !== nodeId; });
    };
    /**
     * @public
     * Finds node by id
     * @param nodeId
     * @returns {TreeNode<T>}
     */
    TreeNode.prototype.getNodeById = function (nodeId) {
        var node = this.deepNodeSearch(function (n) { return n.id === nodeId; });
        if (node === void 0) {
            throw Error("No node found by specified id.");
        }
        return node;
    };
    /**
     * @public
     * Gets all nodes
     * @returns {TreeNode<T>[]}
     */
    TreeNode.prototype.getNodeList = function () {
        var childrenNodeList = this.children.map(function (e) { return e.getNodeList(); }).reduce(function (a, b) { return a.concat(b); }, []);
        var self = this;
        return [self].concat(childrenNodeList).sort(function (a, b) { return a.getId() - b.getId(); });
    };
    /**
     * @public
     * Finds node by condition
     * @param predicate
     * @returns {TreeNode<T> | void}
     */
    TreeNode.prototype.deepNodeSearch = function (predicate) {
        if (predicate(this)) {
            return this;
        }
        if (this.children.length > 0) {
            return this.children.map(function (e) { return e.deepNodeSearch(predicate); }).filter(function (e) { return e !== void 0; })[0];
        }
        return void 0;
    };
    /**
     * @property
     * @private
     * Max identifier of list of nodes
     */
    TreeNode.lastId = 0;
    return TreeNode;
}());
exports.TreeNode = TreeNode;
//# sourceMappingURL=TreeNode.js.map