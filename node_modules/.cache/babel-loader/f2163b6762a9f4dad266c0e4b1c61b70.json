{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Edge_1 = require(\"./Edge\");\n/**\r\n * @classdesc\r\n * Directed edge\r\n */\n\n\nvar DirectedEdge =\n/** @class */\nfunction (_super) {\n  __extends(DirectedEdge, _super);\n  /**\r\n   * @constructor\r\n   * @param vertexOne\r\n   * @param vertexTwo\r\n   */\n\n\n  function DirectedEdge(vertexOne, vertexTwo) {\n    return _super.call(this, vertexOne, vertexTwo) || this;\n  }\n\n  Object.defineProperty(DirectedEdge.prototype, \"isDirected\", {\n    /**\r\n     * @property\r\n     * @public\r\n     * Shows the edge is directed\r\n     * @returns {boolean}\r\n     */\n    get: function () {\n      return true;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DirectedEdge;\n}(Edge_1.Edge);\n\nexports.DirectedEdge = DirectedEdge;","map":{"version":3,"sources":["../../src/main/DirectedEdge.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAGA;;;AAGG;;;AACH,IAAA,YAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAkC,EAAA,SAAA,CAAA,YAAA,EAAA,MAAA,CAAA;AAYhC;;;;AAIG;;;AACH,WAAA,YAAA,CAAmB,SAAnB,EAAuC,SAAvC,EAAyD;WACvD,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,SAAN,EAAiB,SAAjB,KAA2B,I;AAC5B;;AAXD,EAAA,MAAA,CAAA,cAAA,CAAW,YAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AANrB;;;;;AAKG;SACH,YAAA;AACE,aAAO,IAAP;AACD,KAFoB;oBAAA;;AAAA,GAArB;AAYF,SAAA,YAAA;AAAC,CApBD,CAAkC,MAAA,CAAA,IAAlC,CAAA;;AAAa,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Edge_1 = require(\"./Edge\");\r\n/**\r\n * @classdesc\r\n * Directed edge\r\n */\r\nvar DirectedEdge = /** @class */ (function (_super) {\r\n    __extends(DirectedEdge, _super);\r\n    /**\r\n     * @constructor\r\n     * @param vertexOne\r\n     * @param vertexTwo\r\n     */\r\n    function DirectedEdge(vertexOne, vertexTwo) {\r\n        return _super.call(this, vertexOne, vertexTwo) || this;\r\n    }\r\n    Object.defineProperty(DirectedEdge.prototype, \"isDirected\", {\r\n        /**\r\n         * @property\r\n         * @public\r\n         * Shows the edge is directed\r\n         * @returns {boolean}\r\n         */\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return DirectedEdge;\r\n}(Edge_1.Edge));\r\nexports.DirectedEdge = DirectedEdge;\r\n//# sourceMappingURL=DirectedEdge.js.map"]},"metadata":{},"sourceType":"script"}