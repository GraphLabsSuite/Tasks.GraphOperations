{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Vertex_1 = require(\"./Vertex\");\n\nvar IsomorphismChecker_1 = require(\"../algorithms/IsomorphismChecker\");\n\nvar Edge_1 = require(\"./Edge\");\n/** @classdesc\r\n * Graph implementation of the IGraph interface */\n\n\nvar Graph =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   */\n  function Graph(directed) {\n    this._vertices = [];\n    this._edges = [];\n    this._isDirected = directed == null ? false : directed;\n  }\n\n  Object.defineProperty(Graph.prototype, \"isDirected\", {\n    /** @property\r\n     *  @public\r\n     *  Getter for _isDirected field\r\n     *  @returns {boolean}\r\n     *  */\n    get: function () {\n      return this._isDirected;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Graph.prototype, \"allowMultipleEdges\", {\n    /** @property\r\n     *  @public\r\n     *  Getter for _allowMultipleEdges field\r\n     *  @returns {boolean}\r\n     */\n    get: function () {\n      return this._allowMultipleEdges;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Graph.prototype, \"vertices\", {\n    /**\r\n     * @property\r\n     * @public\r\n     * Getter for _vertices field\r\n     * @return {T[]}\r\n     */\n    get: function () {\n      return this._vertices;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Graph.prototype, \"edges\", {\n    /**\r\n     * @property\r\n     * @public\r\n     * Getter for _edges field\r\n     * @return {K[]}\r\n     */\n    get: function () {\n      return this._edges;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Graph.prototype.clear = function () {\n    this._vertices = [];\n    this._edges = [];\n  };\n  /**\r\n   * Adds the edge to the graph\r\n   * @param edge\r\n   */\n\n\n  Graph.prototype.addEdge = function (edge) {\n    this.edges.push(edge);\n  };\n  /**\r\n   * Removes the edge from the graph\r\n   * @param edge\r\n   */\n\n\n  Graph.prototype.removeEdge = function (edge) {\n    var _this = this;\n\n    var edges = [];\n    var edgeOut = null;\n\n    do {\n      edgeOut = this.edges.pop();\n      edges.push(edgeOut);\n    } while (edgeOut === undefined || !edgeOut.equals(edge));\n\n    edges.forEach(function (e) {\n      if (!e.equals(edgeOut)) _this.edges.push(e);\n    });\n  };\n  /**\r\n   * Gets the edge between the two vertices incident to it\r\n   * @param vertexOne\r\n   * @param vertexTwo\r\n   */\n\n\n  Graph.prototype.getEdge = function (vertexOne, vertexTwo) {\n    var result = [];\n    this.edges.forEach(function (edge) {\n      if (edge.vertexOne == vertexOne && edge.vertexTwo == vertexTwo) result.push(edge);\n    });\n    return result;\n  };\n  /**\r\n   * Get the vertex by its name\r\n   * @param name\r\n   * @returns {T[]}\r\n   */\n\n\n  Graph.prototype.getVertex = function (name) {\n    var verticesOut = [];\n\n    for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {\n      var v = _a[_i];\n      if (v.name == name) verticesOut.push(v);\n    }\n\n    return verticesOut;\n  };\n  /**\r\n   * Adds the vertex to the graph\r\n   * @param vertex\r\n   */\n\n\n  Graph.prototype.addVertex = function (vertex) {\n    this.vertices.push(vertex);\n  };\n  /**\r\n   * Removes the vertex from the graph\r\n   * @param vertex\r\n   */\n\n\n  Graph.prototype.removeVertex = function (vertex) {\n    var _this = this;\n\n    var vertices = [];\n    var vertexOut = null;\n\n    if (this._vertices.length > 0) {\n      do {\n        vertexOut = this._vertices.pop();\n        vertices.push(vertexOut);\n      } while (vertexOut === undefined || !vertexOut.equals(vertex));\n\n      vertices.forEach(function (v) {\n        if (!v.equals(vertexOut)) {\n          _this.vertices.push(v);\n        }\n      });\n    }\n\n    this._edges.forEach(function (e) {\n      if (e.isIncident(vertex)) {\n        _this.removeEdge(e);\n      }\n    });\n  };\n  /**\r\n   * Returns the result of union operation for N graphs\r\n   * @param graphs\r\n   * @returns {Graph<T,K>}\r\n   */\n\n\n  Graph.unionN = function (graphs) {\n    if (graphs.length < 2) return Graph.createEmpty(0); //TODO: Think about contracts or asserts\n\n    var copies = graphs.map(function (g) {\n      return g.clone();\n    });\n    var result = copies[0];\n\n    for (var i = 1; i < copies.length; i++) {\n      copies[i].vertices.forEach(function (v) {\n        return result.addVertex(v);\n      });\n      copies[i].edges.forEach(function (e) {\n        return result.addEdge(e);\n      });\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns the result of intersect operation for N graphs\r\n   * @param graphs\r\n   * @returns {IGraph<T,K>}\r\n   */\n\n\n  Graph.intersectN = function (graphs) {\n    if (graphs.length < 2) return Graph.createEmpty(0); //TODO: Think about contracts or asserts\n\n    var copies = graphs.map(function (g) {\n      return g.clone();\n    });\n    var result = copies[0];\n\n    for (var i = 1; i < copies.length; i++) {\n      copies[i].vertices.forEach(function (v) {\n        return result.removeVertex(v);\n      });\n      copies[i].edges.forEach(function (e) {\n        return result.removeEdge(e);\n      });\n    }\n\n    return result;\n  };\n  /**\r\n   * @static\r\n   * Static builder for the directed weighted graph\r\n   * @param verticesNumber\r\n   * @return {DirectedWeightedGraph}\r\n   */\n\n\n  Graph.createEmpty = function (verticesNumber) {\n    var newGraph = new Graph();\n\n    for (var i = 0; i < verticesNumber; ++i) newGraph.addVertex(new Vertex_1.Vertex(i.toString(verticesNumber)));\n\n    return newGraph;\n  };\n  /**\r\n   * Returns the result of union operation\r\n   * @param graph\r\n   * @returns {Graph<T, K>}\r\n   */\n\n\n  Graph.prototype.union = function (graph) {\n    //TODO: Think about contracts or asserts\n    return Graph.unionN([this, graph]);\n  };\n  /**\r\n   * Returns the result of intersect operation\r\n   * @param graph\r\n   * @returns {IGraph}\r\n   */\n\n\n  Graph.prototype.intersect = function (graph) {\n    return Graph.intersectN([this, graph]);\n  };\n  /**\r\n   * Returns a complement graph to the given one\r\n   * @returns {IGraph}\r\n   */\n\n\n  Graph.prototype.complement = function () {\n    return Graph.createEmpty(0); //TODO: implementation\n  };\n  /**\r\n   * Checks if the second graph is isomorphic to the given one\r\n   * @param graph\r\n   * @returns {boolean}\r\n   */\n\n\n  Graph.prototype.checkIsomorphism = function (graph) {\n    return IsomorphismChecker_1.IsomorphismChecker.checkIsomorphism(this, graph);\n  };\n  /**\r\n   * Returns strongly connected components of the given graph\r\n   * @returns {IGraph[]}\r\n   */\n\n\n  Graph.prototype.buildSCC = function () {\n    //TODO: fix the bug with TypeError: Object prototype may only be an Object or null: undefined\n    return [];\n  };\n\n  Graph.prototype.print = function () {\n    // @ts-ignore\n    console.log(this.toString());\n  };\n\n  Graph.prototype.toString = function () {\n    var verticesListStr = '[' + this.vertices.join(',') + ']';\n    if (verticesListStr.length == 0) verticesListStr = \"\\u2205\";\n    var edgesListStr = \"\";\n    this.edges.forEach(function (g) {\n      return edgesListStr = edgesListStr + (\"{\" + g.vertexOne + \",\" + g.vertexTwo + \"}\");\n    });\n    edgesListStr = edgesListStr.length == 0 ? \"\\u2205\" : \"[\" + edgesListStr + \"]\";\n    return \"(\" + verticesListStr + \",\" + edgesListStr + \")\";\n  };\n  /**\r\n   * Deep graph-cloning\r\n   */\n\n\n  Graph.prototype.clone = function () {\n    var clone = new Graph();\n    this.vertices.forEach(function (v) {\n      return clone.addVertex(v.clone());\n    });\n\n    var _loop_1 = function (edge) {\n      var v1 = clone.vertices.filter(function (v) {\n        return edge.vertexOne.equals(v);\n      })[0]; //Single?\n\n      var v2 = clone.vertices.filter(function (v) {\n        return edge.vertexTwo.equals(v);\n      })[0];\n      clone.addEdge(new Edge_1.Edge(v1, v2));\n    };\n\n    for (var _i = 0, _a = this.edges; _i < _a.length; _i++) {\n      var edge = _a[_i];\n\n      _loop_1(edge);\n    }\n\n    return clone;\n  };\n  /**\r\n   * Get subgraph of graph\r\n   * input: vertives\r\n   */\n\n\n  Graph.prototype.getSubgraph = function (subVertices) {\n    var subGraph = new Graph();\n    subVertices.forEach(function (v) {\n      subGraph.addVertex(v.clone());\n    });\n    this.edges.filter(function (e) {\n      return subVertices.indexOf(e.vertexOne) >= 0 && subVertices.indexOf(e.vertexTwo) >= 0;\n    }).forEach(function (e) {\n      return subGraph.addEdge(new Edge_1.Edge(e.vertexOne, e.vertexTwo));\n    });\n    return subGraph;\n  };\n  /**\r\n   * Get neighbourhood\r\n   */\n\n\n  Graph.prototype.getNeighbourhood = function (vertex) {\n    var _this = this;\n\n    var neighbourhood = [];\n    this.vertices.forEach(function (v) {\n      return neighbourhood.push(v.clone());\n    });\n    return neighbourhood.reduce(function (accum, next) {\n      _this.edges.forEach(function (e) {\n        if (e.vertexOne === vertex) accum.push(e.vertexTwo);\n        if (e.vertexTwo === vertex) accum.push(e.vertexOne);\n      });\n\n      return accum;\n    }, []);\n  };\n  /**\r\n   * Get non-neighbourhood\r\n   */\n\n\n  Graph.prototype.getNonNeighbourhood = function (vertex) {\n    var neighbours = this.getNeighbourhood(vertex);\n    neighbours.push(vertex);\n    var answer = this.vertices.reduce(function (accum, next) {\n      return neighbours.indexOf(next) >= 0 ? accum : accum.concat(next);\n    }, []);\n    return answer;\n  };\n  /**\r\n   * Get vertex's degree\r\n   */\n\n\n  Graph.prototype.getVertexDegree = function (vertex) {\n    return this.edges.filter(function (e) {\n      return e.vertexOne === vertex || e.vertexTwo === vertex;\n    }).length;\n  };\n  /**\r\n   * Get vertex with minimum degree\r\n   */\n\n\n  Graph.prototype.getVertexWithMinDegree = function () {\n    var _this = this;\n\n    return this.vertices.reduce(function (min, next) {\n      if (!min || _this.getVertexDegree(next) < _this.getVertexDegree(min)) return next;\n      return min;\n    }, null);\n  };\n  /**\r\n   * Checks if the graph is connected\r\n   */\n\n\n  Graph.prototype.isConnected = function (graph) {\n    var visited = [];\n\n    for (var p = 0; p < graph.vertices.length; p++) {\n      visited.push(false);\n    }\n\n    var arr = [];\n    var visitedVertices = 0;\n\n    function numOfVertex(graph, vertex) {\n      var num = 0;\n\n      for (var i = 0; i < graph.vertices.length; i++) {\n        if (vertex.name === graph.vertices[i].name) {\n          num = i;\n        }\n      }\n\n      return num;\n    }\n\n    function dfs(d) {\n      visitedVertices = 1;\n      visited[numOfVertex(graph, d)] = true;\n      arr = d.arrOfAdjacentVertices(graph);\n\n      for (var k = 0; k < arr.length; k++) {\n        if (!visited[numOfVertex(graph, arr[k])]) {\n          visitedVertices = visitedVertices + dfs(arr[k]);\n        }\n      }\n\n      return visitedVertices;\n    }\n\n    return dfs(graph.vertices[0]) === graph.vertices.length;\n  };\n\n  return Graph;\n}();\n\nexports.Graph = Graph;","map":{"version":3,"sources":["../../src/main/Graph.ts"],"names":[],"mappings":";;;;;;AAGA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,IAAA,oBAAA,GAAA,OAAA,CAAA,kCAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAGA;AACkD;;;AAClD,IAAA,KAAA;AAAA;AAAA,YAAA;AAyDE;;AAEG;AACF,WAAA,KAAA,CAAmB,QAAnB,EAAqC;AACpC,SAAK,SAAL,GAAiB,EAAjB;AACA,SAAK,MAAL,GAAc,EAAd;AACA,SAAK,WAAL,GAAmB,QAAQ,IAAI,IAAZ,GAAmB,KAAnB,GAA2B,QAA9C;AACD;;AAxCD,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AALrB;;;;AAIM;SACN,YAAA;AACE,aAAO,KAAK,WAAZ;AACD,KAFoB;oBAAA;;AAAA,GAArB;AASA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,oBAAX,EAA6B;AAL7B;;;;AAIG;SACH,YAAA;AACE,aAAO,KAAK,mBAAZ;AACD,KAF4B;oBAAA;;AAAA,GAA7B;AAUA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,UAAX,EAAmB;AANnB;;;;;AAKG;SACH,YAAA;AACE,aAAO,KAAK,SAAZ;AACD,KAFkB;oBAAA;;AAAA,GAAnB;AAUA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,OAAX,EAAgB;AANhB;;;;;AAKG;SACH,YAAA;AACE,aAAO,KAAK,MAAZ;AACD,KAFe;oBAAA;;AAAA,GAAhB;;AAaO,EAAA,KAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACG,SAAK,SAAL,GAAiB,EAAjB;AACA,SAAK,MAAL,GAAc,EAAd;AACF,GAHM;AAKP;;;AAGG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,IAAf,EAAsB;AACpB,SAAK,KAAL,CAAW,IAAX,CAAgB,IAAhB;AACD,GAFM;AAIP;;;AAGG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,IAAlB,EAAyB;AAAzB,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,KAAK,GAAQ,EAAjB;AACA,QAAI,OAAO,GAAM,IAAjB;;AACA,OAAG;AACD,MAAA,OAAO,GAAG,KAAK,KAAL,CAAW,GAAX,EAAV;AACA,MAAA,KAAK,CAAC,IAAN,CAAW,OAAX;AACD,KAHD,QAGS,OAAO,KAAK,SAAZ,IAAyB,CAAC,OAAO,CAAC,MAAR,CAAe,IAAf,CAHnC;;AAIA,IAAA,KAAK,CAAC,OAAN,CAAc,UAAA,CAAA,EAAC;AACb,UAAI,CAAC,CAAC,CAAC,MAAF,CAAS,OAAT,CAAL,EACE,KAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,CAAhB;AACH,KAHD;AAID,GAXM;AAaP;;;;AAIG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,SAAf,EAA6B,SAA7B,EAAyC;AACvC,QAAI,MAAM,GAAQ,EAAlB;AACA,SAAK,KAAL,CAAW,OAAX,CAAmB,UAAA,IAAA,EAAI;AACrB,UAAI,IAAI,CAAC,SAAL,IAAkB,SAAlB,IAA+B,IAAI,CAAC,SAAL,IAAkB,SAArD,EAAgE,MAAM,CAAC,IAAP,CAAY,IAAZ;AACjE,KAFD;AAGA,WAAO,MAAP;AACD,GANM;AAQP;;;;AAIG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,IAAjB,EAA6B;AAC3B,QAAI,WAAW,GAAQ,EAAvB;;AACA,SAAgB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,QAArB,EAAgB,EAAA,GAAA,EAAA,CAAA,MAAhB,EAAgB,EAAA,EAAhB,EAA6B;AAAxB,UAAM,CAAC,GAAA,EAAA,CAAA,EAAA,CAAP;AACH,UAAI,CAAC,CAAC,IAAF,IAAU,IAAd,EAAoB,WAAW,CAAC,IAAZ,CAAiB,CAAjB;AAAoB;;AAC1C,WAAO,WAAP;AACD,GALM;AAOP;;;AAGG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,MAAjB,EAA0B;AACxB,SAAK,QAAL,CAAc,IAAd,CAAmB,MAAnB;AACD,GAFM;AAIP;;;AAGG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,MAApB,EAA6B;AAA7B,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,QAAQ,GAAQ,EAApB;AACA,QAAI,SAAS,GAAM,IAAnB;;AACA,QAAI,KAAK,SAAL,CAAe,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,SAAG;AACD,QAAA,SAAS,GAAG,KAAK,SAAL,CAAe,GAAf,EAAZ;AACA,QAAA,QAAQ,CAAC,IAAT,CAAc,SAAd;AACD,OAHD,QAGS,SAAS,KAAK,SAAd,IAA2B,CAAC,SAAS,CAAC,MAAV,CAAiB,MAAjB,CAHrC;;AAIA,MAAA,QAAQ,CAAC,OAAT,CAAiB,UAAA,CAAA,EAAC;AAChB,YAAI,CAAC,CAAC,CAAC,MAAF,CAAS,SAAT,CAAL,EAA0B;AACxB,UAAA,KAAI,CAAC,QAAL,CAAc,IAAd,CAAmB,CAAnB;AACD;AACF,OAJD;AAKD;;AACD,SAAK,MAAL,CAAY,OAAZ,CAAoB,UAAA,CAAA,EAAC;AACnB,UAAI,CAAC,CAAC,UAAF,CAAa,MAAb,CAAJ,EAA0B;AACxB,QAAA,KAAI,CAAC,UAAL,CAAgB,CAAhB;AACD;AACF,KAJD;AAKD,GAnBM;AAqBP;;;;AAIG;;;AACW,EAAA,KAAA,CAAA,MAAA,GAAd,UAAqB,MAArB,EAAqD;AACnD,QAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB,OAAO,KAAK,CAAC,WAAN,CAAkB,CAAlB,CAAP,CAD4B,CAEnD;;AACA,QAAM,MAAM,GAA0B,MAAM,CAAC,GAAP,CAAW,UAAA,CAAA,EAAC;AAAI,aAAsB,CAAC,CAAvB,KAAsB,EAAtB;AAA+B,KAA/C,CAAtC;AACA,QAAM,MAAM,GAAwB,MAAM,CAAC,CAAD,CAA1C;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,MAAA,MAAM,CAAC,CAAD,CAAN,CAAU,QAAV,CAAmB,OAAnB,CAA2B,UAAA,CAAA,EAAC;AAAI,eAAA,MAAM,CAAC,SAAP,CAAA,CAAA,CAAA;AAAmB,OAAnD;AACA,MAAA,MAAM,CAAC,CAAD,CAAN,CAAU,KAAV,CAAgB,OAAhB,CAAwB,UAAA,CAAA,EAAC;AAAI,eAAA,MAAM,CAAC,OAAP,CAAA,CAAA,CAAA;AAAiB,OAA9C;AACD;;AAED,WAAO,MAAP;AACD,GAXa;AAad;;;;AAIG;;;AACW,EAAA,KAAA,CAAA,UAAA,GAAd,UAAyB,MAAzB,EAAyD;AACvD,QAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB,OAAO,KAAK,CAAC,WAAN,CAAkB,CAAlB,CAAP,CADgC,CAEvD;;AACA,QAAM,MAAM,GAA0B,MAAM,CAAC,GAAP,CAAW,UAAA,CAAA,EAAC;AAAI,aAAsB,CAAC,CAAvB,KAAsB,EAAtB;AAA+B,KAA/C,CAAtC;AACA,QAAM,MAAM,GAAwB,MAAM,CAAC,CAAD,CAA1C;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,MAAA,MAAM,CAAC,CAAD,CAAN,CAAU,QAAV,CAAmB,OAAnB,CAA2B,UAAA,CAAA,EAAC;AAAI,eAAA,MAAM,CAAC,YAAP,CAAA,CAAA,CAAA;AAAsB,OAAtD;AACA,MAAA,MAAM,CAAC,CAAD,CAAN,CAAU,KAAV,CAAgB,OAAhB,CAAwB,UAAA,CAAA,EAAC;AAAI,eAAA,MAAM,CAAC,UAAP,CAAA,CAAA,CAAA;AAAoB,OAAjD;AACD;;AAED,WAAO,MAAP;AACD,GAXa;AAad;;;;;AAKG;;;AACW,EAAA,KAAA,CAAA,WAAA,GAAd,UAA0B,cAA1B,EAAgD;AAC9C,QAAM,QAAQ,GAAG,IAAI,KAAJ,EAAjB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,cAApB,EAAoC,EAAE,CAAtC,EACE,QAAQ,CAAC,SAAT,CAAmB,IAAI,QAAA,CAAA,MAAJ,CAAW,CAAC,CAAC,QAAF,CAAW,cAAX,CAAX,CAAnB;;AACF,WAAO,QAAP;AACD,GALa;AAOd;;;;AAIG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,KAAb,EAA0C;AACxC;AACA,WAAO,KAAK,CAAC,MAAN,CAAa,CAAC,IAAD,EAAO,KAAP,CAAb,CAAP;AACD,GAHM;AAKP;;;;AAIG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,KAAjB,EAA8C;AAC5C,WAAO,KAAK,CAAC,UAAN,CAAiB,CAAC,IAAD,EAAO,KAAP,CAAjB,CAAP;AACD,GAFM;AAIP;;;AAGG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,UAAA,GAAP,YAAA;AACE,WAAO,KAAK,CAAC,WAAN,CAAkB,CAAlB,CAAP,CADF,CAC+B;AAC9B,GAFM;AAIP;;;;AAIG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,KAAxB,EAAqD;AACnD,WAAO,oBAAA,CAAA,kBAAA,CAAmB,gBAAnB,CAAoC,IAApC,EAA0C,KAA1C,CAAP;AACD,GAFM;AAIP;;;AAGG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACE;AACA,WAAO,EAAP;AACD,GAHM;;AAKA,EAAA,KAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACE;AACA,IAAA,OAAO,CAAC,GAAR,CAAY,KAAK,QAAL,EAAZ;AACD,GAHM;;AAKA,EAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACE,QAAI,eAAe,GAAW,MAAM,KAAK,QAAL,CAAc,IAAd,CAAmB,GAAnB,CAAN,GAAgC,GAA9D;AACA,QAAI,eAAe,CAAC,MAAhB,IAA0B,CAA9B,EAAiC,eAAe,GAAG,QAAlB;AAEjC,QAAI,YAAY,GAAG,EAAnB;AACA,SAAK,KAAL,CAAW,OAAX,CAAmB,UAAA,CAAA,EAAC;AAAI,aAAA,YAAY,GAAG,YAAY,IAAG,MAAI,CAAC,CAAC,SAAN,GAAe,GAAf,GAAmB,CAAC,CAAC,SAArB,GAA9B,GAA2B,CAA3B;AAA+D,KAAvF;AACA,IAAA,YAAY,GAAI,YAAY,CAAC,MAAb,IAAuB,CAAxB,GAA6B,QAA7B,GAAwC,MAAI,YAAJ,GAAgB,GAAvE;AAEA,WAAO,MAAI,eAAJ,GAAmB,GAAnB,GAAuB,YAAvB,GAAmC,GAA1C;AACD,GATM;AAWP;;AAEG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACE,QAAM,KAAK,GAAG,IAAI,KAAJ,EAAd;AACA,SAAK,QAAL,CAAc,OAAd,CAAsB,UAAA,CAAA,EAAC;AAAI,aAAA,KAAK,CAAC,SAAN,CAAgB,CAAC,CAAjB,KAAgB,EAAhB,CAAA;AAA0B,KAArD;;4BACW,I,EAAI;AAEb,UAAM,EAAE,GAAG,KAAK,CAAC,QAAN,CAAe,MAAf,CAAsB,UAAA,CAAA,EAAC;AAAI,eAAA,IAAI,CAAC,SAAL,CAAe,MAAf,CAAA,CAAA,CAAA;AAAwB,OAAnD,EAAqD,CAArD,CAAX,CAFa,CAEuD;;AACpE,UAAM,EAAE,GAAG,KAAK,CAAC,QAAN,CAAe,MAAf,CAAsB,UAAA,CAAA,EAAC;AAAI,eAAA,IAAI,CAAC,SAAL,CAAe,MAAf,CAAA,CAAA,CAAA;AAAwB,OAAnD,EAAqD,CAArD,CAAX;AACA,MAAA,KAAK,CAAC,OAAN,CAAc,IAAI,MAAA,CAAA,IAAJ,CAAS,EAAT,EAAa,EAAb,CAAd;;;AAJF,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,KAAxB,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAA6B;AAAxB,UAAM,IAAI,GAAA,EAAA,CAAA,EAAA,CAAV;;cAAM,I;AAKV;;AAED,WAAO,KAAP;AACD,GAXM;AAaP;;;AAGG;;;AACK,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,WAAnB,EAAmC;AAChC,QAAM,QAAQ,GAAG,IAAI,KAAJ,EAAjB;AACA,IAAA,WAAW,CAAC,OAAZ,CAAoB,UAAA,CAAA,EAAC;AACjB,MAAA,QAAQ,CAAC,SAAT,CAAmB,CAAC,CAAC,KAAF,EAAnB;AACH,KAFD;AAGA,SAAK,KAAL,CAAW,MAAX,CAAkB,UAAA,CAAA,EAAC;AACf,aAAC,WAAW,CAAC,OAAZ,CAAuB,CAAC,CAAC,SAAzB,KAAuC,CAAxC,IACK,WAAW,CAAC,OAAZ,CAAuB,CAAC,CAAC,SAAzB,KAAuC,CAD5C;AAC8C,KAFlD,EAEoD,OAFpD,CAE4D,UAAC,CAAD,EAAK;AAAK,aAAA,QAAQ,CAAC,OAAT,CAAiB,IAAI,MAAA,CAAA,IAAJ,CAAS,CAAC,CAAC,SAAX,EAAsB,CAAC,CAAxC,SAAiB,CAAjB,CAAA;AAAoD,KAF1H;AAGA,WAAO,QAAP;AACH,GATO;AAWR;;AAEG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,MAAxB,EAAsC;AAAtC,QAAA,KAAA,GAAA,IAAA;;AACI,QAAM,aAAa,GAAa,EAAhC;AACA,SAAK,QAAL,CAAc,OAAd,CAAsB,UAAC,CAAD,EAAU;AAAK,aAAA,aAAa,CAAC,IAAd,CAAmB,CAAC,CAApB,KAAmB,EAAnB,CAAA;AAA6B,KAAlE;AACA,WAAO,aAAa,CAAC,MAAd,CAAqB,UAAC,KAAD,EAAkB,IAAlB,EAA8B;AAClD,MAAA,KAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,UAAA,CAAA,EAAC;AAClB,YAAI,CAAC,CAAC,SAAF,KAAgB,MAApB,EAA4B,KAAK,CAAC,IAAN,CAAW,CAAC,CAAC,SAAb;AAC5B,YAAI,CAAC,CAAC,SAAF,KAAgB,MAApB,EAA4B,KAAK,CAAC,IAAN,CAAW,CAAC,CAAC,SAAb;AAC7B,OAHD;;AAIA,aAAO,KAAP;AACD,KANA,EAME,EANF,CAAP;AAOH,GAVM;AAYP;;AAEG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,mBAAA,GAAP,UAA2B,MAA3B,EAAyC;AACrC,QAAM,UAAU,GAAG,KAAK,gBAAL,CAAsB,MAAtB,CAAnB;AACA,IAAA,UAAU,CAAC,IAAX,CAAgB,MAAhB;AACA,QAAM,MAAM,GAAG,KAAK,QAAL,CAAc,MAAd,CAAqB,UAAC,KAAD,EAAkB,IAAlB,EAA8B;AAC9D,aAAC,UAAU,CAAC,OAAX,CAAmB,IAAnB,KAA4B,CAA7B,GACI,KADJ,GACY,KAAK,CAAC,MAAN,CAAa,IAAb,CADZ;AAC8B,KAFnB,EAEqB,EAFrB,CAAf;AAGA,WAAO,MAAP;AACH,GAPM;AASP;;AAEG;;;AACI,EAAA,KAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,MAAvB,EAAqC;AACnC,WAAO,KAAK,KAAL,CAAW,MAAX,CAAkB,UAAC,CAAD,EAAQ;AAAK,aAAC,CAAC,CAAC,SAAF,KAAgB,MAAjB,IAA6B,CAAC,CAAC,SAAF,KAA7B,MAAA;AAAoD,KAAnF,EAAqF,MAA5F;AACD,GAFM;AAIP;;AAEG;;;AACK,EAAA,KAAA,CAAA,SAAA,CAAA,sBAAA,GAAP,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,WAAO,KAAK,QAAL,CAAc,MAAd,CAAqB,UAAC,GAAD,EAAqB,IAArB,EAAiC;AAC3D,UAAI,CAAC,GAAD,IAAQ,KAAI,CAAC,eAAL,CAAqB,IAArB,IAA6B,KAAI,CAAC,eAAL,CAAqB,GAArB,CAAzC,EAAoE,OAAO,IAAP;AACpE,aAAO,GAAP;AACD,KAHM,EAGJ,IAHI,CAAP;AAID,GALM;AAQR;;AAEG;;;AAEE,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,KAAnB,EAAgD;AACxC,QAAI,OAAO,GAAc,EAAzB;;AACA,SAAI,IAAI,CAAC,GAAG,CAAZ,EAAe,CAAC,GAAG,KAAK,CAAC,QAAN,CAAe,MAAlC,EAA0C,CAAC,EAA3C,EAA8C;AAC1C,MAAA,OAAO,CAAC,IAAR,CAAa,KAAb;AACH;;AACD,QAAI,GAAG,GAAc,EAArB;AACA,QAAI,eAAe,GAAG,CAAtB;;AACA,aAAS,WAAT,CAAqB,KAArB,EAAoD,MAApD,EAAmE;AAC/D,UAAI,GAAG,GAAG,CAAV;;AACA,WAAI,IAAI,CAAC,GAAG,CAAZ,EAAe,CAAC,GAAG,KAAK,CAAC,QAAN,CAAe,MAAlC,EAA0C,CAAC,EAA3C,EAA8C;AAC1C,YAAG,MAAM,CAAC,IAAP,KAAgB,KAAK,CAAC,QAAN,CAAe,CAAf,EAAkB,IAArC,EAA0C;AACtC,UAAA,GAAG,GAAG,CAAN;AACH;AACJ;;AACD,aAAO,GAAP;AACH;;AACD,aAAS,GAAT,CAAa,CAAb,EAAuB;AACnB,MAAA,eAAe,GAAG,CAAlB;AACA,MAAA,OAAO,CAAC,WAAW,CAAC,KAAD,EAAQ,CAAR,CAAZ,CAAP,GAAiC,IAAjC;AACA,MAAA,GAAG,GAAG,CAAC,CAAC,qBAAF,CAAwB,KAAxB,CAAN;;AACI,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,YAAI,CAAC,OAAO,CAAC,WAAW,CAAC,KAAD,EAAQ,GAAG,CAAC,CAAD,CAAX,CAAZ,CAAZ,EAA0C;AACtC,UAAA,eAAe,GAAG,eAAe,GAAG,GAAG,CAAC,GAAG,CAAC,CAAD,CAAJ,CAAvC;AACH;AACJ;;AAEL,aAAO,eAAP;AACH;;AACD,WAAQ,GAAG,CAAC,KAAK,CAAC,QAAN,CAAe,CAAf,CAAD,CAAH,KAA2B,KAAK,CAAC,QAAN,CAAe,MAAlD;AACH,GA7BE;;AA+BP,SAAA,KAAA;AAAC,CAvXD,EAAA;;AAAa,OAAA,CAAA,KAAA,GAAA,KAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Vertex_1 = require(\"./Vertex\");\r\nvar IsomorphismChecker_1 = require(\"../algorithms/IsomorphismChecker\");\r\nvar Edge_1 = require(\"./Edge\");\r\n/** @classdesc\r\n * Graph implementation of the IGraph interface */\r\nvar Graph = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     */\r\n    function Graph(directed) {\r\n        this._vertices = [];\r\n        this._edges = [];\r\n        this._isDirected = directed == null ? false : directed;\r\n    }\r\n    Object.defineProperty(Graph.prototype, \"isDirected\", {\r\n        /** @property\r\n         *  @public\r\n         *  Getter for _isDirected field\r\n         *  @returns {boolean}\r\n         *  */\r\n        get: function () {\r\n            return this._isDirected;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Graph.prototype, \"allowMultipleEdges\", {\r\n        /** @property\r\n         *  @public\r\n         *  Getter for _allowMultipleEdges field\r\n         *  @returns {boolean}\r\n         */\r\n        get: function () {\r\n            return this._allowMultipleEdges;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Graph.prototype, \"vertices\", {\r\n        /**\r\n         * @property\r\n         * @public\r\n         * Getter for _vertices field\r\n         * @return {T[]}\r\n         */\r\n        get: function () {\r\n            return this._vertices;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Graph.prototype, \"edges\", {\r\n        /**\r\n         * @property\r\n         * @public\r\n         * Getter for _edges field\r\n         * @return {K[]}\r\n         */\r\n        get: function () {\r\n            return this._edges;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Graph.prototype.clear = function () {\r\n        this._vertices = [];\r\n        this._edges = [];\r\n    };\r\n    /**\r\n     * Adds the edge to the graph\r\n     * @param edge\r\n     */\r\n    Graph.prototype.addEdge = function (edge) {\r\n        this.edges.push(edge);\r\n    };\r\n    /**\r\n     * Removes the edge from the graph\r\n     * @param edge\r\n     */\r\n    Graph.prototype.removeEdge = function (edge) {\r\n        var _this = this;\r\n        var edges = [];\r\n        var edgeOut = null;\r\n        do {\r\n            edgeOut = this.edges.pop();\r\n            edges.push(edgeOut);\r\n        } while (edgeOut === undefined || !edgeOut.equals(edge));\r\n        edges.forEach(function (e) {\r\n            if (!e.equals(edgeOut))\r\n                _this.edges.push(e);\r\n        });\r\n    };\r\n    /**\r\n     * Gets the edge between the two vertices incident to it\r\n     * @param vertexOne\r\n     * @param vertexTwo\r\n     */\r\n    Graph.prototype.getEdge = function (vertexOne, vertexTwo) {\r\n        var result = [];\r\n        this.edges.forEach(function (edge) {\r\n            if (edge.vertexOne == vertexOne && edge.vertexTwo == vertexTwo)\r\n                result.push(edge);\r\n        });\r\n        return result;\r\n    };\r\n    /**\r\n     * Get the vertex by its name\r\n     * @param name\r\n     * @returns {T[]}\r\n     */\r\n    Graph.prototype.getVertex = function (name) {\r\n        var verticesOut = [];\r\n        for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {\r\n            var v = _a[_i];\r\n            if (v.name == name)\r\n                verticesOut.push(v);\r\n        }\r\n        return verticesOut;\r\n    };\r\n    /**\r\n     * Adds the vertex to the graph\r\n     * @param vertex\r\n     */\r\n    Graph.prototype.addVertex = function (vertex) {\r\n        this.vertices.push(vertex);\r\n    };\r\n    /**\r\n     * Removes the vertex from the graph\r\n     * @param vertex\r\n     */\r\n    Graph.prototype.removeVertex = function (vertex) {\r\n        var _this = this;\r\n        var vertices = [];\r\n        var vertexOut = null;\r\n        if (this._vertices.length > 0) {\r\n            do {\r\n                vertexOut = this._vertices.pop();\r\n                vertices.push(vertexOut);\r\n            } while (vertexOut === undefined || !vertexOut.equals(vertex));\r\n            vertices.forEach(function (v) {\r\n                if (!v.equals(vertexOut)) {\r\n                    _this.vertices.push(v);\r\n                }\r\n            });\r\n        }\r\n        this._edges.forEach(function (e) {\r\n            if (e.isIncident(vertex)) {\r\n                _this.removeEdge(e);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Returns the result of union operation for N graphs\r\n     * @param graphs\r\n     * @returns {Graph<T,K>}\r\n     */\r\n    Graph.unionN = function (graphs) {\r\n        if (graphs.length < 2)\r\n            return Graph.createEmpty(0);\r\n        //TODO: Think about contracts or asserts\r\n        var copies = graphs.map(function (g) { return g.clone(); });\r\n        var result = copies[0];\r\n        for (var i = 1; i < copies.length; i++) {\r\n            copies[i].vertices.forEach(function (v) { return result.addVertex(v); });\r\n            copies[i].edges.forEach(function (e) { return result.addEdge(e); });\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Returns the result of intersect operation for N graphs\r\n     * @param graphs\r\n     * @returns {IGraph<T,K>}\r\n     */\r\n    Graph.intersectN = function (graphs) {\r\n        if (graphs.length < 2)\r\n            return Graph.createEmpty(0);\r\n        //TODO: Think about contracts or asserts\r\n        var copies = graphs.map(function (g) { return g.clone(); });\r\n        var result = copies[0];\r\n        for (var i = 1; i < copies.length; i++) {\r\n            copies[i].vertices.forEach(function (v) { return result.removeVertex(v); });\r\n            copies[i].edges.forEach(function (e) { return result.removeEdge(e); });\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * @static\r\n     * Static builder for the directed weighted graph\r\n     * @param verticesNumber\r\n     * @return {DirectedWeightedGraph}\r\n     */\r\n    Graph.createEmpty = function (verticesNumber) {\r\n        var newGraph = new Graph();\r\n        for (var i = 0; i < verticesNumber; ++i)\r\n            newGraph.addVertex(new Vertex_1.Vertex(i.toString(verticesNumber)));\r\n        return newGraph;\r\n    };\r\n    /**\r\n     * Returns the result of union operation\r\n     * @param graph\r\n     * @returns {Graph<T, K>}\r\n     */\r\n    Graph.prototype.union = function (graph) {\r\n        //TODO: Think about contracts or asserts\r\n        return Graph.unionN([this, graph]);\r\n    };\r\n    /**\r\n     * Returns the result of intersect operation\r\n     * @param graph\r\n     * @returns {IGraph}\r\n     */\r\n    Graph.prototype.intersect = function (graph) {\r\n        return Graph.intersectN([this, graph]);\r\n    };\r\n    /**\r\n     * Returns a complement graph to the given one\r\n     * @returns {IGraph}\r\n     */\r\n    Graph.prototype.complement = function () {\r\n        return Graph.createEmpty(0); //TODO: implementation\r\n    };\r\n    /**\r\n     * Checks if the second graph is isomorphic to the given one\r\n     * @param graph\r\n     * @returns {boolean}\r\n     */\r\n    Graph.prototype.checkIsomorphism = function (graph) {\r\n        return IsomorphismChecker_1.IsomorphismChecker.checkIsomorphism(this, graph);\r\n    };\r\n    /**\r\n     * Returns strongly connected components of the given graph\r\n     * @returns {IGraph[]}\r\n     */\r\n    Graph.prototype.buildSCC = function () {\r\n        //TODO: fix the bug with TypeError: Object prototype may only be an Object or null: undefined\r\n        return [];\r\n    };\r\n    Graph.prototype.print = function () {\r\n        // @ts-ignore\r\n        console.log(this.toString());\r\n    };\r\n    Graph.prototype.toString = function () {\r\n        var verticesListStr = '[' + this.vertices.join(',') + ']';\r\n        if (verticesListStr.length == 0)\r\n            verticesListStr = \"\\u2205\";\r\n        var edgesListStr = \"\";\r\n        this.edges.forEach(function (g) { return edgesListStr = edgesListStr + (\"{\" + g.vertexOne + \",\" + g.vertexTwo + \"}\"); });\r\n        edgesListStr = (edgesListStr.length == 0) ? \"\\u2205\" : \"[\" + edgesListStr + \"]\";\r\n        return \"(\" + verticesListStr + \",\" + edgesListStr + \")\";\r\n    };\r\n    /**\r\n     * Deep graph-cloning\r\n     */\r\n    Graph.prototype.clone = function () {\r\n        var clone = new Graph();\r\n        this.vertices.forEach(function (v) { return clone.addVertex(v.clone()); });\r\n        var _loop_1 = function (edge) {\r\n            var v1 = clone.vertices.filter(function (v) { return edge.vertexOne.equals(v); })[0]; //Single?\r\n            var v2 = clone.vertices.filter(function (v) { return edge.vertexTwo.equals(v); })[0];\r\n            clone.addEdge(new Edge_1.Edge(v1, v2));\r\n        };\r\n        for (var _i = 0, _a = this.edges; _i < _a.length; _i++) {\r\n            var edge = _a[_i];\r\n            _loop_1(edge);\r\n        }\r\n        return clone;\r\n    };\r\n    /**\r\n     * Get subgraph of graph\r\n     * input: vertives\r\n     */\r\n    Graph.prototype.getSubgraph = function (subVertices) {\r\n        var subGraph = new Graph();\r\n        subVertices.forEach(function (v) {\r\n            subGraph.addVertex(v.clone());\r\n        });\r\n        this.edges.filter(function (e) {\r\n            return (subVertices.indexOf(e.vertexOne) >= 0)\r\n                && (subVertices.indexOf(e.vertexTwo) >= 0);\r\n        }).forEach(function (e) { return subGraph.addEdge(new Edge_1.Edge(e.vertexOne, e.vertexTwo)); });\r\n        return subGraph;\r\n    };\r\n    /**\r\n     * Get neighbourhood\r\n     */\r\n    Graph.prototype.getNeighbourhood = function (vertex) {\r\n        var _this = this;\r\n        var neighbourhood = [];\r\n        this.vertices.forEach(function (v) { return neighbourhood.push(v.clone()); });\r\n        return neighbourhood.reduce(function (accum, next) {\r\n            _this.edges.forEach(function (e) {\r\n                if (e.vertexOne === vertex)\r\n                    accum.push(e.vertexTwo);\r\n                if (e.vertexTwo === vertex)\r\n                    accum.push(e.vertexOne);\r\n            });\r\n            return accum;\r\n        }, []);\r\n    };\r\n    /**\r\n     * Get non-neighbourhood\r\n     */\r\n    Graph.prototype.getNonNeighbourhood = function (vertex) {\r\n        var neighbours = this.getNeighbourhood(vertex);\r\n        neighbours.push(vertex);\r\n        var answer = this.vertices.reduce(function (accum, next) {\r\n            return (neighbours.indexOf(next) >= 0) ?\r\n                accum : accum.concat(next);\r\n        }, []);\r\n        return answer;\r\n    };\r\n    /**\r\n     * Get vertex's degree\r\n     */\r\n    Graph.prototype.getVertexDegree = function (vertex) {\r\n        return this.edges.filter(function (e) { return (e.vertexOne === vertex) || (e.vertexTwo === vertex); }).length;\r\n    };\r\n    /**\r\n     * Get vertex with minimum degree\r\n     */\r\n    Graph.prototype.getVertexWithMinDegree = function () {\r\n        var _this = this;\r\n        return this.vertices.reduce(function (min, next) {\r\n            if (!min || _this.getVertexDegree(next) < _this.getVertexDegree(min))\r\n                return next;\r\n            return min;\r\n        }, null);\r\n    };\r\n    /**\r\n     * Checks if the graph is connected\r\n     */\r\n    Graph.prototype.isConnected = function (graph) {\r\n        var visited = [];\r\n        for (var p = 0; p < graph.vertices.length; p++) {\r\n            visited.push(false);\r\n        }\r\n        var arr = [];\r\n        var visitedVertices = 0;\r\n        function numOfVertex(graph, vertex) {\r\n            var num = 0;\r\n            for (var i = 0; i < graph.vertices.length; i++) {\r\n                if (vertex.name === graph.vertices[i].name) {\r\n                    num = i;\r\n                }\r\n            }\r\n            return num;\r\n        }\r\n        function dfs(d) {\r\n            visitedVertices = 1;\r\n            visited[numOfVertex(graph, d)] = true;\r\n            arr = d.arrOfAdjacentVertices(graph);\r\n            for (var k = 0; k < arr.length; k++) {\r\n                if (!visited[numOfVertex(graph, arr[k])]) {\r\n                    visitedVertices = visitedVertices + dfs(arr[k]);\r\n                }\r\n            }\r\n            return visitedVertices;\r\n        }\r\n        return (dfs(graph.vertices[0]) === graph.vertices.length);\r\n    };\r\n    return Graph;\r\n}());\r\nexports.Graph = Graph;\r\n//# sourceMappingURL=Graph.js.map"]},"metadata":{},"sourceType":"script"}