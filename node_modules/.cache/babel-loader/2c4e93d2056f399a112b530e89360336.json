{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DirectedGraph_1 = require(\"../main/DirectedGraph\");\n\nvar UndirectedGraph_1 = require(\"../main/UndirectedGraph\");\n\nvar MatrixOperations_1 = require(\"../helpers/MatrixOperations\");\n/**\r\n * @classdesc\r\n * Finder of SCC\r\n */\n\n\nvar SccBuilder =\n/** @class */\nfunction () {\n  function SccBuilder(graph) {\n    this._graph = graph;\n    this._vertices = this._graph.vertices;\n    this._accessibilityMatrix = SccBuilder.buildAccessibilityMatrix(graph);\n  }\n  /**\r\n   * Finds strongly connected components\r\n   * @param graph\r\n   * @returns {IGraph[]}\r\n   */\n\n\n  SccBuilder.findComponents = function (graph) {\n    return new SccBuilder(graph).buildComponents();\n  };\n\n  SccBuilder.buildAdjacencyMatrix = function (graph) {\n    var result = [];\n\n    for (var i = 0; i < graph.vertices.length; i++) {\n      result[i] = [];\n\n      for (var j = 0; j < graph.vertices.length; j++) {\n        if (i == j) {\n          result[i][j] = 1;\n          continue;\n        }\n\n        if (graph.vertices[j].isAdjacent(graph, graph.vertices[i])) {\n          result[i][j] = 1;\n          continue;\n        }\n\n        result[i][j] = 0;\n      }\n    }\n\n    return result;\n  };\n\n  SccBuilder.buildAccessibilityMatrix = function (graph) {\n    var result = [];\n    var diagonal = [];\n\n    for (var i = 0; i < graph.vertices.length; i++) {\n      result[i] = [];\n      diagonal[i] = [];\n\n      for (var j = 0; j < graph.vertices.length; j++) {\n        if (i == j) {\n          diagonal[i][j] = 1;\n          continue;\n        }\n\n        if (graph.vertices[j].isAdjacent(graph, graph.vertices[i])) {\n          result[i][j] = 1;\n          continue;\n        }\n\n        result[i][j] = 0;\n      }\n    }\n\n    for (var i = 0; i < graph.vertices.length; i++) {\n      result = MatrixOperations_1.MatrixOperations.Sum(result, MatrixOperations_1.MatrixOperations.Power(result, i));\n    }\n\n    result = MatrixOperations_1.MatrixOperations.Sum(result, diagonal);\n    return result;\n  }; //TODO: кажется, тут местами можно немного проще сделать\n\n\n  SccBuilder.prototype.buildComponents = function () {\n    var s = [];\n\n    for (var i = 0; i < this._graph.vertices.length; i++) {\n      s[i] = [];\n\n      for (var j = 0; j < this._graph.vertices.length; j++) s[i][j] = this._accessibilityMatrix[i][j] * this._accessibilityMatrix[j][i];\n    }\n\n    var added = new Array(this._graph.vertices.length);\n\n    for (var i = 0; i < added.length; i++) added[i] = false;\n\n    var components = [];\n\n    for (var i = 0; i < this._graph.vertices.length; i++) {\n      if (added[i]) continue;\n      var scc = this._graph.isDirected ? new DirectedGraph_1.DirectedGraph() : new UndirectedGraph_1.UndirectedGraph(); // const scc: IGraph<IVertex, IEdge> = new Graph<Vertex,UndirectedEdge>();\n\n      added[i] = true;\n      scc.addVertex(this._vertices[i]);\n\n      for (var j = 0; j < this._graph.vertices.length; j++) if (!added[j] && s[i][j] == 1) {\n        added[j] = true;\n        scc.addVertex(this._vertices[j]);\n      }\n\n      components.push(scc);\n    }\n\n    this._graph.edges.forEach(function (edge) {\n      var whereToAdd = components.filter(function (c) {\n        return c.vertices.indexOf(edge.vertexOne) != -1 && c.vertices.indexOf(edge.vertexTwo) != -1;\n      });\n      whereToAdd.forEach(function (c) {\n        return c.addEdge(edge);\n      });\n    });\n\n    return components;\n  };\n\n  return SccBuilder;\n}();\n\nexports.SccBuilder = SccBuilder;","map":{"version":3,"sources":["../../src/algorithms/SccBuilder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DirectedGraph_1 = require(\"../main/DirectedGraph\");\r\nvar UndirectedGraph_1 = require(\"../main/UndirectedGraph\");\r\nvar MatrixOperations_1 = require(\"../helpers/MatrixOperations\");\r\n/**\r\n * @classdesc\r\n * Finder of SCC\r\n */\r\nvar SccBuilder = /** @class */ (function () {\r\n    function SccBuilder(graph) {\r\n        this._graph = graph;\r\n        this._vertices = this._graph.vertices;\r\n        this._accessibilityMatrix = SccBuilder.buildAccessibilityMatrix(graph);\r\n    }\r\n    /**\r\n     * Finds strongly connected components\r\n     * @param graph\r\n     * @returns {IGraph[]}\r\n     */\r\n    SccBuilder.findComponents = function (graph) {\r\n        return (new SccBuilder(graph)).buildComponents();\r\n    };\r\n    SccBuilder.buildAdjacencyMatrix = function (graph) {\r\n        var result = [];\r\n        for (var i = 0; i < graph.vertices.length; i++) {\r\n            result[i] = [];\r\n            for (var j = 0; j < graph.vertices.length; j++) {\r\n                if (i == j) {\r\n                    result[i][j] = 1;\r\n                    continue;\r\n                }\r\n                if (graph.vertices[j].isAdjacent(graph, graph.vertices[i])) {\r\n                    result[i][j] = 1;\r\n                    continue;\r\n                }\r\n                result[i][j] = 0;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    SccBuilder.buildAccessibilityMatrix = function (graph) {\r\n        var result = [];\r\n        var diagonal = [];\r\n        for (var i = 0; i < graph.vertices.length; i++) {\r\n            result[i] = [];\r\n            diagonal[i] = [];\r\n            for (var j = 0; j < graph.vertices.length; j++) {\r\n                if (i == j) {\r\n                    diagonal[i][j] = 1;\r\n                    continue;\r\n                }\r\n                if (graph.vertices[j].isAdjacent(graph, graph.vertices[i])) {\r\n                    result[i][j] = 1;\r\n                    continue;\r\n                }\r\n                result[i][j] = 0;\r\n            }\r\n        }\r\n        for (var i = 0; i < graph.vertices.length; i++) {\r\n            result = MatrixOperations_1.MatrixOperations.Sum(result, MatrixOperations_1.MatrixOperations.Power(result, i));\r\n        }\r\n        result = MatrixOperations_1.MatrixOperations.Sum(result, diagonal);\r\n        return result;\r\n    };\r\n    //TODO: кажется, тут местами можно немного проще сделать\r\n    SccBuilder.prototype.buildComponents = function () {\r\n        var s = [];\r\n        for (var i = 0; i < this._graph.vertices.length; i++) {\r\n            s[i] = [];\r\n            for (var j = 0; j < this._graph.vertices.length; j++)\r\n                s[i][j] = this._accessibilityMatrix[i][j] * this._accessibilityMatrix[j][i];\r\n        }\r\n        var added = new Array(this._graph.vertices.length);\r\n        for (var i = 0; i < added.length; i++)\r\n            added[i] = false;\r\n        var components = [];\r\n        for (var i = 0; i < this._graph.vertices.length; i++) {\r\n            if (added[i])\r\n                continue;\r\n            var scc = this._graph.isDirected\r\n                ? new DirectedGraph_1.DirectedGraph()\r\n                : new UndirectedGraph_1.UndirectedGraph();\r\n            // const scc: IGraph<IVertex, IEdge> = new Graph<Vertex,UndirectedEdge>();\r\n            added[i] = true;\r\n            scc.addVertex(this._vertices[i]);\r\n            for (var j = 0; j < this._graph.vertices.length; j++)\r\n                if (!added[j] && s[i][j] == 1) {\r\n                    added[j] = true;\r\n                    scc.addVertex(this._vertices[j]);\r\n                }\r\n            components.push(scc);\r\n        }\r\n        this._graph.edges.forEach(function (edge) {\r\n            var whereToAdd = components.filter(function (c) { return c.vertices.indexOf(edge.vertexOne) != -1 &&\r\n                c.vertices.indexOf(edge.vertexTwo) != -1; });\r\n            whereToAdd.forEach(function (c) { return c.addEdge(edge); });\r\n        });\r\n        return components;\r\n    };\r\n    return SccBuilder;\r\n}());\r\nexports.SccBuilder = SccBuilder;\r\n//# sourceMappingURL=SccBuilder.js.map"]},"metadata":{},"sourceType":"script"}