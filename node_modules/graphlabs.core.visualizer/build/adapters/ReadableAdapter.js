"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var d3_selection_1 = require("d3-selection");
var d3 = require("d3");
var graphlabs_core_graphs_1 = require("graphlabs.core.graphs");
var __1 = require("..");
var react_1 = require("react");
var ReadableAdapter = /** @class */ (function (_super) {
    __extends(ReadableAdapter, _super);
    function ReadableAdapter(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            events: []
        };
        _this.updateGraph = _this.updateGraph.bind(_this);
        _this.vertexOne = new graphlabs_core_graphs_1.Vertex('');
        _this.vertexTwo = new graphlabs_core_graphs_1.Vertex('');
        return _this;
    }
    ReadableAdapter.prototype.addVertex = function () {
    };
    ReadableAdapter.prototype.addEdge = function () {
    };
    ReadableAdapter.prototype.removeVertex = function () {
    };
    ReadableAdapter.prototype.removeEdge = function () {
    };
    ReadableAdapter.prototype.renderSvg = function () {
        console.log(this.graphVisualizer);
        this.graphVisualizer.width = this.ref.getBoundingClientRect().width;
        this.graphVisualizer.height = this.ref.getBoundingClientRect().height;
        this.graphVisualizer.calculate();
        for (var _i = 0, _a = this.graphVisualizer.geometric.edges; _i < _a.length; _i++) {
            var elem = _a[_i];
            this.addEdgeToSVG(elem);
        }
        for (var _b = 0, _c = this.graphVisualizer.geometric.vertices; _b < _c.length; _b++) {
            var elem = _c[_b];
            this.addVertexToSVG(elem);
        }
    };
    ReadableAdapter.prototype.addEdgeToSVG = function (elem) {
        console.log(this.graphVisualizer);
        var data = [{ x: elem.outPoint.X, y: elem.outPoint.Y }, { x: elem.inPoint.X, y: elem.inPoint.Y }];
        d3_selection_1.select(this.ref)
            .append('line')
            .datum([this.vertexOne, this.vertexTwo])
            .attr('id', "edge_" + elem.edge.vertexOne.name + "_" + elem.edge.vertexTwo.name)
            .attr('out', elem.edge.vertexOne.name)
            .attr('in', elem.edge.vertexTwo.name)
            .attr('graph-id', this.graphVisualizer.geometric.graphId)
            .attr('label', elem.label)
            .attr('x1', data[0].x)
            .attr('x2', data[1].x)
            .attr('y1', data[0].y)
            .attr('y2', data[1].y)
            .style('stroke', 'black')
            .style('stroke-width', 5)
            .style('fill', 'none')
            .on('click', clickEdge);
        if (this.props.namedEdges == true) {
            d3_selection_1.select(this.ref)
                .append('text')
                .attr('id', "label2_" + elem.label)
                .attr('x', (data[0].x + data[1].x) / 2)
                .attr('y', ((data[0].y + data[1].y) / 2) + 15)
                .text(elem.label)
                .style('fill', '#000')
                .style('font-size', '14px')
                .style('font-family', 'sans-serif')
                .style('text-anchor', 'middle');
        }
        if (this.props.weightedEdges == true) {
            d3_selection_1.select(this.ref)
                .append('text')
                .attr('id', "label2_" + elem.label)
                .attr('x', (data[0].x + data[1].x) / 2)
                .attr('y', ((data[0].y + data[1].y) / 2) + 15)
                .text(elem.weightLabel)
                .style('fill', '#000')
                .style('font-size', '16px')
                .style('font-family', 'sans-serif')
                .style('text-anchor', 'middle');
        }
        function clickEdge(dataArr) {
            dataArr[0].rename(this.getAttribute("out"));
            dataArr[1].rename(this.getAttribute("in"));
            sessionStorage.setItem("out", this.getAttribute("out"));
            sessionStorage.setItem("in", this.getAttribute("in"));
            var elemColour = d3_selection_1.select(this).style("stroke");
            if (elemColour === 'black') {
                d3_selection_1.select(this)
                    .style('stroke', 'green');
            }
            else {
                d3_selection_1.select(this)
                    .style('stroke', 'black');
            }
        }
    };
    ReadableAdapter.prototype.addVertexToSVG = function (elem) {
        console.log(this.graphVisualizer);
        var createVertex = d3_selection_1.select(this.ref)
            .append('circle')
            .datum([this.vertexOne, this.vertexTwo])
            .attr('id', "vertex_" + elem.label)
            .attr('graph-id', this.graphVisualizer.geometric.graphId)
            .attr('cx', elem.center.X)
            .attr('cy', elem.center.Y)
            .attr('label', elem.label)
            .attr('r', elem.radius)
            .attr('wave', elem.wave)
            .style('fill', '#eee')
            .style('stroke', '#000')
            .style('stroke-width', 5);
        if (this.props.incidentEdges == true) {
            createVertex
                .on('click', clickIncidentEdge);
        }
        else {
            createVertex
                .on('click', clickVertex);
        }
        if (this.props.withoutDragging !== true) {
            createVertex
                .classed('dragging', true)
                .call(d3.drag().on('start', startDrag));
        }
        d3_selection_1.select(this.ref)
            .append('text')
            .attr('id', "label_" + elem.label)
            .attr('x', elem.center.X)
            .attr('y', elem.center.Y + elem.radius / 4)
            .attr('font-size', elem.radius)
            .text(elem.label)
            .style('fill', '#000')
            .style('font-family', 'sans-serif')
            .style('text-anchor', 'middle')
            .style('padding-top', '50%')
            .style('padding-left', '25%')
            .style('padding-right', '25%')
            .style('user-select', 'none')
            .style('pointer-events', 'none');
        var referrer = this.ref;
        var isNamedEdges = this.props.namedEdges;
        var myGraph = this.graphVisualizer.geometric.graph;
        function startDrag() {
            var circle = d3.select(this).classed('dragging', true);
            d3.event.on('drag', dragged).on('end', ended);
            var radius = parseFloat(circle.attr('r'));
            function dragged(d) {
                if (d3.event.x < referrer.getBoundingClientRect().width - radius
                    && d3.event.x > radius
                    && d3.event.y < referrer.getBoundingClientRect().height - radius
                    && d3.event.y > radius) {
                    circle.raise().attr('cx', d3.event.x).attr('cy', d3.event.y);
                    var name_1 = circle.attr('id');
                    var _id = name_1.substring(7);
                    var graphId_1 = circle.attr('graph-id');
                    console.log('graphid' + graphId_1);
                    d3_selection_1.select("#label_" + _id)
                        .raise()
                        .attr('x', d3.event.x)
                        .attr('y', d3.event.y + +circle.attr('r') / 4);
                    d3.selectAll('line').each(function (l, li) {
                        if ("vertex_" + d3.select(this).attr('out') === name_1 && d3.select(this).attr('graph-id') === graphId_1) {
                            console.log('graphid2' + d3.select(this).attr('graph-id'));
                            d3_selection_1.select(this)
                                .attr('x1', d3.event.x)
                                .attr('y1', d3.event.y);
                            if (isNamedEdges == true) {
                                d3_selection_1.select("#label2_" + d3.select(this).attr('label'))
                                    .attr('x', (d3.event.x + Number(d3.select(this).attr('x2'))) / 2)
                                    .attr('y', ((d3.event.y + Number(d3.select(this).attr('y2'))) / 2) + 15);
                            }
                        }
                        if ("vertex_" + d3.select(this).attr('in') === name_1 && d3.select(this).attr('graph-id') === graphId_1) {
                            d3_selection_1.select(this)
                                .attr('x2', d3.event.x)
                                .attr('y2', d3.event.y);
                            if (isNamedEdges == true) {
                                d3_selection_1.select("#label2_" + d3.select(this).attr('label'))
                                    .attr('x', (d3.event.x + Number(d3.select(this).attr('x1'))) / 2)
                                    .attr('y', ((d3.event.y + Number(d3.select(this).attr('y1'))) / 2) + 15);
                            }
                        }
                    });
                }
                //     console.log("ATTENTION!!!");
                // }
            }
            function ended() {
                circle.classed('dragging', false);
            }
        }
        function clickIncidentEdge(dataArr) {
            var arr_one = [];
            var arr_two = [];
            var waveAttr = d3_selection_1.select(this).attr('wave');
            var vertexColour = d3_selection_1.select(this).style("fill");
            if (vertexColour === 'rgb(238, 238, 238)') {
                d3_selection_1.select(this)
                    .style('fill', '#ff0000');
                //select<SVGTextElement,{}>(`#label_${this.getAttribute('label')}`)
                // .text(this.getAttribute('label')+'(' + this.getAttribute('wave') + ')');
                if (dataArr[0].name == '') {
                    dataArr[0].rename(this.getAttribute('label'));
                    arr_one = dataArr[0].arrOfIncidentEdges(myGraph);
                    d3.selectAll('line').each(function (l, li) {
                        for (var i = 0; i < arr_one.length; i++) {
                            if (d3.select(this).attr('in') == arr_one[i].vertexOne.name &&
                                d3.select(this).attr('out') == arr_one[i].vertexTwo.name ||
                                d3.select(this).attr('out') == arr_one[i].vertexOne.name
                                    && d3.select(this).attr('in') == arr_one[i].vertexTwo.name) {
                                d3_selection_1.select(this).style("stroke", 'green');
                            }
                        }
                    });
                }
                else if (dataArr[1].name == '') {
                    dataArr[1].rename(this.getAttribute('label'));
                    arr_two = dataArr[1].arrOfIncidentEdges(myGraph);
                    d3.selectAll('line').each(function (l, li) {
                        for (var i = 0; i < arr_two.length; i++) {
                            if (d3.select(this).attr('in') == arr_two[i].vertexOne.name &&
                                d3.select(this).attr('out') == arr_two[i].vertexTwo.name ||
                                d3.select(this).attr('out') == arr_two[i].vertexOne.name
                                    && d3.select(this).attr('in') == arr_two[i].vertexTwo.name) {
                                d3_selection_1.select(this).style("stroke", 'green');
                            }
                        }
                    });
                }
                else if (dataArr[0].name !== '' && dataArr[1].name !== '') {
                    dataArr[1].rename('');
                    dataArr[0].rename(this.getAttribute('label'));
                    arr_one = dataArr[0].arrOfIncidentEdges(myGraph);
                    d3.selectAll('line').each(function (l, li) {
                        for (var i = 0; i < arr_one.length; i++) {
                            if (d3.select(this).attr('in') == arr_one[i].vertexOne.name &&
                                d3.select(this).attr('out') == arr_one[i].vertexTwo.name ||
                                d3.select(this).attr('out') == arr_one[i].vertexOne.name
                                    && d3.select(this).attr('in') == arr_one[i].vertexTwo.name) {
                                d3_selection_1.select(this).style("stroke", 'green');
                            }
                        }
                    });
                }
            }
            if (vertexColour === 'rgb(255, 0, 0)') {
                var arr = [];
                var data = void 0;
                for (var l = 0; l < myGraph.vertices.length; l++) {
                    if (this.getAttribute('label') === myGraph.vertices[l].name) {
                        data = myGraph.vertices[l];
                    }
                }
                arr = data.arrOfAdjacentVertices(myGraph);
                for (var k = 0; k < arr.length; k++) {
                    if (+this.getAttribute('wave') === +arr[k].wave + 1) {
                        d3_selection_1.select(this)
                            .style('fill', 'blue');
                        d3_selection_1.select("#edge_" + arr[k].name + "_" + this.getAttribute('label'))
                            .style('stroke', 'red');
                        d3_selection_1.select("#edge_" + this.getAttribute('label') + "_" + arr[k].name)
                            .style('stroke', 'red');
                    }
                    else if (this.getAttribute('wave') === '0') {
                        d3_selection_1.select(this).style('fill', 'blue');
                    } //окраска стартовой верширы!
                }
            }
        }
        function clickVertex(dataArr) {
            var elemColour = d3_selection_1.select(this).style("fill");
            if (elemColour === 'rgb(255, 0, 0)') {
                d3_selection_1.select(this)
                    .style('fill', '#eee');
                if (this.getAttribute('label') == dataArr[0].name) {
                    dataArr[0].rename('');
                }
                else if (this.getAttribute('label') == dataArr[1].name) {
                    dataArr[1].rename('');
                }
            }
            else {
                console.log(dataArr[1]);
                d3_selection_1.select(this)
                    .style('fill', '#ff0000');
                if (dataArr[0].name == '') {
                    dataArr[0].rename(this.getAttribute('label'));
                }
                else if (dataArr[1].name == '') {
                    dataArr[1].rename(this.getAttribute('label'));
                }
                else if (dataArr[0].name !== '' && dataArr[1].name !== '') {
                    dataArr[1].rename('');
                    dataArr[0].rename(this.getAttribute('label'));
                }
            }
        }
    };
    ReadableAdapter.prototype.removeVertexFromSVG = function (elem) {
        console.log(this.graphVisualizer);
        d3_selection_1.select("#vertex_" + elem.label)
            .remove();
        d3_selection_1.select("#label_" + elem.label)
            .remove();
    };
    ReadableAdapter.prototype.removeEdgeFromSVG = function (elem) {
        console.log(this.graphVisualizer);
        d3_selection_1.select("#edge_" + elem.edge.vertexOne.name + "_" + elem.edge.vertexTwo.name)
            .remove();
        d3_selection_1.select("#label2_" + elem.label)
            .remove();
    };
    ReadableAdapter.prototype.updateSvg = function () {
        console.log(this.vertexOne);
        console.log(this.vertexTwo);
        this.graphVisualizer.width = this.ref.getBoundingClientRect().width;
        this.graphVisualizer.height = this.ref.getBoundingClientRect().height;
        this.graphVisualizer.calculate();
        for (var _i = 0, _a = this.graphVisualizer.geometric.vertices; _i < _a.length; _i++) {
            var elem = _a[_i];
            d3_selection_1.select("#vertex_" + elem.label)
                .attr('cx', elem.center.X)
                .attr('cy', elem.center.Y)
                .attr('r', elem.radius)
                .style('fill', '#eee');
            d3_selection_1.select("#label_" + elem.label)
                .attr('x', elem.center.X)
                .attr('y', elem.center.Y + elem.radius / 4)
                .attr('font-size', elem.radius);
        }
        for (var _b = 0, _c = this.graphVisualizer.geometric.edges; _b < _c.length; _b++) {
            var elem = _c[_b];
            d3_selection_1.select("#edge_" + elem.edge.vertexOne.name + "_" + elem.edge.vertexTwo.name)
                .attr('x1', elem.outPoint.X)
                .attr('x2', elem.inPoint.X)
                .attr('y1', elem.outPoint.Y)
                .attr('y2', elem.inPoint.Y);
            if (this.props.namedEdges == true) {
                d3_selection_1.select("#label2_" + elem.label)
                    .attr('x', (elem.outPoint.X + elem.inPoint.X) / 2)
                    .attr('y', ((elem.outPoint.Y + elem.inPoint.Y) / 2) + 15);
            }
        }
    };
    ReadableAdapter.prototype.componentDidMount = function () {
        this.graphVisualizer = new __1.CircleGraphVisualizer(this.props.graph);
        this.renderSvg();
        window.onresize = this.updateSvg.bind(this);
    };
    ReadableAdapter.prototype.updateGraph = function () {
        // tslint:disable-next-line no-console
        console.log('Here I am!');
    };
    ReadableAdapter.prototype.render = function () {
        var _this = this;
        return (React.createElement("svg", { style: { width: '100%', height: '100%' }, ref: function (ref) { return _this.ref = ref; } }));
    };
    return ReadableAdapter;
}(react_1.Component));
exports.ReadableAdapter = ReadableAdapter;
//# sourceMappingURL=ReadableAdapter.js.map