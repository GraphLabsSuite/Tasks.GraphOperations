"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Vertex_1 = require("./Vertex");
var IsomorphismChecker_1 = require("../algorithms/IsomorphismChecker");
var Edge_1 = require("./Edge");
/** @classdesc
 * Graph implementation of the IGraph interface */
var Graph = /** @class */ (function () {
    /**
     * @constructor
     */
    function Graph(directed) {
        this._vertices = [];
        this._edges = [];
        this._isDirected = directed == null ? false : directed;
    }
    Object.defineProperty(Graph.prototype, "isDirected", {
        /** @property
         *  @public
         *  Getter for _isDirected field
         *  @returns {boolean}
         *  */
        get: function () {
            return this._isDirected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Graph.prototype, "allowMultipleEdges", {
        /** @property
         *  @public
         *  Getter for _allowMultipleEdges field
         *  @returns {boolean}
         */
        get: function () {
            return this._allowMultipleEdges;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Graph.prototype, "vertices", {
        /**
         * @property
         * @public
         * Getter for _vertices field
         * @return {T[]}
         */
        get: function () {
            return this._vertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Graph.prototype, "edges", {
        /**
         * @property
         * @public
         * Getter for _edges field
         * @return {K[]}
         */
        get: function () {
            return this._edges;
        },
        enumerable: true,
        configurable: true
    });
    Graph.prototype.clear = function () {
        this._vertices = [];
        this._edges = [];
    };
    /**
     * Adds the edge to the graph
     * @param edge
     */
    Graph.prototype.addEdge = function (edge) {
        this.edges.push(edge);
    };
    /**
     * Removes the edge from the graph
     * @param edge
     */
    Graph.prototype.removeEdge = function (edge) {
        var _this = this;
        var edges = [];
        var edgeOut = null;
        do {
            edgeOut = this.edges.pop();
            edges.push(edgeOut);
        } while (edgeOut === undefined || !edgeOut.equals(edge));
        edges.forEach(function (e) {
            if (!e.equals(edgeOut))
                _this.edges.push(e);
        });
    };
    /**
     * Gets the edge between the two vertices incident to it
     * @param vertexOne
     * @param vertexTwo
     */
    Graph.prototype.getEdge = function (vertexOne, vertexTwo) {
        var result = [];
        this.edges.forEach(function (edge) {
            if (edge.vertexOne == vertexOne && edge.vertexTwo == vertexTwo)
                result.push(edge);
        });
        return result;
    };
    /**
     * Get the vertex by its name
     * @param name
     * @returns {T[]}
     */
    Graph.prototype.getVertex = function (name) {
        var verticesOut = [];
        for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
            var v = _a[_i];
            if (v.name == name)
                verticesOut.push(v);
        }
        return verticesOut;
    };
    /**
     * Adds the vertex to the graph
     * @param vertex
     */
    Graph.prototype.addVertex = function (vertex) {
        this.vertices.push(vertex);
    };
    /**
     * Removes the vertex from the graph
     * @param vertex
     */
    Graph.prototype.removeVertex = function (vertex) {
        var _this = this;
        var vertices = [];
        var vertexOut = null;
        if (this._vertices.length > 0) {
            do {
                vertexOut = this._vertices.pop();
                vertices.push(vertexOut);
            } while (vertexOut === undefined || !vertexOut.equals(vertex));
            vertices.forEach(function (v) {
                if (!v.equals(vertexOut)) {
                    _this.vertices.push(v);
                }
            });
        }
        this._edges.forEach(function (e) {
            if (e.isIncident(vertex)) {
                _this.removeEdge(e);
            }
        });
    };
    /**
     * Returns the result of union operation for N graphs
     * @param graphs
     * @returns {Graph<T,K>}
     */
    Graph.unionN = function (graphs) {
        if (graphs.length < 2)
            return Graph.createEmpty(0);
        //TODO: Think about contracts or asserts
        var copies = graphs.map(function (g) { return g.clone(); });
        var result = copies[0];
        for (var i = 1; i < copies.length; i++) {
            copies[i].vertices.forEach(function (v) { return result.addVertex(v); });
            copies[i].edges.forEach(function (e) { return result.addEdge(e); });
        }
        return result;
    };
    /**
     * Returns the result of intersect operation for N graphs
     * @param graphs
     * @returns {IGraph<T,K>}
     */
    Graph.intersectN = function (graphs) {
        if (graphs.length < 2)
            return Graph.createEmpty(0);
        //TODO: Think about contracts or asserts
        var copies = graphs.map(function (g) { return g.clone(); });
        var result = copies[0];
        for (var i = 1; i < copies.length; i++) {
            copies[i].vertices.forEach(function (v) { return result.removeVertex(v); });
            copies[i].edges.forEach(function (e) { return result.removeEdge(e); });
        }
        return result;
    };
    /**
     * @static
     * Static builder for the directed weighted graph
     * @param verticesNumber
     * @return {DirectedWeightedGraph}
     */
    Graph.createEmpty = function (verticesNumber) {
        var newGraph = new Graph();
        for (var i = 0; i < verticesNumber; ++i)
            newGraph.addVertex(new Vertex_1.Vertex(i.toString(verticesNumber)));
        return newGraph;
    };
    /**
     * Returns the result of union operation
     * @param graph
     * @returns {Graph<T, K>}
     */
    Graph.prototype.union = function (graph) {
        //TODO: Think about contracts or asserts
        return Graph.unionN([this, graph]);
    };
    /**
     * Returns the result of intersect operation
     * @param graph
     * @returns {IGraph}
     */
    Graph.prototype.intersect = function (graph) {
        return Graph.intersectN([this, graph]);
    };
    /**
     * Returns a complement graph to the given one
     * @returns {IGraph}
     */
    Graph.prototype.complement = function () {
        return Graph.createEmpty(0); //TODO: implementation
    };
    /**
     * Checks if the second graph is isomorphic to the given one
     * @param graph
     * @returns {boolean}
     */
    Graph.prototype.checkIsomorphism = function (graph) {
        return IsomorphismChecker_1.IsomorphismChecker.checkIsomorphism(this, graph);
    };
    /**
     * Returns strongly connected components of the given graph
     * @returns {IGraph[]}
     */
    Graph.prototype.buildSCC = function () {
        //TODO: fix the bug with TypeError: Object prototype may only be an Object or null: undefined
        return [];
    };
    Graph.prototype.print = function () {
        // @ts-ignore
        console.log(this.toString());
    };
    Graph.prototype.toString = function () {
        var verticesListStr = '[' + this.vertices.join(',') + ']';
        if (verticesListStr.length == 0)
            verticesListStr = "\u2205";
        var edgesListStr = "";
        this.edges.forEach(function (g) { return edgesListStr = edgesListStr + ("{" + g.vertexOne + "," + g.vertexTwo + "}"); });
        edgesListStr = (edgesListStr.length == 0) ? "\u2205" : "[" + edgesListStr + "]";
        return "(" + verticesListStr + "," + edgesListStr + ")";
    };
    /**
     * Deep graph-cloning
     */
    Graph.prototype.clone = function () {
        var clone = new Graph();
        this.vertices.forEach(function (v) { return clone.addVertex(v.clone()); });
        var _loop_1 = function (edge) {
            var v1 = clone.vertices.filter(function (v) { return edge.vertexOne.equals(v); })[0]; //Single?
            var v2 = clone.vertices.filter(function (v) { return edge.vertexTwo.equals(v); })[0];
            clone.addEdge(new Edge_1.Edge(v1, v2));
        };
        for (var _i = 0, _a = this.edges; _i < _a.length; _i++) {
            var edge = _a[_i];
            _loop_1(edge);
        }
        return clone;
    };
    /**
     * Get subgraph of graph
     * input: vertives
     */
    Graph.prototype.getSubgraph = function (subVertices) {
        var subGraph = new Graph();
        subVertices.forEach(function (v) {
            subGraph.addVertex(v.clone());
        });
        this.edges.filter(function (e) {
            return (subVertices.indexOf(e.vertexOne) >= 0)
                && (subVertices.indexOf(e.vertexTwo) >= 0);
        }).forEach(function (e) { return subGraph.addEdge(new Edge_1.Edge(e.vertexOne, e.vertexTwo)); });
        return subGraph;
    };
    /**
     * Get neighbourhood
     */
    Graph.prototype.getNeighbourhood = function (vertex) {
        var _this = this;
        var neighbourhood = [];
        this.vertices.forEach(function (v) { return neighbourhood.push(v.clone()); });
        return neighbourhood.reduce(function (accum, next) {
            _this.edges.forEach(function (e) {
                if (e.vertexOne === vertex)
                    accum.push(e.vertexTwo);
                if (e.vertexTwo === vertex)
                    accum.push(e.vertexOne);
            });
            return accum;
        }, []);
    };
    /**
     * Get non-neighbourhood
     */
    Graph.prototype.getNonNeighbourhood = function (vertex) {
        var neighbours = this.getNeighbourhood(vertex);
        neighbours.push(vertex);
        var answer = this.vertices.reduce(function (accum, next) {
            return (neighbours.indexOf(next) >= 0) ?
                accum : accum.concat(next);
        }, []);
        return answer;
    };
    /**
     * Get vertex's degree
     */
    Graph.prototype.getVertexDegree = function (vertex) {
        return this.edges.filter(function (e) { return (e.vertexOne === vertex) || (e.vertexTwo === vertex); }).length;
    };
    /**
     * Get vertex with minimum degree
     */
    Graph.prototype.getVertexWithMinDegree = function () {
        var _this = this;
        return this.vertices.reduce(function (min, next) {
            if (!min || _this.getVertexDegree(next) < _this.getVertexDegree(min))
                return next;
            return min;
        }, null);
    };
    /**
     * Checks if the graph is connected
     */
    Graph.prototype.isConnected = function (graph) {
        var visited = [];
        for (var p = 0; p < graph.vertices.length; p++) {
            visited.push(false);
        }
        var arr = [];
        var visitedVertices = 0;
        function numOfVertex(graph, vertex) {
            var num = 0;
            for (var i = 0; i < graph.vertices.length; i++) {
                if (vertex.name === graph.vertices[i].name) {
                    num = i;
                }
            }
            return num;
        }
        function dfs(d) {
            visitedVertices = 1;
            visited[numOfVertex(graph, d)] = true;
            arr = d.arrOfAdjacentVertices(graph);
            for (var k = 0; k < arr.length; k++) {
                if (!visited[numOfVertex(graph, arr[k])]) {
                    visitedVertices = visitedVertices + dfs(arr[k]);
                }
            }
            return visitedVertices;
        }
        return (dfs(graph.vertices[0]) === graph.vertices.length);
    };
    return Graph;
}());
exports.Graph = Graph;
//# sourceMappingURL=Graph.js.map