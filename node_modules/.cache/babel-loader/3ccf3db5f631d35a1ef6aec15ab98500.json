{"ast":null,"code":"import './App.css';\nimport { Template, store, init } from \"graphlabs.core.template\";\nimport { Vertex, Edge, GraphGenerator } from \"graphlabs.core.graphs\";\nimport 'graphlabs.core.template/dist/main.css';\nimport { init1, graphModel1, init2, graphModel2, initres } from './ForMyGraphModel';\n\nclass App extends Template {\n  constructor(...args) {\n    super(...args);\n    this.message_0 = \"\";\n    this.num_0 = 0;\n    this.state = {\n      status: store.getState().app.status\n    };\n  }\n\n  componentWillMount() {\n    let graph;\n    graph = GraphGenerator.generate(0);\n    init(graph);\n    let graph1;\n    graph1 = this.GetNewRandomGraph(5);\n    init1(graph1);\n    let graph2;\n    graph2 = this.GetNewRandomGraphForThatOne(5, graph1);\n    init2(graph2);\n    let graphres = this.ChooseTask();\n    initres(graphres); //this.scc_count = SccBuilder.findComponents(graphres).length;\n  } //Для меня в будующем: проблема невозможности удать ребро заключается в том, что я создаю два других, тем саммы ломая себе всё.\n  //Это нужно проверить и внести определённые правки. Также нужно узнать как мой модуль добавить на сайт, а не только на гитхаб.\n\n\n  ChooseTask() {\n    this.num_0 = Math.round(Math.random() * 100) % 7;\n\n    switch (this.num_0) {\n      case 0:\n        this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n        return this.Uni(graphModel1, graphModel2);\n\n      case 1:\n        this.message_0 = \"Постройте граф, являющийся результатом соединения двух графов.\";\n        return this.Joint(graphModel1, graphModel2);\n\n      case 2:\n        this.message_0 = \"Постройте граф, являющийся результатом произведения двух графов.\";\n        return this.Product(graphModel1, graphModel2);\n\n      case 3:\n        this.message_0 = \"Постройте граф, являющийся результатом композиции двух графов.\";\n        return this.Composition(graphModel1, graphModel2);\n\n      case 4:\n        this.message_0 = \"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\"; // Объединение по Зыкову\n\n        return this.Uni_Z(graphModel1, graphModel2);\n\n      case 5:\n        this.message_0 = \"Постройте граф, являющийся результатом пересечения двух графов.\"; // Пересечение\n\n        return this.Cross(graphModel1, graphModel2);\n\n      case 6:\n        this.message_0 = \"Постройте граф, являющийся дополнением графа.\"; // Дополнение\n\n        return this.Addition(graphModel1);\n\n      case 7:\n        this.message_0 = \"Постройте граф, являющийся результатом декартового произведения двух графов.\"; // Декартово произведение\n\n        return this.Cartesian_Product(graphModel1, graphModel2);\n\n      default:\n        this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n        return this.Uni(graphModel1, graphModel2);\n    }\n  }\n\n  GetNewRandomGraph(num) {\n    // рандомный граф\n    let graph;\n    graph = GraphGenerator.generate(0);\n    var arr = [];\n\n    for (var i = 0; i < num; i++) {\n      arr.push(Math.round(Math.random()));\n\n      if (arr[i] === 1) {\n        let vert = new Vertex(`${i}`);\n        graph.addVertex(vert);\n      }\n    }\n\n    for (var i = 0; i < num - 1; i++) {\n      if (arr[i] === 1) {\n        for (var j = i + 1; j < num; j++) {\n          if (arr[j] === 1 && Math.random() > 0.45) {\n            // 55% chance what is edge i+j\n            let edge = new Edge(graph.getVertex(`${i}`)[0], graph.getVertex(`${j}`)[0], `${i}+${j}`);\n            graph.addEdge(edge);\n          }\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  GetNewRandomGraphForThatOne(num, graph1) {\n    // рандомный, не имеющий общих вершин с первым\n    let graph;\n    graph = GraphGenerator.generate(0);\n    var arr = [];\n    let length = graph1.vertices.length + 1;\n\n    for (var i = 0; i < num; i++) {\n      arr.push(Math.round(Math.random()));\n\n      if (arr[i] === 1) {\n        let vert = new Vertex(`${i + length}`);\n        graph.addVertex(vert);\n      }\n    }\n\n    for (var i = 0; i < num - 1; i++) {\n      if (arr[i] === 1) {\n        for (var j = i + 1; j < num; j++) {\n          if (arr[j] === 1 && Math.random() > 0.45) {\n            // 55% chance what is edge i+j\n            let edge = new Edge(graph.getVertex(`${i + length}`)[0], graph.getVertex(`${j + length}`)[0], `${i + length}+${j + length}`);\n            graph.addEdge(edge);\n          }\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  Uni(graph1, graph2) {\n    // объединение\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.vertices.forEach(v => {\n      if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n        // если нет таких же по имени вершин\n        graphres.addVertex(v);\n      }\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph1.edges.forEach(e => {\n      let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n      let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n      let e_new;\n      e_new = new Edge(vv1, vv2);\n      graphres.addEdge(e_new);\n    });\n    graph2.edges.forEach(e => {\n      let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n      let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n      let e_new;\n      e_new = new Edge(vv1, vv2);\n      graphres.addEdge(e_new);\n    });\n    return graphres;\n  }\n\n  Operation2(graph1, graph2) {\n    // соединение по  (это и есть простое соединение)\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.vertices.forEach(v => {\n      if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n        // если нет таких же по имени вершин\n        graphres.addVertex(v);\n        graph1.vertices.forEach(v1 => {\n          // дополнение к объединению\n          if (!(graphres.getEdge(v, v1).length > 0)) {\n            let e;\n            e = new Edge(v, v1);\n            graphres.addEdge(e);\n          }\n        });\n      }\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    return graphres;\n  }\n\n  Joint(graph1, graph2) {\n    // соединение !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n      graph2.vertices.forEach(v1 => {\n        if (!(graphres.getVertex(`${v1.name}`).length > 0)) graphres.addVertex(v1);\n        let e;\n        e = new Edge(v, v1);\n        graphres.addEdge(e);\n      });\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    return graphres;\n  }\n\n  Product(graph1, graph2) {\n    // Произведение !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graph2.vertices.forEach(v1 => {\n        let v_res;\n        v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n        graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n        //graphres.addVertex(v_res);\n      });\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        graph1.vertices.forEach(u1 => {\n          graph2.vertices.forEach(u2 => {\n            if (u1.name != v1.name || u2.name != v2.name) {\n              if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              } else if (u2.name === v2.name && v1.isAdjacent(graph1, u1)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              }\n            }\n          });\n        });\n      });\n    });\n    return graphres;\n  }\n\n  Composition(graph1, graph2) {\n    // Композиция !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graph2.vertices.forEach(v1 => {\n        let v_res;\n        v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n        graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n        //graphres.addVertex(v_res);\n      });\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        graph1.vertices.forEach(u1 => {\n          graph2.vertices.forEach(u2 => {\n            if (u1.name != v1.name || u2.name != v2.name) {\n              let e_0;\n              e_0 = new Edge(v1, v2);\n\n              if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n                //graph2.getEdge(v2,u2).length>0 ){\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              } else if (v1.isAdjacent(graph1, u1)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              }\n            }\n          });\n        });\n      });\n    });\n    return graphres;\n  }\n\n  Uni_Z(graph1, graph2) {\n    // объединение по Зыкову\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graphres.addVertex(v);\n    });\n    graph1.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph2.vertices.forEach(v => {\n      if (!(graphres.getVertex(`${v.name}`).length > 0)) {\n        // если нет таких же по имени вершин\n        graphres.addVertex(v);\n      }\n    });\n    graph2.edges.forEach(e => {\n      graphres.addEdge(e);\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        if (!graphres.getVertex(v1.name)[0].isAdjacent(graphres, graphres.getVertex(v2.name)[0])) {\n          let vv1 = graphres.getVertex(`${v1.name}`)[0];\n          let vv2 = graphres.getVertex(`${v2.name}`)[0];\n          let e;\n          e = new Edge(vv1, vv2);\n          graphres.addEdge(e);\n        }\n      });\n    });\n    return graphres;\n  }\n\n  Cross(graph1, graph2) {\n    // Пересечение\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        if (v1.name == v2.name) {\n          let v_res;\n          v_res = new Vertex(`${v1.name}`);\n          graphres.addVertex(v_res);\n        }\n      });\n    });\n    graph1.edges.forEach(u1 => {\n      graph2.edges.forEach(u2 => {\n        if (u1.vertexOne.name == u2.vertexOne.name && u1.vertexTwo.name == u2.vertexTwo.name || u1.vertexOne.name == u2.vertexTwo.name && u1.vertexTwo.name == u2.vertexOne.name) {\n          let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n          let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n          let e;\n          e = new Edge(v1[0], v2[0]);\n          graphres.addEdge(e);\n        }\n      });\n    });\n    return graphres;\n  }\n\n  Addition(graph1) {\n    // Дополнение\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v1 => {\n      let v_res;\n      v_res = new Vertex(`${v1.name}`);\n      graphres.addVertex(v_res);\n    });\n    graph1.vertices.forEach(v1 => {\n      graph1.vertices.forEach(v2 => {\n        let vv1 = v1.name;\n        let vv2 = v2.name;\n\n        if (v1.name != v2.name && !v1.isAdjacent(graph1, v2) && !graphres.getVertex(v1.name)[0].isAdjacent(graphres, graphres.getVertex(v2.name)[0])) {\n          let v1 = graphres.getVertex(`${vv1}`);\n          let v2 = graphres.getVertex(`${vv2}`);\n          let e;\n          e = new Edge(v1[0], v2[0]);\n          graphres.addEdge(e);\n        }\n      });\n    });\n    let graph2;\n    graph2 = this.GetNewRandomGraph(0);\n    init2(graph2);\n    return graphres;\n  }\n\n  Cartesian_Product(graph1, graph2) {\n    // Декартово произведение !!!!! без пересечения вершин !!!!!\n    let graphres;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v => {\n      graph2.vertices.forEach(v1 => {\n        let v_res;\n        v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n\n        graphres.addVertex(v_res); //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n        //graphres.addVertex(v_res);\n      });\n    });\n    graph1.vertices.forEach(v1 => {\n      graph2.vertices.forEach(v2 => {\n        graph1.vertices.forEach(u1 => {\n          graph2.vertices.forEach(u2 => {\n            if (u1.name != v1.name || u2.name != v2.name) {\n              let e_0;\n              e_0 = new Edge(v1, v2);\n\n              if (u1.name === v1.name && v2.isAdjacent(graph2, u2)) {\n                //graph2.getEdge(v2,u2).length>0 ){\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              } else if (v1.isAdjacent(graph1, u1)) {\n                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                let e;\n                e = new Edge(vv1[0], vv2[0]);\n                graphres.addEdge(e);\n              }\n            }\n          });\n        });\n      });\n    });\n    return graphres;\n  }\n  /*public constructor(props: {}) {\n      super(props);\n      store.subscribe(() => {\n          if (store.getState().app.status !== this.state.status) {\n              this.setState({\n                  status: store.getState().app.status,\n              });\n          }\n      });\n      this.task = this.task.bind(this);\n      this.getTaskToolbar = this.getTaskToolbar.bind(this);\n  }\n   public render() {\n      const Task: any = this.task();\n      const Toolbar = this.getTaskToolbar();\n      const Area = this.getArea();\n      return (\n          <div className={styles.App} id=\"wrap\">\n              {this.state.status\n                  ? <p>Задание выполнено. Ожидайте ответа от сервера...</p>\n                  : (\n                      <div>\n                          <div className={styles.MainRow}>\n                              <div className={styles.GraphCell}>\n                                  <Area/>\n                              </div>\n                              <div className={styles.ToolCell}>\n                                  <Toolbar/>\n                              </div>\n                              <div className={styles.TaskCell}>\n                                  <p>Задание</p>\n                                  <Task/>\n                              </div>\n                          </div>\n                          <div className={styles.LeftBottom}>\n                              <StudentMark/>\n                          </div>\n                          <div className={styles.LowRow}>\n                              <Console/>\n                          </div>\n                      </div>)}\n          </div>\n      );\n  }//<Task/>\n   protected getTaskToolbar() {\n      return Toolbar;\n  }\n   protected getArea(): SFC<{}> {\n      return () => <GraphVisualizer\n          graph={graphModel}\n          adapterType={'writable'}\n          namedEdges={false}\n          vertexNaming={true}\n          withoutDragging={true}\n          edgeNaming={false}\n          incidentEdges={false}\n      />;\n      //return () =>\n      //    <GraphVisualizer\n      //        graph={graphModelres}\n      //        adapterType={'readable'}\n      //        namedEdges={false}\n      //        vertexNaming={false}\n      //        withoutDragging={false}\n      //        edgeNaming={false}\n      //        incidentEdges={false}\n      //    />\n  }\n   protected task(): SFC<{}> {\n      graphModel.vertices.forEach(v => (console.log(`id = ${v.id}; label = ${v.label}; name = ${v.name}; wawe=${v.wave}.\\n`)));\n      return () =>\n          <div>\n              <p>\n                  {this.message_0}\n              </p>\n              <div>\n                  <p>\n                      <GraphVisualizer\n                          graph={graphModel1}\n                          adapterType={'readable'}\n                          namedEdges={false}\n                          vertexNaming={false}\n                          withoutDragging={true}\n                          edgeNaming={false}\n                          incidentEdges={false}\n                      />\n                  </p>\n                  <p>\n                      <GraphVisualizer\n                          graph={graphModel2}\n                          adapterType={'readable'}\n                          namedEdges={false}\n                          vertexNaming={false}\n                          withoutDragging={true}\n                          edgeNaming={false}\n                          incidentEdges={false}\n                      />\n                  </p>\n              </div>\n          </div>\n  }*/\n\n\n}\n\nexport default App;","map":{"version":3,"sources":["/home/ilya/UIR/test_5/src/App.tsx"],"names":["Template","store","init","Vertex","Edge","GraphGenerator","init1","graphModel1","init2","graphModel2","initres","App","message_0","num_0","state","status","getState","app","componentWillMount","graph","generate","graph1","GetNewRandomGraph","graph2","GetNewRandomGraphForThatOne","graphres","ChooseTask","Math","round","random","Uni","Joint","Product","Composition","Uni_Z","Cross","Addition","Cartesian_Product","num","arr","i","push","vert","addVertex","j","edge","getVertex","addEdge","length","vertices","forEach","v","edges","e","name","vv1","vertexOne","vv2","vertexTwo","e_new","Operation2","v1","getEdge","v_res","v2","u1","u2","isAdjacent","e_0"],"mappings":"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AAC,CAAD,CAAZ,EAAgBE,GAAG,CAAC,CAAD,CAAnB,CAAJ;AACAhC,gBAAAA,QAAQ,CAACsB,OAAT,CAAiBM,CAAjB;AACH;AACJ;AAEJ,WAvBD;AAwBH,SAzBD;AA0BH,OA3BD;AA4BH,KA7BD;AA+BA,WAAO5B,QAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA9hB2B;;AAqiB3B,eAAed,GAAf","sourcesContent":["import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { GraphVisualizer, IGraphView, Template, Toolbar, ToolButtonList, store, IMatrixView, INGraphsView, graphActionCreators, StudentMark, init, graphModel, Console, State } from \"graphlabs.core.template\";\nimport { IGraph, IVertex, IEdge, Graph, Vertex, Edge, GraphGenerator, SccBuilder } from \"graphlabs.core.graphs\";\nimport styles from './Template.module.scss';\nimport 'graphlabs.core.template/dist/main.css';\n\nimport { Component, SFC} from 'react';\nimport { init1, graphModel1, init2, graphModel2, initres, graphModelres } from './ForMyGraphModel';\n\nclass App extends Template {\n    protected message_0 = \"\";\n    protected num_0 = 0;\n\n    public state = {\n        status: store.getState().app.status,\n    };\n\n    componentWillMount() {\n        let graph: IGraph<IVertex, IEdge>;\n\n        graph = GraphGenerator.generate(0);\n        init(graph);\n\n        let graph1: IGraph<IVertex, IEdge>;\n        graph1 = this.GetNewRandomGraph(5);\n        init1(graph1);\n\n        let graph2: IGraph<IVertex, IEdge>;\n        graph2 = this.GetNewRandomGraphForThatOne(5,graph1);\n        init2(graph2);\n\n        let graphres = this.ChooseTask();\n        initres(graphres);\n        //this.scc_count = SccBuilder.findComponents(graphres).length;\n    }\n\n\n        //Для меня в будующем: проблема невозможности удать ребро заключается в том, что я создаю два других, тем саммы ломая себе всё.\n        //Это нужно проверить и внести определённые правки. Также нужно узнать как мой модуль добавить на сайт, а не только на гитхаб.\n\n\n    protected ChooseTask(){\n        this.num_0 = Math.round(Math.random() * 100)%7;\n        switch (this.num_0) {\n            case 0:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n                return this.Uni(graphModel1,graphModel2);\n            case 1:\n                this.message_0 = \"Постройте граф, являющийся результатом соединения двух графов.\";\n                return this.Joint(graphModel1,graphModel2);\n            case 2:\n                this.message_0 = \"Постройте граф, являющийся результатом произведения двух графов.\";\n                return this.Product(graphModel1,graphModel2);\n            case 3:\n                this.message_0 = \"Постройте граф, являющийся результатом композиции двух графов.\";\n                return this.Composition(graphModel1,graphModel2);\n            case 4:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\"; // Объединение по Зыкову\n                return this.Uni_Z(graphModel1,graphModel2);\n            case 5:\n                this.message_0 = \"Постройте граф, являющийся результатом пересечения двух графов.\"; // Пересечение\n                return this.Cross(graphModel1,graphModel2);\n            case 6:\n                this.message_0 = \"Постройте граф, являющийся дополнением графа.\"; // Дополнение\n                return this.Addition(graphModel1);\n            case 7:\n                this.message_0 = \"Постройте граф, являющийся результатом декартового произведения двух графов.\"; // Декартово произведение\n                return this.Cartesian_Product(graphModel1,graphModel2);\n            default:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n                return this.Uni(graphModel1,graphModel2);\n        }\n    }\n\n    protected GetNewRandomGraph (num:number){ // рандомный граф\n        let graph: IGraph<IVertex, IEdge>;\n        graph = GraphGenerator.generate(0);\n        var arr = [];\n        for(var i = 0; i<num; i++ ){\n            arr.push(Math.round(Math.random()));\n            if(arr[i]===1){\n                let vert = new Vertex(`${i}`);\n                graph.addVertex(vert);\n            }\n        }\n        for(var i=0;i<num-1;i++){\n            if(arr[i]===1) {\n                for(var j = i+1;j<num;j++){\n                    if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge i+j\n                        let edge = new Edge(graph.getVertex(`${i}`)[0],graph.getVertex(`${j}`)[0],`${i}+${j}`);\n                        graph.addEdge(edge);\n                    }\n                }\n            }\n        }\n        return graph;\n    }\n\n    protected GetNewRandomGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>){ // рандомный, не имеющий общих вершин с первым\n        let graph: IGraph<IVertex, IEdge>;\n        graph = GraphGenerator.generate(0);\n        var arr = [];\n        let length = graph1.vertices.length+1;\n        for(var i = 0; i<num; i++ ){\n            arr.push(Math.round(Math.random()));\n            if(arr[i]===1){\n                let vert = new Vertex(`${i+length}`);\n                graph.addVertex(vert);\n            }\n        }\n        for(var i=0;i<num-1;i++){\n            if(arr[i]===1) {\n                for(var j = i+1;j<num;j++){\n                    if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge i+j\n                        let edge = new Edge(graph.getVertex(`${i+length}`)[0],graph.getVertex(`${j+length}`)[0],`${i+length}+${j+length}`);\n                        graph.addEdge(edge);\n                    }\n                }\n            }\n        }\n        return graph;\n    }\n\n\n\n    protected Uni(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph1.edges.forEach((e: any)=> {\n            let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n            let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n            let e_new: IEdge;\n            e_new = new Edge(vv1,vv2);\n            graphres.addEdge(e_new);\n        });\n        graph2.edges.forEach((e: any)=> {\n            let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n            let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n            let e_new: IEdge;\n            e_new = new Edge(vv1,vv2);\n            graphres.addEdge(e_new);\n        });\n        return graphres;\n    }\n\n    protected Operation2(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение по  (это и есть простое соединение)\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n\n                graph1.vertices.forEach((v1:any)=>{ // дополнение к объединению\n                    if(!(graphres.getEdge(v,v1).length>0)){\n                        let e: IEdge;\n                        e = new Edge(v,v1);\n                        graphres.addEdge(e);\n                    }\n                });\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        return graphres;\n    }\n\n    protected Joint(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach(v=>{\n            graphres.addVertex(v);\n            graph2.vertices.forEach(v1=>{\n                if(!(graphres.getVertex(`${v1.name}`).length>0))\n                    graphres.addVertex(v1);\n                let e: IEdge;\n                e = new Edge(v,v1);\n                graphres.addEdge(e);\n            });\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        return graphres;\n    }\n\n    protected Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Произведение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!=v1.name||u2.name!=v2.name){\n                            if((u1.name===v1.name)&&(v2.isAdjacent(graph2,u2))){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if((u2.name===v2.name)&&(v1.isAdjacent(graph1,u1))){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Composition(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Композиция !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!=v1.name || u2.name!=v2.name){\n                            let e_0: IEdge;\n                            e_0=new Edge(v1,v2)\n                            if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if(v1.isAdjacent(graph1,u1)){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Uni_Z(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение по Зыкову\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph1.vertices.forEach((v1: any)=> {\n            graph2.vertices.forEach((v2: any)=> {\n                if (!(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                    let vv1 = graphres.getVertex(`${v1.name}`)[0];\n                    let vv2 = graphres.getVertex(`${v2.name}`)[0];\n\n                    let e: IEdge;\n                    e = new Edge(vv1,vv2);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n        return graphres;\n    }\n\n    protected Cross(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Пересечение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                if (v1.name == v2.name){\n                    let v_res: IVertex;\n                    v_res = new Vertex(`${v1.name}`);\n                    graphres.addVertex(v_res);\n                }\n            });\n        });\n\n        graph1.edges.forEach(u1=>{\n            graph2.edges.forEach(u2=>{\n                if ((u1.vertexOne.name == u2.vertexOne.name && u1.vertexTwo.name == u2.vertexTwo.name) || (u1.vertexOne.name == u2.vertexTwo.name && u1.vertexTwo.name == u2.vertexOne.name)){\n                    let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n                    let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n\n                    let e: IEdge;\n                    e = new Edge(v1[0],v2[0]);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Addition(graph1: IGraph<IVertex, IEdge>){ // Дополнение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v1.name}`);\n            graphres.addVertex(v_res);\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph1.vertices.forEach(v2=>{\n                let vv1 = v1.name;\n                let vv2 = v2.name;\n                if (v1.name != v2.name && !(v1.isAdjacent(graph1,v2)) && !(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                    let v1 = graphres.getVertex(`${vv1}`);\n                    let v2 = graphres.getVertex(`${vv2}`);\n\n                    let e: IEdge;\n                    e = new Edge(v1[0],v2[0]);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n\n        let graph2: IGraph<IVertex, IEdge>;\n        graph2 = this.GetNewRandomGraph(0);\n        init2(graph2);\n\n\n        return graphres;\n    }\n\n    protected Cartesian_Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Декартово произведение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!=v1.name || u2.name!=v2.name){\n                            let e_0: IEdge;\n                            e_0=new Edge(v1,v2)\n                            if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if(v1.isAdjacent(graph1,u1)){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    /*public constructor(props: {}) {\n        super(props);\n        store.subscribe(() => {\n            if (store.getState().app.status !== this.state.status) {\n                this.setState({\n                    status: store.getState().app.status,\n                });\n            }\n        });\n        this.task = this.task.bind(this);\n        this.getTaskToolbar = this.getTaskToolbar.bind(this);\n    }\n\n    public render() {\n        const Task: any = this.task();\n        const Toolbar = this.getTaskToolbar();\n        const Area = this.getArea();\n        return (\n            <div className={styles.App} id=\"wrap\">\n                {this.state.status\n                    ? <p>Задание выполнено. Ожидайте ответа от сервера...</p>\n                    : (\n                        <div>\n                            <div className={styles.MainRow}>\n                                <div className={styles.GraphCell}>\n                                    <Area/>\n                                </div>\n                                <div className={styles.ToolCell}>\n                                    <Toolbar/>\n                                </div>\n                                <div className={styles.TaskCell}>\n                                    <p>Задание</p>\n                                    <Task/>\n                                </div>\n                            </div>\n                            <div className={styles.LeftBottom}>\n                                <StudentMark/>\n                            </div>\n                            <div className={styles.LowRow}>\n                                <Console/>\n                            </div>\n                        </div>)}\n            </div>\n        );\n    }//<Task/>\n\n    protected getTaskToolbar() {\n        return Toolbar;\n    }\n\n    protected getArea(): SFC<{}> {\n        return () => <GraphVisualizer\n            graph={graphModel}\n            adapterType={'writable'}\n            namedEdges={false}\n            vertexNaming={true}\n            withoutDragging={true}\n            edgeNaming={false}\n            incidentEdges={false}\n        />;\n        //return () =>\n        //    <GraphVisualizer\n        //        graph={graphModelres}\n        //        adapterType={'readable'}\n        //        namedEdges={false}\n        //        vertexNaming={false}\n        //        withoutDragging={false}\n        //        edgeNaming={false}\n        //        incidentEdges={false}\n        //    />\n    }\n\n    protected task(): SFC<{}> {\n        graphModel.vertices.forEach(v => (console.log(`id = ${v.id}; label = ${v.label}; name = ${v.name}; wawe=${v.wave}.\\n`)));\n        return () =>\n            <div>\n                <p>\n                    {this.message_0}\n                </p>\n                <div>\n                    <p>\n                        <GraphVisualizer\n                            graph={graphModel1}\n                            adapterType={'readable'}\n                            namedEdges={false}\n                            vertexNaming={false}\n                            withoutDragging={true}\n                            edgeNaming={false}\n                            incidentEdges={false}\n                        />\n                    </p>\n                    <p>\n                        <GraphVisualizer\n                            graph={graphModel2}\n                            adapterType={'readable'}\n                            namedEdges={false}\n                            vertexNaming={false}\n                            withoutDragging={true}\n                            edgeNaming={false}\n                            incidentEdges={false}\n                        />\n                    </p>\n                </div>\n            </div>\n    }*/\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}