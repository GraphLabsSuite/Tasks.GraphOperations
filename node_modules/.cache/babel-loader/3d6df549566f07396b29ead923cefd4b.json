{"ast":null,"code":"import './App.css';\nimport { Template } from \"graphlabs.core.template\";\nimport 'graphlabs.core.template/dist/main.css';\n\nclass App extends Template {\n  /*protected message_0 = \"\";\n  protected num_0 = 0;\n   public state = {\n      status: store.getState().app.status,\n  };\n   componentWillMount() {\n      let graph: IGraph<IVertex, IEdge>;\n       graph = GraphGenerator.generate(0);\n      init(graph);\n       let graph1: IGraph<IVertex, IEdge>;\n      graph1 = this.GetNewRandomGraph(5);\n      init1(graph1);\n       let graph2: IGraph<IVertex, IEdge>;\n      graph2 = this.GetNewRandomGraphForThatOne(5,graph1);\n      init2(graph2);\n       let graphres = this.ChooseTask();\n      initres(graphres);\n      this.scc_count = SccBuilder.findComponents(graphres).length;\n  }\n        //Для меня в будующем: проблема невозможности удать ребро заключается в том, что я создаю два других, тем саммы ломая себе всё.\n      //Это нужно проверить и внести определённые правки. Также нужно узнать как мой модуль добавить на сайт, а не только на гитхаб.\n    protected ChooseTask(){\n      this.num_0 = Math.round(Math.random() * 100)%7;\n      switch (this.num_0) {\n          case 0:\n              this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n              return this.Uni(graphModel1,graphModel2);\n          case 1:\n              this.message_0 = \"Постройте граф, являющийся результатом соединения двух графов.\";\n              return this.Joint(graphModel1,graphModel2);\n          case 2:\n              this.message_0 = \"Постройте граф, являющийся результатом произведения двух графов.\";\n              return this.Product(graphModel1,graphModel2);\n          case 3:\n              this.message_0 = \"Постройте граф, являющийся результатом композиции двух графов.\";\n              return this.Composition(graphModel1,graphModel2);\n          case 4:\n              this.message_0 = \"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\"; // Объединение по Зыкову\n              return this.Uni_Z(graphModel1,graphModel2);\n          case 5:\n              this.message_0 = \"Постройте граф, являющийся результатом пересечения двух графов.\"; // Пересечение\n              return this.Cross(graphModel1,graphModel2);\n          case 6:\n              this.message_0 = \"Постройте граф, являющийся дополнением графа.\"; // Дополнение\n              return this.Addition(graphModel1);\n          case 7:\n              this.message_0 = \"Постройте граф, являющийся результатом декартового произведения двух графов.\"; // Декартово произведение\n              return this.Cartesian_Product(graphModel1,graphModel2);\n          default:\n              this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n              return this.Uni(graphModel1,graphModel2);\n      }\n  }\n   protected GetNewRandomGraph (num:number){ // рандомный граф\n      let graph: IGraph<IVertex, IEdge>;\n      graph = GraphGenerator.generate(0);\n      var arr = [];\n      for(var i = 0; i<num; i++ ){\n          arr.push(Math.round(Math.random()));\n          if(arr[i]===1){\n              let vert = new Vertex(`${i}`);\n              graph.addVertex(vert);\n          }\n      }\n      for(var i=0;i<num-1;i++){\n          if(arr[i]===1) {\n              for(var j = i+1;j<num;j++){\n                  if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge i+j\n                      let edge = new Edge(graph.getVertex(`${i}`)[0],graph.getVertex(`${j}`)[0],`${i}+${j}`);\n                      graph.addEdge(edge);\n                  }\n              }\n          }\n      }\n      return graph;\n  }\n   protected GetNewRandomGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>){ // рандомный, не имеющий общих вершин с первым\n      let graph: IGraph<IVertex, IEdge>;\n      graph = GraphGenerator.generate(0);\n      var arr = [];\n      let length = graph1.vertices.length+1;\n      for(var i = 0; i<num; i++ ){\n          arr.push(Math.round(Math.random()));\n          if(arr[i]===1){\n              let vert = new Vertex(`${i+length}`);\n              graph.addVertex(vert);\n          }\n      }\n      for(var i=0;i<num-1;i++){\n          if(arr[i]===1) {\n              for(var j = i+1;j<num;j++){\n                  if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge i+j\n                      let edge = new Edge(graph.getVertex(`${i+length}`)[0],graph.getVertex(`${j+length}`)[0],`${i+length}+${j+length}`);\n                      graph.addEdge(edge);\n                  }\n              }\n          }\n      }\n      return graph;\n  }\n     protected Uni(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение\n      let graphres: IGraph<IVertex, IEdge>;\n      graphres = GraphGenerator.generate(0);\n      graph1.vertices.forEach((v:any)=>{\n          graphres.addVertex(v);\n      });\n      graph1.edges.forEach((e:any)=>{\n          graphres.addEdge(e);\n      });\n      graph2.vertices.forEach((v: any)=>{\n          if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n              graphres.addVertex(v);\n          }\n      });\n      graph2.edges.forEach((e:any)=>{\n          graphres.addEdge(e);\n      });\n      graph1.edges.forEach((e: any)=> {\n          let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n          let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n           let e_new: IEdge;\n          e_new = new Edge(vv1,vv2);\n          graphres.addEdge(e_new);\n      });\n      graph2.edges.forEach((e: any)=> {\n          let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n          let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n           let e_new: IEdge;\n          e_new = new Edge(vv1,vv2);\n          graphres.addEdge(e_new);\n      });\n      return graphres;\n  }\n   protected Operation2(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение по  (это и есть простое соединение)\n      let graphres: IGraph<IVertex, IEdge>;\n      graphres = GraphGenerator.generate(0);\n      graph1.vertices.forEach((v:any)=>{\n          graphres.addVertex(v);\n      });\n      graph1.edges.forEach((e:any)=>{\n          graphres.addEdge(e);\n      });\n      graph2.vertices.forEach((v: any)=>{\n          if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n              graphres.addVertex(v);\n               graph1.vertices.forEach((v1:any)=>{ // дополнение к объединению\n                  if(!(graphres.getEdge(v,v1).length>0)){\n                      let e: IEdge;\n                      e = new Edge(v,v1);\n                      graphres.addEdge(e);\n                  }\n              });\n          }\n      });\n      graph2.edges.forEach((e:any)=>{\n          graphres.addEdge(e);\n      });\n      return graphres;\n  }\n   protected Joint(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение !!!!! без пересечения вершин !!!!!\n      let graphres: IGraph<IVertex, IEdge>;\n      graphres = GraphGenerator.generate(0);\n      graph1.vertices.forEach(v=>{\n          graphres.addVertex(v);\n          graph2.vertices.forEach(v1=>{\n              if(!(graphres.getVertex(`${v1.name}`).length>0))\n                  graphres.addVertex(v1);\n              let e: IEdge;\n              e = new Edge(v,v1);\n              graphres.addEdge(e);\n          });\n      });\n      graph1.edges.forEach((e:any)=>{\n          graphres.addEdge(e);\n      });\n      graph2.edges.forEach((e:any)=>{\n          graphres.addEdge(e);\n      });\n      return graphres;\n  }\n   protected Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Произведение !!!!! без пересечения вершин !!!!!\n      let graphres: IGraph<IVertex, IEdge>;\n      graphres = GraphGenerator.generate(0);\n       graph1.vertices.forEach(v=>{\n          graph2.vertices.forEach(v1=>{\n              let v_res: IVertex;\n              v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n              graphres.addVertex(v_res);\n              //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n              //graphres.addVertex(v_res);\n           });\n      });\n       graph1.vertices.forEach(v1=>{\n          graph2.vertices.forEach(v2=>{\n              graph1.vertices.forEach(u1=>{\n                  graph2.vertices.forEach(u2=>{\n                      if(u1.name!=v1.name||u2.name!=v2.name){\n                          if((u1.name===v1.name)&&(v2.isAdjacent(graph2,u2))){\n                              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                               let e: IEdge;\n                              e = new Edge(vv1[0],vv2[0]);\n                              graphres.addEdge(e);\n                          }\n                           else if((u2.name===v2.name)&&(v1.isAdjacent(graph1,u1))){\n                              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                               let e: IEdge;\n                              e = new Edge(vv1[0],vv2[0]);\n                              graphres.addEdge(e);\n                          }\n                      }\n                   });\n              });\n          });\n      });\n       return graphres;\n  }\n   protected Composition(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Композиция !!!!! без пересечения вершин !!!!!\n      let graphres: IGraph<IVertex, IEdge>;\n      graphres = GraphGenerator.generate(0);\n       graph1.vertices.forEach(v=>{\n          graph2.vertices.forEach(v1=>{\n              let v_res: IVertex;\n              v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n              graphres.addVertex(v_res);\n              //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n              //graphres.addVertex(v_res);\n           });\n      });\n       graph1.vertices.forEach(v1=>{\n          graph2.vertices.forEach(v2=>{\n              graph1.vertices.forEach(u1=>{\n                  graph2.vertices.forEach(u2=>{\n                      if(u1.name!=v1.name || u2.name!=v2.name){\n                          let e_0: IEdge;\n                          e_0=new Edge(v1,v2)\n                          if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                               let e: IEdge;\n                              e = new Edge(vv1[0],vv2[0]);\n                              graphres.addEdge(e);\n                          }\n                           else if(v1.isAdjacent(graph1,u1)){\n                              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                               let e: IEdge;\n                              e = new Edge(vv1[0],vv2[0]);\n                              graphres.addEdge(e);\n                          }\n                      }\n                   });\n              });\n          });\n      });\n       return graphres;\n  }\n   protected Uni_Z(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение по Зыкову\n      let graphres: IGraph<IVertex, IEdge>;\n      graphres = GraphGenerator.generate(0);\n      graph1.vertices.forEach((v:any)=>{\n          graphres.addVertex(v);\n      });\n      graph1.edges.forEach((e:any)=>{\n          graphres.addEdge(e);\n      });\n      graph2.vertices.forEach((v: any)=>{\n          if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n              graphres.addVertex(v);\n          }\n      });\n      graph2.edges.forEach((e:any)=>{\n          graphres.addEdge(e);\n      });\n      graph1.vertices.forEach((v1: any)=> {\n          graph2.vertices.forEach((v2: any)=> {\n              if (!(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                  let vv1 = graphres.getVertex(`${v1.name}`)[0];\n                  let vv2 = graphres.getVertex(`${v2.name}`)[0];\n                   let e: IEdge;\n                  e = new Edge(vv1,vv2);\n                  graphres.addEdge(e);\n              }\n          });\n      });\n      return graphres;\n  }\n   protected Cross(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Пересечение\n      let graphres: IGraph<IVertex, IEdge>;\n      graphres = GraphGenerator.generate(0);\n       graph1.vertices.forEach(v1=>{\n          graph2.vertices.forEach(v2=>{\n              if (v1.name == v2.name){\n                  let v_res: IVertex;\n                  v_res = new Vertex(`${v1.name}`);\n                  graphres.addVertex(v_res);\n              }\n          });\n      });\n       graph1.edges.forEach(u1=>{\n          graph2.edges.forEach(u2=>{\n              if ((u1.vertexOne.name == u2.vertexOne.name && u1.vertexTwo.name == u2.vertexTwo.name) || (u1.vertexOne.name == u2.vertexTwo.name && u1.vertexTwo.name == u2.vertexOne.name)){\n                  let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n                  let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n                   let e: IEdge;\n                  e = new Edge(v1[0],v2[0]);\n                  graphres.addEdge(e);\n              }\n          });\n      });\n       return graphres;\n  }\n   protected Addition(graph1: IGraph<IVertex, IEdge>){ // Дополнение\n      let graphres: IGraph<IVertex, IEdge>;\n      graphres = GraphGenerator.generate(0);\n       graph1.vertices.forEach(v1=>{\n          let v_res: IVertex;\n          v_res = new Vertex(`${v1.name}`);\n          graphres.addVertex(v_res);\n      });\n       graph1.vertices.forEach(v1=>{\n          graph1.vertices.forEach(v2=>{\n              let vv1 = v1.name;\n              let vv2 = v2.name;\n              if (v1.name != v2.name && !(v1.isAdjacent(graph1,v2)) && !(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                  let v1 = graphres.getVertex(`${vv1}`);\n                  let v2 = graphres.getVertex(`${vv2}`);\n                   let e: IEdge;\n                  e = new Edge(v1[0],v2[0]);\n                  graphres.addEdge(e);\n              }\n          });\n      });\n       let graph2: IGraph<IVertex, IEdge>;\n      graph2 = this.GetNewRandomGraph(0);\n      init2(graph2);\n        return graphres;\n  }\n   protected Cartesian_Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Декартово произведение !!!!! без пересечения вершин !!!!!\n      let graphres: IGraph<IVertex, IEdge>;\n      graphres = GraphGenerator.generate(0);\n       graph1.vertices.forEach(v=>{\n          graph2.vertices.forEach(v1=>{\n              let v_res: IVertex;\n              v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n              graphres.addVertex(v_res);\n              //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n              //graphres.addVertex(v_res);\n           });\n      });\n       graph1.vertices.forEach(v1=>{\n          graph2.vertices.forEach(v2=>{\n              graph1.vertices.forEach(u1=>{\n                  graph2.vertices.forEach(u2=>{\n                      if(u1.name!=v1.name || u2.name!=v2.name){\n                          let e_0: IEdge;\n                          e_0=new Edge(v1,v2)\n                          if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                               let e: IEdge;\n                              e = new Edge(vv1[0],vv2[0]);\n                              graphres.addEdge(e);\n                          }\n                           else if(v1.isAdjacent(graph1,u1)){\n                              let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                              let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n                               let e: IEdge;\n                              e = new Edge(vv1[0],vv2[0]);\n                              graphres.addEdge(e);\n                          }\n                      }\n                   });\n              });\n          });\n      });\n       return graphres;\n  }\n   public constructor(props: {}) {\n      super(props);\n      store.subscribe(() => {\n          if (store.getState().app.status !== this.state.status) {\n              this.setState({\n                  status: store.getState().app.status,\n              });\n          }\n      });\n      this.task = this.task.bind(this);\n      this.getTaskToolbar = this.getTaskToolbar.bind(this);\n  }\n   public render() {\n      const Task: any = this.task();\n      const Toolbar = this.getTaskToolbar();\n      const Area = this.getArea();\n      return (\n          <div className={styles.App} id=\"wrap\">\n              {this.state.status\n                  ? <p>Задание выполнено. Ожидайте ответа от сервера...</p>\n                  : (\n                      <div>\n                          <div className={styles.MainRow}>\n                              <div className={styles.GraphCell}>\n                                  <Area/>\n                              </div>\n                              <div className={styles.ToolCell}>\n                                  <Toolbar/>\n                              </div>\n                              <div className={styles.TaskCell}>\n                                  <p>Задание</p>\n                                  <Task/>\n                              </div>\n                          </div>\n                          <div className={styles.LeftBottom}>\n                              <StudentMark/>\n                          </div>\n                          <div className={styles.LowRow}>\n                              <Console/>\n                          </div>\n                      </div>)}\n          </div>\n      );\n  }//<Task/>\n   protected getTaskToolbar() {\n      return Toolbar;\n  }\n   protected getArea(): SFC<{}> {\n      return () => <GraphVisualizer\n          graph={graphModel}\n          adapterType={'writable'}\n          namedEdges={false}\n          vertexNaming={true}\n          withoutDragging={true}\n          edgeNaming={false}\n          incidentEdges={false}\n      />;\n      //return () =>\n      //    <GraphVisualizer\n      //        graph={graphModelres}\n      //        adapterType={'readable'}\n      //        namedEdges={false}\n      //        vertexNaming={false}\n      //        withoutDragging={false}\n      //        edgeNaming={false}\n      //        incidentEdges={false}\n      //    />\n  }\n   protected task(): SFC<{}> {\n      graphModel.vertices.forEach(v => (console.log(`id = ${v.id}; label = ${v.label}; name = ${v.name}; wawe=${v.wave}.\\n`)));\n      return () =>\n          <div>\n              <p>\n                  {this.message_0}\n              </p>\n              <div>\n                  <p>\n                      <GraphVisualizer\n                          graph={graphModel1}\n                          adapterType={'readable'}\n                          namedEdges={false}\n                          vertexNaming={false}\n                          withoutDragging={true}\n                          edgeNaming={false}\n                          incidentEdges={false}\n                      />\n                  </p>\n                  <p>\n                      <GraphVisualizer\n                          graph={graphModel2}\n                          adapterType={'readable'}\n                          namedEdges={false}\n                          vertexNaming={false}\n                          withoutDragging={true}\n                          edgeNaming={false}\n                          incidentEdges={false}\n                      />\n                  </p>\n              </div>\n          </div>\n  }*/\n}\n\nexport default App;","map":{"version":3,"sources":["/home/ilya/UIR/test_5/src/App.tsx"],"names":["Template","App"],"mappings":"AAEA,OAAO,WAAP;AACA,SAAsCA,QAAtC,QAAqL,yBAArL;AAGA,OAAO,uCAAP;;AAKA,MAAMC,GAAN,SAAkBD,QAAlB,CAA2B;AACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhe2B;;AAqiB3B,eAAeC,GAAf","sourcesContent":["import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { GraphVisualizer, IGraphView, Template, Toolbar, ToolButtonList, store, IMatrixView, INGraphsView, graphActionCreators, StudentMark, init, graphModel, Console, State } from \"graphlabs.core.template\";\nimport { IGraph, IVertex, IEdge, Graph, Vertex, Edge, GraphGenerator, SccBuilder } from \"graphlabs.core.graphs\";\nimport styles from './Template.module.scss';\nimport 'graphlabs.core.template/dist/main.css';\n\nimport { Component, SFC} from 'react';\nimport { init1, graphModel1, init2, graphModel2, initres, graphModelres } from './ForMyGraphModel';\n\nclass App extends Template {\n    /*protected message_0 = \"\";\n    protected num_0 = 0;\n\n    public state = {\n        status: store.getState().app.status,\n    };\n\n    componentWillMount() {\n        let graph: IGraph<IVertex, IEdge>;\n\n        graph = GraphGenerator.generate(0);\n        init(graph);\n\n        let graph1: IGraph<IVertex, IEdge>;\n        graph1 = this.GetNewRandomGraph(5);\n        init1(graph1);\n\n        let graph2: IGraph<IVertex, IEdge>;\n        graph2 = this.GetNewRandomGraphForThatOne(5,graph1);\n        init2(graph2);\n\n        let graphres = this.ChooseTask();\n        initres(graphres);\n        this.scc_count = SccBuilder.findComponents(graphres).length;\n    }\n\n\n        //Для меня в будующем: проблема невозможности удать ребро заключается в том, что я создаю два других, тем саммы ломая себе всё.\n        //Это нужно проверить и внести определённые правки. Также нужно узнать как мой модуль добавить на сайт, а не только на гитхаб.\n\n\n    protected ChooseTask(){\n        this.num_0 = Math.round(Math.random() * 100)%7;\n        switch (this.num_0) {\n            case 0:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n                return this.Uni(graphModel1,graphModel2);\n            case 1:\n                this.message_0 = \"Постройте граф, являющийся результатом соединения двух графов.\";\n                return this.Joint(graphModel1,graphModel2);\n            case 2:\n                this.message_0 = \"Постройте граф, являющийся результатом произведения двух графов.\";\n                return this.Product(graphModel1,graphModel2);\n            case 3:\n                this.message_0 = \"Постройте граф, являющийся результатом композиции двух графов.\";\n                return this.Composition(graphModel1,graphModel2);\n            case 4:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\"; // Объединение по Зыкову\n                return this.Uni_Z(graphModel1,graphModel2);\n            case 5:\n                this.message_0 = \"Постройте граф, являющийся результатом пересечения двух графов.\"; // Пересечение\n                return this.Cross(graphModel1,graphModel2);\n            case 6:\n                this.message_0 = \"Постройте граф, являющийся дополнением графа.\"; // Дополнение\n                return this.Addition(graphModel1);\n            case 7:\n                this.message_0 = \"Постройте граф, являющийся результатом декартового произведения двух графов.\"; // Декартово произведение\n                return this.Cartesian_Product(graphModel1,graphModel2);\n            default:\n                this.message_0 = \"Постройте граф, являющийся результатом объединения двух графов.\";\n                return this.Uni(graphModel1,graphModel2);\n        }\n    }\n\n    protected GetNewRandomGraph (num:number){ // рандомный граф\n        let graph: IGraph<IVertex, IEdge>;\n        graph = GraphGenerator.generate(0);\n        var arr = [];\n        for(var i = 0; i<num; i++ ){\n            arr.push(Math.round(Math.random()));\n            if(arr[i]===1){\n                let vert = new Vertex(`${i}`);\n                graph.addVertex(vert);\n            }\n        }\n        for(var i=0;i<num-1;i++){\n            if(arr[i]===1) {\n                for(var j = i+1;j<num;j++){\n                    if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge i+j\n                        let edge = new Edge(graph.getVertex(`${i}`)[0],graph.getVertex(`${j}`)[0],`${i}+${j}`);\n                        graph.addEdge(edge);\n                    }\n                }\n            }\n        }\n        return graph;\n    }\n\n    protected GetNewRandomGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>){ // рандомный, не имеющий общих вершин с первым\n        let graph: IGraph<IVertex, IEdge>;\n        graph = GraphGenerator.generate(0);\n        var arr = [];\n        let length = graph1.vertices.length+1;\n        for(var i = 0; i<num; i++ ){\n            arr.push(Math.round(Math.random()));\n            if(arr[i]===1){\n                let vert = new Vertex(`${i+length}`);\n                graph.addVertex(vert);\n            }\n        }\n        for(var i=0;i<num-1;i++){\n            if(arr[i]===1) {\n                for(var j = i+1;j<num;j++){\n                    if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge i+j\n                        let edge = new Edge(graph.getVertex(`${i+length}`)[0],graph.getVertex(`${j+length}`)[0],`${i+length}+${j+length}`);\n                        graph.addEdge(edge);\n                    }\n                }\n            }\n        }\n        return graph;\n    }\n\n\n\n    protected Uni(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph1.edges.forEach((e: any)=> {\n            let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n            let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n            let e_new: IEdge;\n            e_new = new Edge(vv1,vv2);\n            graphres.addEdge(e_new);\n        });\n        graph2.edges.forEach((e: any)=> {\n            let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n            let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n            let e_new: IEdge;\n            e_new = new Edge(vv1,vv2);\n            graphres.addEdge(e_new);\n        });\n        return graphres;\n    }\n\n    protected Operation2(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение по  (это и есть простое соединение)\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n\n                graph1.vertices.forEach((v1:any)=>{ // дополнение к объединению\n                    if(!(graphres.getEdge(v,v1).length>0)){\n                        let e: IEdge;\n                        e = new Edge(v,v1);\n                        graphres.addEdge(e);\n                    }\n                });\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        return graphres;\n    }\n\n    protected Joint(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach(v=>{\n            graphres.addVertex(v);\n            graph2.vertices.forEach(v1=>{\n                if(!(graphres.getVertex(`${v1.name}`).length>0))\n                    graphres.addVertex(v1);\n                let e: IEdge;\n                e = new Edge(v,v1);\n                graphres.addEdge(e);\n            });\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        return graphres;\n    }\n\n    protected Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Произведение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!=v1.name||u2.name!=v2.name){\n                            if((u1.name===v1.name)&&(v2.isAdjacent(graph2,u2))){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if((u2.name===v2.name)&&(v1.isAdjacent(graph1,u1))){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Composition(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Композиция !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!=v1.name || u2.name!=v2.name){\n                            let e_0: IEdge;\n                            e_0=new Edge(v1,v2)\n                            if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if(v1.isAdjacent(graph1,u1)){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Uni_Z(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение по Зыкову\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n        graph1.vertices.forEach((v:any)=>{\n            graphres.addVertex(v);\n        });\n        graph1.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph2.vertices.forEach((v: any)=>{\n            if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n                graphres.addVertex(v);\n            }\n        });\n        graph2.edges.forEach((e:any)=>{\n            graphres.addEdge(e);\n        });\n        graph1.vertices.forEach((v1: any)=> {\n            graph2.vertices.forEach((v2: any)=> {\n                if (!(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                    let vv1 = graphres.getVertex(`${v1.name}`)[0];\n                    let vv2 = graphres.getVertex(`${v2.name}`)[0];\n\n                    let e: IEdge;\n                    e = new Edge(vv1,vv2);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n        return graphres;\n    }\n\n    protected Cross(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Пересечение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                if (v1.name == v2.name){\n                    let v_res: IVertex;\n                    v_res = new Vertex(`${v1.name}`);\n                    graphres.addVertex(v_res);\n                }\n            });\n        });\n\n        graph1.edges.forEach(u1=>{\n            graph2.edges.forEach(u2=>{\n                if ((u1.vertexOne.name == u2.vertexOne.name && u1.vertexTwo.name == u2.vertexTwo.name) || (u1.vertexOne.name == u2.vertexTwo.name && u1.vertexTwo.name == u2.vertexOne.name)){\n                    let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n                    let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n\n                    let e: IEdge;\n                    e = new Edge(v1[0],v2[0]);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n\n        return graphres;\n    }\n\n    protected Addition(graph1: IGraph<IVertex, IEdge>){ // Дополнение\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v1.name}`);\n            graphres.addVertex(v_res);\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph1.vertices.forEach(v2=>{\n                let vv1 = v1.name;\n                let vv2 = v2.name;\n                if (v1.name != v2.name && !(v1.isAdjacent(graph1,v2)) && !(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                    let v1 = graphres.getVertex(`${vv1}`);\n                    let v2 = graphres.getVertex(`${vv2}`);\n\n                    let e: IEdge;\n                    e = new Edge(v1[0],v2[0]);\n                    graphres.addEdge(e);\n                }\n            });\n        });\n\n        let graph2: IGraph<IVertex, IEdge>;\n        graph2 = this.GetNewRandomGraph(0);\n        init2(graph2);\n\n\n        return graphres;\n    }\n\n    protected Cartesian_Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Декартово произведение !!!!! без пересечения вершин !!!!!\n        let graphres: IGraph<IVertex, IEdge>;\n        graphres = GraphGenerator.generate(0);\n\n        graph1.vertices.forEach(v=>{\n            graph2.vertices.forEach(v1=>{\n                let v_res: IVertex;\n                v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n                graphres.addVertex(v_res);\n                //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n                //graphres.addVertex(v_res);\n\n            });\n        });\n\n        graph1.vertices.forEach(v1=>{\n            graph2.vertices.forEach(v2=>{\n                graph1.vertices.forEach(u1=>{\n                    graph2.vertices.forEach(u2=>{\n                        if(u1.name!=v1.name || u2.name!=v2.name){\n                            let e_0: IEdge;\n                            e_0=new Edge(v1,v2)\n                            if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n\n                            else if(v1.isAdjacent(graph1,u1)){\n                                let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                                let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                                let e: IEdge;\n                                e = new Edge(vv1[0],vv2[0]);\n                                graphres.addEdge(e);\n                            }\n                        }\n\n                    });\n                });\n            });\n        });\n\n        return graphres;\n    }\n\n    public constructor(props: {}) {\n        super(props);\n        store.subscribe(() => {\n            if (store.getState().app.status !== this.state.status) {\n                this.setState({\n                    status: store.getState().app.status,\n                });\n            }\n        });\n        this.task = this.task.bind(this);\n        this.getTaskToolbar = this.getTaskToolbar.bind(this);\n    }\n\n    public render() {\n        const Task: any = this.task();\n        const Toolbar = this.getTaskToolbar();\n        const Area = this.getArea();\n        return (\n            <div className={styles.App} id=\"wrap\">\n                {this.state.status\n                    ? <p>Задание выполнено. Ожидайте ответа от сервера...</p>\n                    : (\n                        <div>\n                            <div className={styles.MainRow}>\n                                <div className={styles.GraphCell}>\n                                    <Area/>\n                                </div>\n                                <div className={styles.ToolCell}>\n                                    <Toolbar/>\n                                </div>\n                                <div className={styles.TaskCell}>\n                                    <p>Задание</p>\n                                    <Task/>\n                                </div>\n                            </div>\n                            <div className={styles.LeftBottom}>\n                                <StudentMark/>\n                            </div>\n                            <div className={styles.LowRow}>\n                                <Console/>\n                            </div>\n                        </div>)}\n            </div>\n        );\n    }//<Task/>\n\n    protected getTaskToolbar() {\n        return Toolbar;\n    }\n\n    protected getArea(): SFC<{}> {\n        return () => <GraphVisualizer\n            graph={graphModel}\n            adapterType={'writable'}\n            namedEdges={false}\n            vertexNaming={true}\n            withoutDragging={true}\n            edgeNaming={false}\n            incidentEdges={false}\n        />;\n        //return () =>\n        //    <GraphVisualizer\n        //        graph={graphModelres}\n        //        adapterType={'readable'}\n        //        namedEdges={false}\n        //        vertexNaming={false}\n        //        withoutDragging={false}\n        //        edgeNaming={false}\n        //        incidentEdges={false}\n        //    />\n    }\n\n    protected task(): SFC<{}> {\n        graphModel.vertices.forEach(v => (console.log(`id = ${v.id}; label = ${v.label}; name = ${v.name}; wawe=${v.wave}.\\n`)));\n        return () =>\n            <div>\n                <p>\n                    {this.message_0}\n                </p>\n                <div>\n                    <p>\n                        <GraphVisualizer\n                            graph={graphModel1}\n                            adapterType={'readable'}\n                            namedEdges={false}\n                            vertexNaming={false}\n                            withoutDragging={true}\n                            edgeNaming={false}\n                            incidentEdges={false}\n                        />\n                    </p>\n                    <p>\n                        <GraphVisualizer\n                            graph={graphModel2}\n                            adapterType={'readable'}\n                            namedEdges={false}\n                            vertexNaming={false}\n                            withoutDragging={true}\n                            edgeNaming={false}\n                            incidentEdges={false}\n                        />\n                    </p>\n                </div>\n            </div>\n    }*/\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}