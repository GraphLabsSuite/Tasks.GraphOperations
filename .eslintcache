[{"/home/ilya/UIR/Tasks.GraphOperations/src/index.tsx":"1","/home/ilya/UIR/Tasks.GraphOperations/src/reportWebVitals.ts":"2","/home/ilya/UIR/Tasks.GraphOperations/src/App.tsx":"3","/home/ilya/UIR/Tasks.GraphOperations/src/ForMyGraphModel.ts":"4","/home/ilya/UIR/Tasks.GraphOperations/src/Ops.ts":"5","/home/ilya/UIR/Tasks.GraphOperations/src/CheckAnswer.ts":"6","/home/ilya/UIR/Tasks.GraphOperations/src/GraphsInit.ts":"7","/home/ilya/UIR/Tasks.GraphOperations/src/ForMeVars.tsx":"8","/home/ilya/UIR/Tasks.GraphOperations/src/MyVisualizer.tsx":"9"},{"size":500,"mtime":1612041338314,"results":"10","hashOfConfig":"11"},{"size":425,"mtime":1612041338322,"results":"12","hashOfConfig":"11"},{"size":12541,"mtime":1622916748377,"results":"13","hashOfConfig":"11"},{"size":1321,"mtime":1622915714262,"results":"14","hashOfConfig":"11"},{"size":13568,"mtime":1617540034049,"results":"15","hashOfConfig":"11"},{"size":4001,"mtime":1621188506235,"results":"16","hashOfConfig":"11"},{"size":3864,"mtime":1622848813224,"results":"17","hashOfConfig":"11"},{"size":1951,"mtime":1622916178317,"results":"18","hashOfConfig":"11"},{"size":3739,"mtime":1622915520740,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"zzjyth",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"32"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"22"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"22"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"22"},"/home/ilya/UIR/Tasks.GraphOperations/src/index.tsx",[],["44","45"],"/home/ilya/UIR/Tasks.GraphOperations/src/reportWebVitals.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/App.tsx",["46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66"],"/home/ilya/UIR/Tasks.GraphOperations/src/ForMyGraphModel.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/Ops.ts",["67"],"import './App.css';\nimport {  IGraph, IVertex, IEdge, Vertex, Edge, GraphGenerator } from \"graphlabs.core.graphs\";\nimport 'graphlabs.core.template/dist/main.css';\n\nimport { /*initres, graphModelres, init, graphModel, init1,*/ graphModel1, init2, graphModel2 } from './ForMyGraphModel';\nimport { num_0, num_0_changing, message_0_changing } from './ForMeVars';\n\nfunction ChooseTask(){\n    switch (num_0) {\n        case 0:\n            message_0_changing(\"Постройте граф, являющийся результатом пересечения двух графов.\");// вершины пересекаются\n            return Cross(graphModel1,graphModel2);\n        case 1:\n            message_0_changing(\"Постройте граф, являющийся дополнением графа.\"); // один граф\n            return Addition(graphModel1);\n        case 2:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\"); // вершины пересекаются\n            return Uni(graphModel1,graphModel2);\n        case 3:\n            message_0_changing(\"Постройте граф, являющийся результатом соединения двух графов с неперсекающимися вершинами.\"); // вершины пока не пересекаются\n            return Joint(graphModel1,graphModel2);\n        case 4:\n            message_0_changing(\"Постройте граф, являющийся результатом соединения двух графов с персекающимися вершинами.\"); // вершины пересекаются\n            return Joint_Z(graphModel1,graphModel2);\n        case 5:\n            message_0_changing(\"Постройте граф, являющийся результатом произведения двух графов.\"); // вершины пока не пересекаются\n            return Product(graphModel1,graphModel2);\n        case 6:\n            message_0_changing(\"Постройте граф, являющийся результатом композиции двух графов.\"); // вершины пока не пересекаются\n            return Composition(graphModel1,graphModel2);\n        case 7:\n            message_0_changing(\"Постройте граф, являющийся результатом декартового произведения двух графов.\"); // вершины пока не пересекаются\n            return Cartesian_Product(graphModel1,graphModel2);\n        default:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\");\n            return Uni(graphModel1,graphModel2);\n    }\n}\n\nfunction Addition(graph1: IGraph<IVertex, IEdge>){ // Дополнение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v1=>{\n        let v_res: IVertex;\n        v_res = new Vertex(`${v1.name}`);\n        graphres.addVertex(v_res);\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph1.vertices.forEach(v2=>{\n            let vv1 = v1.name;\n            let vv2 = v2.name;\n            if (v1.name !== v2.name && !(v1.isAdjacent(graph1,v2)) && !(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                let v1 = graphres.getVertex(`${vv1}`);\n                let v2 = graphres.getVertex(`${vv2}`);\n\n                let e: IEdge;\n                e = new Edge(v1[0],v2[0]);\n                graphres.addEdge(e);\n            }\n        });\n    });\n\n    let graph2: IGraph<IVertex, IEdge>;\n    graph2 = GraphGenerator.generate(0);\n    init2(graph2);\n\n\n    return graphres;\n}\n\nfunction Cross(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Пересечение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            if (v1.name === v2.name){\n                let v_res: IVertex;\n                v_res = new Vertex(`${v1.name}`);\n                graphres.addVertex(v_res);\n            }\n        });\n    });\n\n    graph1.edges.forEach(u1=>{\n        graph2.edges.forEach(u2=>{\n            if ((u1.vertexOne.name === u2.vertexOne.name && u1.vertexTwo.name === u2.vertexTwo.name) || (u1.vertexOne.name === u2.vertexTwo.name && u1.vertexTwo.name === u2.vertexOne.name)){\n                let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n                let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n\n                let e: IEdge;\n                e = new Edge(v1[0],v2[0]);\n                graphres.addEdge(e);\n            }\n        });\n    });\n\n    return graphres;\n}\n\nfunction Uni(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach((v:any)=>{\n        graphres.addVertex(v);\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.vertices.forEach((v: any)=>{\n        if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n            graphres.addVertex(v);\n        }\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph1.edges.forEach((e: any)=> {\n        let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n        let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n        let e_new: IEdge;\n        e_new = new Edge(vv1,vv2);\n        graphres.addEdge(e_new);\n    });\n    graph2.edges.forEach((e: any)=> {\n        let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n        let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n        let e_new: IEdge;\n        e_new = new Edge(vv1,vv2);\n        graphres.addEdge(e_new);\n    });\n    return graphres;\n}\n\nfunction Joint_Z(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение с пересекающимися вершинами\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach((v:any)=>{\n        graphres.addVertex(v);\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.vertices.forEach((v: any)=>{\n        if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n            graphres.addVertex(v);\n        }\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph1.vertices.forEach((v1: any)=> {\n        graph2.vertices.forEach((v2: any)=> {\n            if (!(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                let vv1 = graphres.getVertex(`${v1.name}`)[0];\n                let vv2 = graphres.getVertex(`${v2.name}`)[0];\n\n                let e: IEdge;\n                e = new Edge(vv1,vv2);\n                graphres.addEdge(e);\n            }\n        });\n    });\n    return graphres;\n}\n\nfunction Joint(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v=>{\n        graphres.addVertex(v);\n        graph2.vertices.forEach(v1=>{\n            if(!(graphres.getVertex(`${v1.name}`).length>0))\n                graphres.addVertex(v1);\n            let e: IEdge;\n            e = new Edge(v,v1);\n            graphres.addEdge(e);\n        });\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    return graphres;\n}\n\nfunction Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Произведение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name||u2.name!==v2.name){\n                        if((u1.name===v1.name)&&(v2.isAdjacent(graph2,u2))){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if((u2.name===v2.name)&&(v1.isAdjacent(graph1,u1))){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nfunction Composition(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Композиция !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name || u2.name!==v2.name){\n                        //let e_0: IEdge;\n                        //e_0=new Edge(v1,v2)\n                        if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if(v1.isAdjacent(graph1,u1)){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nfunction Cartesian_Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Декартово произведение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name || u2.name!==v2.name){\n                        //let e_0: IEdge;\n                        //e_0=new Edge(v1,v2)\n                        if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if(v1.isAdjacent(graph1,u1)){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nexport { ChooseTask };",["68","69"],"/home/ilya/UIR/Tasks.GraphOperations/src/CheckAnswer.ts",["70","71","72","73","74"],"import {graphModel, graphModelres} from \"./ForMyGraphModel\";\nimport { IVertex } from 'graphlabs.core.graphs';\nimport { store } from 'graphlabs.core.template';\nimport {message_0, message_0_changing, num_0, num_0_changing, message_1, message_1_changing, mark_0, mark_0_changing, k_s, k_s_changing} from './ForMeVars';\n\nfunction LastCheckingAnswer(){\n    mark_0_changing(Math.round(mark_0*100/(8*9+k_s[0]+k_s[1]+k_s[2]+k_s[3]+k_s[4]+k_s[5]+k_s[6]+k_s[7])));\n    window.alert(`Вы вполнили задания на оценку: ${mark_0}`);\n    //window.alert(`k_s: ${k_s}`);\n    store.getState().notifier.score = mark_0; // здесь я меняю оценку.\n    return Promise.resolve({success: mark_0 === 100, fee: mark_0});\n}\n\nfunction CheckingAnswer(){// мое добавление для проверки оценки: процент одинаковости\n    let markN = 100;\n    graphModelres.vertices.forEach((v:any)=>{ // проверка на совпадения вершин\n        if(graphModel.getVertex(v.name).length===1){\n            //markN+=50/(graphModelres.vertices.length);\n        }\n        else{\n            markN=0;\n        }\n    });\n    graphModel.vertices.forEach((v:any)=>{ // проверка на лишние вершины\n        if(graphModelres.getVertex(v.name).length===0){\n            //markN-=50/(graphModelres.vertices.length);\n            markN=0;\n        }\n    });\n\n    let num = 0;\n    graphModel.vertices.forEach((v1:IVertex)=>{\n        graphModel.vertices.forEach((v2:IVertex)=>{\n            graphModelres.vertices.forEach((u1:IVertex)=>{\n                graphModelres.vertices.forEach((u2:IVertex)=>{\n                    if( ( v1.name === u1.name && v2.name === u2.name ) || ( v1.name === u2.name && v2.name === u1.name ) ){\n                        if( v1.name !== v2.name && u1.name !== u2.name ){\n                            if( v1.isAdjacent(graphModel, v2) ){\n                                if( u1.isAdjacent(graphModelres, u2) ) {\n                                    num++;\n                                }\n                            }\n                        }\n                    }\n                });\n            });\n        });\n    });\n    num/=2*2;\n    if(num !== (graphModel.edges.length + graphModelres.edges.length)/2 ){\n        markN = 0;\n    }\n\n    if(markN===100){\n        window.alert(`Вы верно выполнили предыдущее задание`);\n        mark_0_changing(mark_0+9+k_s[num_0]);\n    }\n\n    if(markN<100){\n        window.alert(`Вы неверно выполнили предыдущее задание`);\n    }\n}\n\nfunction StartDifficult(){\n    let new_k_s = [0,0,0,0,0,0,0,0];\n    let all_num = 0;\n    for (let i=0; i<8; i++){\n        new_k_s = k_s;\n        new_k_s[i]+=Math.round(Math.random()*99+1);\n        all_num+=new_k_s[i];\n    }\n    let true_num=0;\n    for (let i=0; i<8; i++){\n        new_k_s[i]=Math.round(39*new_k_s[i]/all_num);\n        true_num+=new_k_s[i];\n    }\n    let max_0=0;\n    let min_0=0;\n    let schetchick=true;\n    while (true_num !==39){\n        if(true_num>39){\n            max_0 = Math.max(new_k_s[0], new_k_s[1], new_k_s[2], new_k_s[3], new_k_s[4], new_k_s[5], new_k_s[6], new_k_s[7]);\n            for (let i=0; i<8; i++){\n                if (schetchick && max_0 === new_k_s[i]){\n                    new_k_s[i]--;\n                    true_num--;\n                    schetchick = false;\n                }\n            }\n            schetchick = true;\n        }\n        else{\n            min_0 = Math.min(new_k_s[0], new_k_s[1], new_k_s[2], new_k_s[3], new_k_s[4], new_k_s[5], new_k_s[6], new_k_s[7]);\n            for (let i=0; i<8; i++){\n                if (schetchick && min_0 === new_k_s[i]){\n                    new_k_s[i]++;\n                    true_num++;\n                    schetchick = false;\n                }\n            }\n            schetchick = true;\n        }\n    }\n    k_s_changing(new_k_s);\n}\n\nexport {CheckingAnswer, StartDifficult, LastCheckingAnswer};","/home/ilya/UIR/Tasks.GraphOperations/src/GraphsInit.ts",["75","76","77","78","79","80","81","82"],"import {init, init1, init2, initres} from \"./ForMyGraphModel\";\nimport {Edge, GraphGenerator, IEdge, IGraph, IVertex, Vertex} from 'graphlabs.core.graphs';\nimport {ChooseTask} from \"./Ops\";\nimport {message_0, message_0_changing, num_0, num_0_changing, message_1, message_1_changing, mark_0, mark_0_changing, k_s, k_s_changing} from './ForMeVars';\n\nfunction GraphsInit(){\n    let graph: IGraph<IVertex, IEdge>;\n    let num_vert_plus_edg = num_0<=4?(9+k_s[num_0]):(Math.round((9+k_s[num_0])/2));\n\n    graph = GraphGenerator.generate(0);\n    init(graph);\n\n    let graph1: IGraph<IVertex, IEdge>;\n    graph1 = GetNewRandomGraph(num_vert_plus_edg);\n    init1(graph1);\n\n    let graph2: IGraph<IVertex, IEdge>;\n    if(num_0<=1)\n        graph2 = GetNewRandomGraphForThatOne(num_vert_plus_edg, graph1, 0.5);\n    else if (num_0===2 || num_0===4) //\n        graph2 = GetNewRandomGraphForThatOne(num_vert_plus_edg, graph1, 0.3);\n    else //(num_0===3 || num_0===5 || num_0===6 || num_0===7 )\n        graph2 = GetNewGraphForThatOne(num_vert_plus_edg, graph1);\n\n    init2(graph2);\n\n    let graphres = ChooseTask();\n    initres(graphres);\n}\n\nfunction GetNewRandomGraph (num:number){ // рандомный граф\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    let edge_num = num - Math.round(num/2);//Math.round((Math.random()*0.15+0.85)*num/2);\n    let vert_num = num - edge_num;\n    let vert_num_help = vert_num;\n\n    while (vert_num!==0){\n        graph.addVertex(new Vertex(`${vert_num}`));\n        vert_num--;\n    }\n\n    while (edge_num!==0){\n        let v1 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+1)}`)[0];\n        let v2 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+1)}`)[0];\n        if(!v1.isAdjacent(graph,v2)){\n            graph.addEdge(new Edge(v1,v2,`${v1.name}+${v2.name}`));\n            edge_num--;\n        }\n    }\n\n    return graph;\n}\n\nfunction GetNewGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>){\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    let edge_num = num - Math.round(num/2);\n    let vert_num = num - edge_num;\n\n    let mins_vert=graph1.vertices.length;\n\n    vert_num+=mins_vert;\n    //edge_num+=graph1.edges.length; vert_num = Math.round(vert_num*percent);\n\n    let vert_num_help = vert_num;\n\n    while (vert_num!==mins_vert){\n        graph.addVertex(new Vertex(`${vert_num}`));\n        vert_num--;\n    }\n\n    while (edge_num!==0){\n        let v1 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+mins_vert)}`)[0];\n        let v2 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+mins_vert)}`)[0];\n        if(v1 && v2 && !v1.isAdjacent(graph,v2)){\n            graph.addEdge(new Edge(v1,v2,`${v1.name}+${v2.name}`));\n            edge_num--;\n        }\n    }\n\n    return graph;\n}\n\nfunction GetNewRandomGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>, percent:number){\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    let edge_num = num - Math.round(num/2);\n    let vert_num = num - edge_num;\n\n    let mins_vert=graph1.vertices.length;\n    mins_vert -= Math.round(mins_vert*percent);\n\n    vert_num+=mins_vert;\n    //edge_num+=graph1.edges.length; vert_num = Math.round(vert_num*percent);\n\n    let vert_num_help = vert_num;\n\n    while (vert_num!==mins_vert){\n        graph.addVertex(new Vertex(`${vert_num}`));\n        vert_num--;\n    }\n\n    while (edge_num!==0){\n        let v1 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+mins_vert)}`)[0];\n        let v2 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+mins_vert)}`)[0];\n        if(v1 && v2 && !v1.isAdjacent(graph,v2)){\n            graph.addEdge(new Edge(v1,v2,`${v1.name}+${v2.name}`));\n            edge_num--;\n        }\n    }\n\n    return graph;\n}\n\nexport {GraphsInit};","/home/ilya/UIR/Tasks.GraphOperations/src/ForMeVars.tsx",[],"/home/ilya/UIR/Tasks.GraphOperations/src/MyVisualizer.tsx",["83"],"import {Graph, IEdge, IGraph, IVertex} from 'graphlabs.core.graphs';\nimport * as d3 from \"d3\";\n\nfunction MyVisualizer(graph: IGraph<IVertex, IEdge>, my_class:string){\n    d3.select(`svg.${my_class}`).attr(\"width\",\"98%\").attr(\"height\",\"100%\");\n\n    if (graph.vertices.length===1){\n        window.alert(`${d3.select(`svg.${my_class}`).style(\"width\")}`);\n        d3.select(`svg.${my_class}`).append(\"svg\").attr(\"width\", \"100%\").attr(\"height\", \"100%\")\n            .append(\"circle\").attr(\"cx\", \"50%\").attr(\"cy\", \"50%\").attr(\"r\", 30)\n            .attr(\"stroke\",\"black\").attr(\"stroke-width\",5).attr(\"fill\",\"rgb(238, 238, 238)\");\n\n        d3.select(`svg.${my_class}`).select(\"svg\").append(\"text\").attr(\"x\",\"50%\").attr(\"y\",\"52%\")\n            .attr(\"text-anchor\",\"middle\").style(\"fill\",\"rgb(0, 0, 0)\").style(\"font-family\", \"sans-serif\")\n            .style(\"text-anchor\",\"middle\").style(\"padding-top\",\"50%\").style(\"padding-left\",\"25%\")\n            .style(\"padding-right\",\"25%\").text(`${graph.vertices[0].name}`);\n    }\n    else{\n        let n:number = graph.vertices.length; // number of vertices\n        let R:number = 15 * ( 1 + 1/(Math.pow(n,3/5))); // radius of vertices\n        let w:number = parseFloat(d3.select(`svg.${my_class}`).style(\"width\").slice(0,d3.select(`svg.${my_class}`).style(\"width\").length-2)); // width\n        let h:number = w; // height\n        d3.select(`svg.${my_class}`).attr(\"height\",h); // set height in html\n        let r:number = w/2-R-10; // radius of graph\n        let phi_0:number = 0; // phi 0\n        let phi_i:number = phi_0; // phi i\n        let x_0:number = w/2; // x 0\n        let y_0:number = h/2; // y 0\n        let x:number[] = [];\n        let y:number[] = [];\n        for (let i = 0; i<graph.vertices.length; i++){\n            phi_i += 360/n;\n            x[i] = x_0 - r * Math.sin(Math.PI*(2+phi_i/180));\n            y[i] = y_0 + r * Math.cos(Math.PI*(2+phi_i/180));\n\n        }\n        let i = 0;\n        let j = 0;\n        let vert_names:string[] = [];\n        graph.vertices.forEach((v:IVertex)=>{\n            vert_names[j]=v.name;\n            j++;\n        });\n        graph.edges.forEach((e:IEdge)=>{\n            //let z = Math.min(parseInt(d3.select(`svg.${my_class}`).select(`svg.vert_num_${e.vertexOne.name}`).style(\"z\")),parseInt(d3.select(`svg.${my_class}`).select(`svg.vert_num_${e.vertexTwo.name}`).style(\"z\")));\n            d3.select(`svg.${my_class}`).append(\"line\").style('stroke', 'black').attr(\"stroke-width\",5)//.style(\"z\",z-10)\n                .attr('x1', x[vert_names.indexOf(e.vertexOne.name)])\n                .attr('y1', y[vert_names.indexOf(e.vertexOne.name)])\n                .attr('x2', x[vert_names.indexOf(e.vertexTwo.name)])\n                .attr('y2', y[vert_names.indexOf(e.vertexTwo.name)]);\n        });\n        graph.vertices.forEach((v:IVertex)=>{\n            d3.select(`svg.${my_class}`).append(\"svg\").attr(\"class\",`vert_num_${v.name}`).attr(\"width\", \"100%\").attr(\"height\", \"100%\")\n                .append(\"circle\").attr(\"cx\", x[i]).attr(\"cy\", y[i]).attr(\"r\", R)\n                .attr(\"stroke\",\"black\").attr(\"stroke-width\",5).attr(\"fill\",\"rgb(238, 238, 238)\");\n            d3.select(`svg.${my_class}`).select(`svg.vert_num_${v.name}`).append(`text`).attr(\"x\",x[i]).attr(\"y\",y[i]+4) // знак = 8 пикселей в высоту, поэтому ловим середину так сказать(\n                .attr(\"text-anchor\",\"middle\").style(\"fill\",\"rgb(0, 0, 0)\").style(\"font-family\", \"sans-serif\")\n                .style(\"text-anchor\",\"middle\").style(\"padding-top\",\"50%\").style(\"padding-left\",\"25%\")\n                .style(\"padding-right\",\"25%\").text(`${v.name}`);\n            //vert_names[i]=v.name;\n            i++;\n        });\n\n    }\n}\n\nexport {MyVisualizer};",{"ruleId":"84","replacedBy":"85"},{"ruleId":"86","replacedBy":"87"},{"ruleId":"88","severity":1,"message":"89","line":1,"column":16,"nodeType":"90","messageId":"91","endLine":1,"endColumn":25},{"ruleId":"88","severity":1,"message":"92","line":2,"column":10,"nodeType":"90","messageId":"91","endLine":2,"endColumn":19},{"ruleId":"88","severity":1,"message":"93","line":5,"column":5,"nodeType":"90","messageId":"91","endLine":5,"endColumn":15},{"ruleId":"88","severity":1,"message":"94","line":8,"column":53,"nodeType":"90","messageId":"91","endLine":8,"endColumn":64},{"ruleId":"88","severity":1,"message":"95","line":8,"column":66,"nodeType":"90","messageId":"91","endLine":8,"endColumn":73},{"ruleId":"88","severity":1,"message":"96","line":8,"column":75,"nodeType":"90","messageId":"91","endLine":8,"endColumn":94},{"ruleId":"88","severity":1,"message":"97","line":10,"column":5,"nodeType":"90","messageId":"91","endLine":10,"endColumn":11},{"ruleId":"88","severity":1,"message":"98","line":11,"column":5,"nodeType":"90","messageId":"91","endLine":11,"endColumn":12},{"ruleId":"88","severity":1,"message":"99","line":16,"column":8,"nodeType":"90","messageId":"91","endLine":16,"endColumn":14},{"ruleId":"88","severity":1,"message":"100","line":18,"column":9,"nodeType":"90","messageId":"91","endLine":18,"endColumn":24},{"ruleId":"88","severity":1,"message":"101","line":23,"column":10,"nodeType":"90","messageId":"91","endLine":23,"endColumn":15},{"ruleId":"88","severity":1,"message":"102","line":23,"column":30,"nodeType":"90","messageId":"91","endLine":23,"endColumn":35},{"ruleId":"88","severity":1,"message":"103","line":23,"column":50,"nodeType":"90","messageId":"91","endLine":23,"endColumn":57},{"ruleId":"88","severity":1,"message":"104","line":23,"column":78,"nodeType":"90","messageId":"91","endLine":23,"endColumn":82},{"ruleId":"88","severity":1,"message":"105","line":24,"column":20,"nodeType":"90","messageId":"91","endLine":24,"endColumn":38},{"ruleId":"88","severity":1,"message":"106","line":24,"column":94,"nodeType":"90","messageId":"91","endLine":24,"endColumn":100},{"ruleId":"88","severity":1,"message":"107","line":25,"column":10,"nodeType":"90","messageId":"91","endLine":25,"endColumn":20},{"ruleId":"88","severity":1,"message":"108","line":29,"column":9,"nodeType":"90","messageId":"91","endLine":29,"endColumn":12},{"ruleId":"109","severity":1,"message":"110","line":185,"column":21,"nodeType":"111","endLine":185,"endColumn":35},{"ruleId":"112","severity":1,"message":"113","line":202,"column":21,"nodeType":"111","endLine":202,"endColumn":102},{"ruleId":"112","severity":1,"message":"113","line":230,"column":21,"nodeType":"111","endLine":230,"endColumn":102},{"ruleId":"88","severity":1,"message":"114","line":6,"column":17,"nodeType":"90","messageId":"91","endLine":6,"endColumn":31},{"ruleId":"84","replacedBy":"115"},{"ruleId":"86","replacedBy":"116"},{"ruleId":"88","severity":1,"message":"117","line":4,"column":9,"nodeType":"90","messageId":"91","endLine":4,"endColumn":18},{"ruleId":"88","severity":1,"message":"105","line":4,"column":20,"nodeType":"90","messageId":"91","endLine":4,"endColumn":38},{"ruleId":"88","severity":1,"message":"114","line":4,"column":47,"nodeType":"90","messageId":"91","endLine":4,"endColumn":61},{"ruleId":"88","severity":1,"message":"118","line":4,"column":63,"nodeType":"90","messageId":"91","endLine":4,"endColumn":72},{"ruleId":"88","severity":1,"message":"119","line":4,"column":74,"nodeType":"90","messageId":"91","endLine":4,"endColumn":92},{"ruleId":"88","severity":1,"message":"117","line":4,"column":9,"nodeType":"90","messageId":"91","endLine":4,"endColumn":18},{"ruleId":"88","severity":1,"message":"105","line":4,"column":20,"nodeType":"90","messageId":"91","endLine":4,"endColumn":38},{"ruleId":"88","severity":1,"message":"114","line":4,"column":47,"nodeType":"90","messageId":"91","endLine":4,"endColumn":61},{"ruleId":"88","severity":1,"message":"118","line":4,"column":63,"nodeType":"90","messageId":"91","endLine":4,"endColumn":72},{"ruleId":"88","severity":1,"message":"119","line":4,"column":74,"nodeType":"90","messageId":"91","endLine":4,"endColumn":92},{"ruleId":"88","severity":1,"message":"106","line":4,"column":94,"nodeType":"90","messageId":"91","endLine":4,"endColumn":100},{"ruleId":"88","severity":1,"message":"120","line":4,"column":102,"nodeType":"90","messageId":"91","endLine":4,"endColumn":117},{"ruleId":"88","severity":1,"message":"121","line":4,"column":124,"nodeType":"90","messageId":"91","endLine":4,"endColumn":136},{"ruleId":"88","severity":1,"message":"122","line":1,"column":9,"nodeType":"90","messageId":"91","endLine":1,"endColumn":14},"no-native-reassign",["123"],"no-negated-in-lhs",["124"],"@typescript-eslint/no-unused-vars","'FormEvent' is defined but never used.","Identifier","unusedVar","'Component' is defined but never used.","'ToolButton' is defined but never used.","'StudentMark' is defined but never used.","'Console' is defined but never used.","'graphActionCreators' is defined but never used.","'IGraph' is defined but never used.","'IVertex' is defined but never used.","'styles' is defined but never used.","'WritableAdapter' is defined but never used.","'init1' is defined but never used.","'init2' is defined but never used.","'initres' is defined but never used.","'init' is defined but never used.","'message_0_changing' is defined but never used.","'mark_0' is defined but never used.","'ChooseTask' is defined but never used.","'log' is defined but never used.","react/jsx-pascal-case","Imported JSX component T_s_shawing must be in PascalCase or SCREAMING_SNAKE_CASE","JSXOpeningElement","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","'num_0_changing' is defined but never used.",["123"],["124"],"'message_0' is defined but never used.","'message_1' is defined but never used.","'message_1_changing' is defined but never used.","'mark_0_changing' is defined but never used.","'k_s_changing' is defined but never used.","'Graph' is defined but never used.","no-global-assign","no-unsafe-negation"]