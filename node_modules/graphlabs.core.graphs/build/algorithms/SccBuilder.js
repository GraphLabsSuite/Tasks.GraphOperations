"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DirectedGraph_1 = require("../main/DirectedGraph");
var UndirectedGraph_1 = require("../main/UndirectedGraph");
var MatrixOperations_1 = require("../helpers/MatrixOperations");
/**
 * @classdesc
 * Finder of SCC
 */
var SccBuilder = /** @class */ (function () {
    function SccBuilder(graph) {
        this._graph = graph;
        this._vertices = this._graph.vertices;
        this._accessibilityMatrix = SccBuilder.buildAccessibilityMatrix(graph);
    }
    /**
     * Finds strongly connected components
     * @param graph
     * @returns {IGraph[]}
     */
    SccBuilder.findComponents = function (graph) {
        return (new SccBuilder(graph)).buildComponents();
    };
    SccBuilder.buildAdjacencyMatrix = function (graph) {
        var result = [];
        for (var i = 0; i < graph.vertices.length; i++) {
            result[i] = [];
            for (var j = 0; j < graph.vertices.length; j++) {
                if (i == j) {
                    result[i][j] = 1;
                    continue;
                }
                if (graph.vertices[j].isAdjacent(graph, graph.vertices[i])) {
                    result[i][j] = 1;
                    continue;
                }
                result[i][j] = 0;
            }
        }
        return result;
    };
    SccBuilder.buildAccessibilityMatrix = function (graph) {
        var result = [];
        var diagonal = [];
        for (var i = 0; i < graph.vertices.length; i++) {
            result[i] = [];
            diagonal[i] = [];
            for (var j = 0; j < graph.vertices.length; j++) {
                if (i == j) {
                    diagonal[i][j] = 1;
                    continue;
                }
                if (graph.vertices[j].isAdjacent(graph, graph.vertices[i])) {
                    result[i][j] = 1;
                    continue;
                }
                result[i][j] = 0;
            }
        }
        for (var i = 0; i < graph.vertices.length; i++) {
            result = MatrixOperations_1.MatrixOperations.Sum(result, MatrixOperations_1.MatrixOperations.Power(result, i));
        }
        result = MatrixOperations_1.MatrixOperations.Sum(result, diagonal);
        return result;
    };
    //TODO: кажется, тут местами можно немного проще сделать
    SccBuilder.prototype.buildComponents = function () {
        var s = [];
        for (var i = 0; i < this._graph.vertices.length; i++) {
            s[i] = [];
            for (var j = 0; j < this._graph.vertices.length; j++)
                s[i][j] = this._accessibilityMatrix[i][j] * this._accessibilityMatrix[j][i];
        }
        var added = new Array(this._graph.vertices.length);
        for (var i = 0; i < added.length; i++)
            added[i] = false;
        var components = [];
        for (var i = 0; i < this._graph.vertices.length; i++) {
            if (added[i])
                continue;
            var scc = this._graph.isDirected
                ? new DirectedGraph_1.DirectedGraph()
                : new UndirectedGraph_1.UndirectedGraph();
            // const scc: IGraph<IVertex, IEdge> = new Graph<Vertex,UndirectedEdge>();
            added[i] = true;
            scc.addVertex(this._vertices[i]);
            for (var j = 0; j < this._graph.vertices.length; j++)
                if (!added[j] && s[i][j] == 1) {
                    added[j] = true;
                    scc.addVertex(this._vertices[j]);
                }
            components.push(scc);
        }
        this._graph.edges.forEach(function (edge) {
            var whereToAdd = components.filter(function (c) { return c.vertices.indexOf(edge.vertexOne) != -1 &&
                c.vertices.indexOf(edge.vertexTwo) != -1; });
            whereToAdd.forEach(function (c) { return c.addEdge(edge); });
        });
        return components;
    };
    return SccBuilder;
}());
exports.SccBuilder = SccBuilder;
//# sourceMappingURL=SccBuilder.js.map