[{"/home/ilya/UIR/Tasks.GraphOperations/src/index.tsx":"1","/home/ilya/UIR/Tasks.GraphOperations/src/reportWebVitals.ts":"2","/home/ilya/UIR/Tasks.GraphOperations/src/App.tsx":"3","/home/ilya/UIR/Tasks.GraphOperations/src/ForMyGraphModel.ts":"4","/home/ilya/UIR/Tasks.GraphOperations/src/Ops.ts":"5","/home/ilya/UIR/Tasks.GraphOperations/src/CheckAnswer.ts":"6","/home/ilya/UIR/Tasks.GraphOperations/src/GraphsInit.ts":"7","/home/ilya/UIR/Tasks.GraphOperations/src/ForMeVars.tsx":"8"},{"size":500,"mtime":1612041338314,"results":"9","hashOfConfig":"10"},{"size":425,"mtime":1612041338322,"results":"11","hashOfConfig":"10"},{"size":12304,"mtime":1621428265056,"results":"12","hashOfConfig":"10"},{"size":1060,"mtime":1612104314915,"results":"13","hashOfConfig":"10"},{"size":13568,"mtime":1617540034049,"results":"14","hashOfConfig":"10"},{"size":4001,"mtime":1621188506235,"results":"15","hashOfConfig":"10"},{"size":3864,"mtime":1617543634700,"results":"16","hashOfConfig":"10"},{"size":1801,"mtime":1621189148333,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"zzjyth",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"20"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30","usedDeprecatedRules":"31"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"20"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"20"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"/home/ilya/UIR/Tasks.GraphOperations/src/index.tsx",[],["40","41"],"/home/ilya/UIR/Tasks.GraphOperations/src/reportWebVitals.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/App.tsx",["42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63"],"import React, {FormEvent} from 'react';\nimport { Component } from 'react';\n\nimport {\n    ToolButton,\n    ToolButtonList,/* IGraphView, IMatrixView, INGraphsView, State, ToolButton*/\n} from \"graphlabs.core.template\";\nimport { GraphVisualizer, Template, Toolbar, store, StudentMark, Console, graphActionCreators, adapter } from \"graphlabs.core.template\";\nimport {  /*Graph, SccBuilder, Vertex, Edge,*/\n    IGraph,\n    IVertex,\n    IEdge,\n    GraphGenerator,\n    Vertex\n} from \"graphlabs.core.graphs\";\nimport styles from './Template.module.scss';\nimport 'graphlabs.core.template/dist/main.css';\nimport {WritableAdapter} from \"graphlabs.core.visualizer\";\n\nimport './App.css';\n\nimport { /*Component,*/ SFC} from 'react';\nimport { init1, graphModel1, init2, graphModel2, initres, /*graphModelres,*/ init, graphModel } from './ForMyGraphModel';\nimport {message_0, message_0_changing, num_0, num_0_changing, message_1, message_1_changing, mark_0, mark_0_changing, T_s, T_s_changing, T_s_shawing } from './ForMeVars';\nimport { ChooseTask } from './Ops';\nimport { CheckingAnswer, StartDifficult, LastCheckingAnswer } from \"./CheckAnswer\";\nimport { GraphsInit } from \"./GraphsInit\"\nimport ReactDOM from \"react-dom\";\nimport {log} from \"util\";\n\nclass App extends Template {\n\n    public state = {\n        status: store.getState().app.status,\n    };\n\n    componentWillMount() {\n        StartDifficult();\n        mark_0_changing(0);\n        GraphsInit();\n\n        let timerId = setInterval(()=>{\n            T_s_changing(T_s-1);\n            ReactDOM.render(T_s_shawing(), document.getElementById(\"T_s\"));\n        }, 1000);\n        window.setTimeout(()=>{clearInterval(timerId);LastCheckingAnswer();},1000*45*60);\n    }\n\n    /*public constructor(props: {}) { // не совсем понимаю, почему овервайт этих функций происходит автоматически и без конструктора\n        super(props);\n        this.render = this.render.bind(this);\n        this.getArea = this.getArea.bind(this);\n        this.task = this.task.bind(this);\n        this.getTaskToolbar = this.getTaskToolbar.bind(this);\n    }*/\n\n    /*public render():JSX.Element {\n        const Task: any = this.task();\n        const Toolbar = this.getTaskToolbar();\n        const Area = this.getArea51();\n        return (\n            <div className={styles.App} id=\"wrap\">\n                {this.state.status\n                    ? <p>Задание выполнено. Ожидайте ответа от сервера...</p>\n                    : (\n                        <div>\n                            <div className={styles.MainRow}>\n                                <div className={styles.GraphCell}>\n                                    <Area/>\n                                </div>\n                                <div className={styles.ToolCell}>\n                                    <Toolbar/>\n                                </div>\n                                <div className={styles.TaskCell}>\n                                    <p>Задание</p>\n                                    <Task/>\n                                </div>\n                            </div>\n                            <div className={styles.LeftBottom}>\n                                <StudentMark/>\n                            </div>\n                            <div className={styles.LowRow}>\n                                <Console/>\n                            </div>\n                        </div>)}\n            </div>\n        );\n    }*/\n\n    // 1) разобраться со store, dispatch и др\n\n    // Проблема с огромным пробелом на сайте не в модуле, а в самом сайте, там проблема скорее не в flex\n\n    // пустое пространство му графами в задании тем меньше, чем больше соотношение экрана.\n\n    protected getTaskToolbar() {\n        //super.getTaskToolbar()\n\n        Toolbar.prototype.getButtonList = () => {\n            function beforeComplete(this: App):  Promise<{ success: boolean; fee: number }> {\n                return new Promise((resolve => {\n                    resolve(LastCheckingAnswer());\n                }));\n            }\n            ToolButtonList.prototype.beforeComplete = beforeComplete.bind(this);\n            ToolButtonList.prototype.help = () => `В данном задании вы должны построить результат операции, указанной в задании в правой части экрана. Для этого вы можете добавлять любое число вершин/рёбер. Также вы можете удалять любое число вершин, не инцидентных ни одному ребру или рёбер. Оценка зависит только от того, правильно ли вы построите граф.`;\n            ToolButtonList.prototype.toolButtons = {};\n\n                /*ToolButtonList.prototype.toolButtons = {\n                \"http://gl-backend.svtz.ru:5000/odata/downloadImage(name='add_vertex.png')\": () => {\n                    const start = new Date().getTime();\n                    adapter.addVertex();\n                    const end = new Date().getTime();\n                    T_s_changing(T_s - Math.round((end-start)/1000));\n                },\n            };*/\n            return ToolButtonList;\n        };\n        Toolbar.prototype.render = () => {\n            const Buttons = Toolbar.prototype.getButtonList();\n            return (\n                <div style={{marginLeft:'4px'}}>\n                    <p>Панель инструментов</p>\n                    <Buttons/>\n                    <button style={{marginTop:'4px', border: '1px double black', borderRadius:'10px', background: 'white', width:'130px', height:'46px', textAlign: 'center', font:'13pt serif'}} onClick={()=>{\n                        const start = new Date().getTime();\n                        //adapter.addVertex();\n                        graphModel.addVertex(new Vertex(`${window.prompt(\"Добавте вершину, имя вершины должно состоять из последовательности цифр.\", '0')}`));\n                        this.render();\n                        this.forceUpdate();\n                        const end = new Date().getTime();\n                        T_s_changing(T_s - Math.round((end-start)/1000));\n                    }}>Добавить<br/>вершину</button>\n                    <button style={{marginTop:'4px', border: '1px double black', borderRadius:'10px', background: 'white', width:'130px', height:'46px', textAlign: 'center', font:'13pt serif'}} onClick={()=>{\n                        const start = new Date().getTime();\n                        adapter.addEdge();\n                        graphModel.edges.forEach((e:IEdge, i=0)=>{e.name = `${i++}`;});\n                        const end = new Date().getTime();\n                        T_s_changing(T_s - Math.round((end-start)/1000));\n                    }}>Добавить<br/>ребро</button>\n                    <button style={{marginTop:'17px', border: '1px double black', borderRadius:'10px', background: 'white', width:'130px', height:'46px', textAlign: 'center', font:'13pt serif'}} onClick={()=>{\n                        const start = new Date().getTime();\n                        adapter.removeVertex();\n                        const end = new Date().getTime();\n                        T_s_changing(T_s - Math.round((end-start)/1000));\n                    }}>Удалить<br/>вершину</button>\n                    <button style={{marginTop:'4px', border: '1px double black', borderRadius:'10px', background: 'white', width:'130px', height:'46px', textAlign: 'center', font:'13pt serif'}} onClick={()=>{\n                        const start = new Date().getTime();\n                        adapter.removeEdge();\n                        const end = new Date().getTime();\n                        T_s_changing(T_s - Math.round((end-start)/1000));\n                    }}>Удалить<br/>ребро</button>\n                    <button type={\"button\"} style={{marginTop:'17px', border: '1px double black', borderRadius:'10px', background: 'white', width:'130px', height:'46px', textAlign: 'center', font:'13pt serif'}} onClick={()=> {\n                        if(window.confirm(\"Вы уверены, что хотите перейти к новой операции?\")){\n                            CheckingAnswer();\n                            num_0_changing(num_0 + 1);\n                            GraphsInit();\n                            this.forceUpdate();\n                            if (num_0 === 7) {  // удалить кнопку было бы хорошо\n                                message_1_changing(\"Завершите выполнение теста.\");\n                                this.disable();\n                            }\n                        }\n                    }}>{message_1}</button>\n                    <T_s_shawing/>\n                </div>);\n        };\n        return Toolbar;\n    }\n\n    protected disable(){\n        let element = document.getElementsByTagName('button')[0];\n        if (element != null) {\n            element.setAttribute('disabled','disabled');\n        }\n    }\n\n    protected getArea(): SFC<{}> {\n        return () =>\n            <div style={{marginLeft:'4px', marginTop:'4px'}}>\n                <p className={\"help_for_casuals\"} data-title=\"Рабочая область. В ней вы можете строить граф, являющийся результатом операции из области задания. Чтобы выделить ребро или вершину, нужно нажать на соответствующий элемент (который при выделении окрашивается в зелёный или красный соответственно).\" >\n                    <img src={\"http://gl-backend.svtz.ru:5000/odata/downloadImage(name='Help.png')\"}></img>\n                </p>\n                <GraphVisualizer\n                    graph={graphModel}\n                    adapterType={'writable'}\n                    namedEdges={false}\n                    vertexNaming={true}\n                    withoutDragging={false}\n                    edgeNaming={false}\n                    incidentEdges={false}\n                />\n            </div>\n        //return () =>\n        //    <GraphVisualizer\n        //        graph={graphModelres}\n        //        adapterType={'readable'}\n        //        namedEdges={false}\n        //        vertexNaming={false}\n        //        withoutDragging={false}\n        //        edgeNaming={false}\n        //        incidentEdges={false}\n        //    />;\n    }\n\n    protected task(): SFC<{}> {\n        return () =>\n            <div style={{marginLeft:'5px'}}>\n                <p className={\"help_for_casuals\"} data-title=\"Область задания. Здесь представлено задание, которое нужно выполнить.\" >\n                    <img src={\"http://gl-backend.svtz.ru:5000/odata/downloadImage(name='Help.png')\"}></img>\n                </p>\n                {message_0}\n                <div className={\"raph-Model-1\"}>\n                    <GraphVisualizer\n                        graph={graphModel1}\n                        adapterType={'readable'}\n                        namedEdges={false}\n                        vertexNaming={false}\n                        withoutDragging={true}\n                        edgeNaming={false}\n                        incidentEdges={false}\n                    />\n                </div>\n                <div className={\"raph-Model-2\"}>\n                    <GraphVisualizer\n                        graph={graphModel2}\n                        adapterType={'readable'}\n                        namedEdges={false}\n                        vertexNaming={false}\n                        withoutDragging={true}\n                        edgeNaming={false}\n                        incidentEdges={false}\n                    />\n                </div>\n            </div>;\n    }\n}\n\nexport default App;\n","/home/ilya/UIR/Tasks.GraphOperations/src/ForMyGraphModel.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/Ops.ts",["64"],"import './App.css';\nimport {  IGraph, IVertex, IEdge, Vertex, Edge, GraphGenerator } from \"graphlabs.core.graphs\";\nimport 'graphlabs.core.template/dist/main.css';\n\nimport { /*initres, graphModelres, init, graphModel, init1,*/ graphModel1, init2, graphModel2 } from './ForMyGraphModel';\nimport { num_0, num_0_changing, message_0_changing } from './ForMeVars';\n\nfunction ChooseTask(){\n    switch (num_0) {\n        case 0:\n            message_0_changing(\"Постройте граф, являющийся результатом пересечения двух графов.\");// вершины пересекаются\n            return Cross(graphModel1,graphModel2);\n        case 1:\n            message_0_changing(\"Постройте граф, являющийся дополнением графа.\"); // один граф\n            return Addition(graphModel1);\n        case 2:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\"); // вершины пересекаются\n            return Uni(graphModel1,graphModel2);\n        case 3:\n            message_0_changing(\"Постройте граф, являющийся результатом соединения двух графов с неперсекающимися вершинами.\"); // вершины пока не пересекаются\n            return Joint(graphModel1,graphModel2);\n        case 4:\n            message_0_changing(\"Постройте граф, являющийся результатом соединения двух графов с персекающимися вершинами.\"); // вершины пересекаются\n            return Joint_Z(graphModel1,graphModel2);\n        case 5:\n            message_0_changing(\"Постройте граф, являющийся результатом произведения двух графов.\"); // вершины пока не пересекаются\n            return Product(graphModel1,graphModel2);\n        case 6:\n            message_0_changing(\"Постройте граф, являющийся результатом композиции двух графов.\"); // вершины пока не пересекаются\n            return Composition(graphModel1,graphModel2);\n        case 7:\n            message_0_changing(\"Постройте граф, являющийся результатом декартового произведения двух графов.\"); // вершины пока не пересекаются\n            return Cartesian_Product(graphModel1,graphModel2);\n        default:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\");\n            return Uni(graphModel1,graphModel2);\n    }\n}\n\nfunction Addition(graph1: IGraph<IVertex, IEdge>){ // Дополнение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v1=>{\n        let v_res: IVertex;\n        v_res = new Vertex(`${v1.name}`);\n        graphres.addVertex(v_res);\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph1.vertices.forEach(v2=>{\n            let vv1 = v1.name;\n            let vv2 = v2.name;\n            if (v1.name !== v2.name && !(v1.isAdjacent(graph1,v2)) && !(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                let v1 = graphres.getVertex(`${vv1}`);\n                let v2 = graphres.getVertex(`${vv2}`);\n\n                let e: IEdge;\n                e = new Edge(v1[0],v2[0]);\n                graphres.addEdge(e);\n            }\n        });\n    });\n\n    let graph2: IGraph<IVertex, IEdge>;\n    graph2 = GraphGenerator.generate(0);\n    init2(graph2);\n\n\n    return graphres;\n}\n\nfunction Cross(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Пересечение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            if (v1.name === v2.name){\n                let v_res: IVertex;\n                v_res = new Vertex(`${v1.name}`);\n                graphres.addVertex(v_res);\n            }\n        });\n    });\n\n    graph1.edges.forEach(u1=>{\n        graph2.edges.forEach(u2=>{\n            if ((u1.vertexOne.name === u2.vertexOne.name && u1.vertexTwo.name === u2.vertexTwo.name) || (u1.vertexOne.name === u2.vertexTwo.name && u1.vertexTwo.name === u2.vertexOne.name)){\n                let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n                let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n\n                let e: IEdge;\n                e = new Edge(v1[0],v2[0]);\n                graphres.addEdge(e);\n            }\n        });\n    });\n\n    return graphres;\n}\n\nfunction Uni(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach((v:any)=>{\n        graphres.addVertex(v);\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.vertices.forEach((v: any)=>{\n        if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n            graphres.addVertex(v);\n        }\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph1.edges.forEach((e: any)=> {\n        let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n        let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n        let e_new: IEdge;\n        e_new = new Edge(vv1,vv2);\n        graphres.addEdge(e_new);\n    });\n    graph2.edges.forEach((e: any)=> {\n        let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n        let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n        let e_new: IEdge;\n        e_new = new Edge(vv1,vv2);\n        graphres.addEdge(e_new);\n    });\n    return graphres;\n}\n\nfunction Joint_Z(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение с пересекающимися вершинами\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach((v:any)=>{\n        graphres.addVertex(v);\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.vertices.forEach((v: any)=>{\n        if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n            graphres.addVertex(v);\n        }\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph1.vertices.forEach((v1: any)=> {\n        graph2.vertices.forEach((v2: any)=> {\n            if (!(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                let vv1 = graphres.getVertex(`${v1.name}`)[0];\n                let vv2 = graphres.getVertex(`${v2.name}`)[0];\n\n                let e: IEdge;\n                e = new Edge(vv1,vv2);\n                graphres.addEdge(e);\n            }\n        });\n    });\n    return graphres;\n}\n\nfunction Joint(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v=>{\n        graphres.addVertex(v);\n        graph2.vertices.forEach(v1=>{\n            if(!(graphres.getVertex(`${v1.name}`).length>0))\n                graphres.addVertex(v1);\n            let e: IEdge;\n            e = new Edge(v,v1);\n            graphres.addEdge(e);\n        });\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    return graphres;\n}\n\nfunction Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Произведение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name||u2.name!==v2.name){\n                        if((u1.name===v1.name)&&(v2.isAdjacent(graph2,u2))){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if((u2.name===v2.name)&&(v1.isAdjacent(graph1,u1))){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nfunction Composition(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Композиция !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name || u2.name!==v2.name){\n                        //let e_0: IEdge;\n                        //e_0=new Edge(v1,v2)\n                        if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if(v1.isAdjacent(graph1,u1)){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nfunction Cartesian_Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Декартово произведение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name || u2.name!==v2.name){\n                        //let e_0: IEdge;\n                        //e_0=new Edge(v1,v2)\n                        if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if(v1.isAdjacent(graph1,u1)){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nexport { ChooseTask };",["65","66"],"/home/ilya/UIR/Tasks.GraphOperations/src/CheckAnswer.ts",["67","68","69","70","71"],"import {graphModel, graphModelres} from \"./ForMyGraphModel\";\nimport { IVertex } from 'graphlabs.core.graphs';\nimport { store } from 'graphlabs.core.template';\nimport {message_0, message_0_changing, num_0, num_0_changing, message_1, message_1_changing, mark_0, mark_0_changing, k_s, k_s_changing} from './ForMeVars';\n\nfunction LastCheckingAnswer(){\n    mark_0_changing(Math.round(mark_0*100/(8*9+k_s[0]+k_s[1]+k_s[2]+k_s[3]+k_s[4]+k_s[5]+k_s[6]+k_s[7])));\n    window.alert(`Вы вполнили задания на оценку: ${mark_0}`);\n    //window.alert(`k_s: ${k_s}`);\n    store.getState().notifier.score = mark_0; // здесь я меняю оценку.\n    return Promise.resolve({success: mark_0 === 100, fee: mark_0});\n}\n\nfunction CheckingAnswer(){// мое добавление для проверки оценки: процент одинаковости\n    let markN = 100;\n    graphModelres.vertices.forEach((v:any)=>{ // проверка на совпадения вершин\n        if(graphModel.getVertex(v.name).length===1){\n            //markN+=50/(graphModelres.vertices.length);\n        }\n        else{\n            markN=0;\n        }\n    });\n    graphModel.vertices.forEach((v:any)=>{ // проверка на лишние вершины\n        if(graphModelres.getVertex(v.name).length===0){\n            //markN-=50/(graphModelres.vertices.length);\n            markN=0;\n        }\n    });\n\n    let num = 0;\n    graphModel.vertices.forEach((v1:IVertex)=>{\n        graphModel.vertices.forEach((v2:IVertex)=>{\n            graphModelres.vertices.forEach((u1:IVertex)=>{\n                graphModelres.vertices.forEach((u2:IVertex)=>{\n                    if( ( v1.name === u1.name && v2.name === u2.name ) || ( v1.name === u2.name && v2.name === u1.name ) ){\n                        if( v1.name !== v2.name && u1.name !== u2.name ){\n                            if( v1.isAdjacent(graphModel, v2) ){\n                                if( u1.isAdjacent(graphModelres, u2) ) {\n                                    num++;\n                                }\n                            }\n                        }\n                    }\n                });\n            });\n        });\n    });\n    num/=2*2;\n    if(num !== (graphModel.edges.length + graphModelres.edges.length)/2 ){\n        markN = 0;\n    }\n\n    if(markN===100){\n        window.alert(`Вы верно выполнили предыдущее задание`);\n        mark_0_changing(mark_0+9+k_s[num_0]);\n    }\n\n    if(markN<100){\n        window.alert(`Вы неверно выполнили предыдущее задание`);\n    }\n}\n\nfunction StartDifficult(){\n    let new_k_s = [0,0,0,0,0,0,0,0];\n    let all_num = 0;\n    for (let i=0; i<8; i++){\n        new_k_s = k_s;\n        new_k_s[i]+=Math.round(Math.random()*99+1);\n        all_num+=new_k_s[i];\n    }\n    let true_num=0;\n    for (let i=0; i<8; i++){\n        new_k_s[i]=Math.round(39*new_k_s[i]/all_num);\n        true_num+=new_k_s[i];\n    }\n    let max_0=0;\n    let min_0=0;\n    let schetchick=true;\n    while (true_num !==39){\n        if(true_num>39){\n            max_0 = Math.max(new_k_s[0], new_k_s[1], new_k_s[2], new_k_s[3], new_k_s[4], new_k_s[5], new_k_s[6], new_k_s[7]);\n            for (let i=0; i<8; i++){\n                if (schetchick && max_0 === new_k_s[i]){\n                    new_k_s[i]--;\n                    true_num--;\n                    schetchick = false;\n                }\n            }\n            schetchick = true;\n        }\n        else{\n            min_0 = Math.min(new_k_s[0], new_k_s[1], new_k_s[2], new_k_s[3], new_k_s[4], new_k_s[5], new_k_s[6], new_k_s[7]);\n            for (let i=0; i<8; i++){\n                if (schetchick && min_0 === new_k_s[i]){\n                    new_k_s[i]++;\n                    true_num++;\n                    schetchick = false;\n                }\n            }\n            schetchick = true;\n        }\n    }\n    k_s_changing(new_k_s);\n}\n\nexport {CheckingAnswer, StartDifficult, LastCheckingAnswer};","/home/ilya/UIR/Tasks.GraphOperations/src/GraphsInit.ts",["72","73","74","75","76","77","78","79"],"import {init, init1, init2, initres} from \"./ForMyGraphModel\";\nimport {Edge, GraphGenerator, IEdge, IGraph, IVertex, Vertex} from 'graphlabs.core.graphs';\nimport {ChooseTask} from \"./Ops\";\nimport {message_0, message_0_changing, num_0, num_0_changing, message_1, message_1_changing, mark_0, mark_0_changing, k_s, k_s_changing} from './ForMeVars';\n\nfunction GraphsInit(){\n    let graph: IGraph<IVertex, IEdge>;\n    let num_vert_plus_edg = num_0<=4?(9+k_s[num_0]):(Math.round((9+k_s[num_0])/2));\n\n    graph = GraphGenerator.generate(0);\n    init(graph);\n\n    let graph1: IGraph<IVertex, IEdge>;\n    graph1 = GetNewRandomGraph(num_vert_plus_edg);\n    init1(graph1);\n\n    let graph2: IGraph<IVertex, IEdge>;\n    if(num_0<=1)\n        graph2 = GetNewRandomGraphForThatOne(num_vert_plus_edg, graph1, 0.5);\n    else if (num_0===2 || num_0===4) //\n        graph2 = GetNewRandomGraphForThatOne(num_vert_plus_edg, graph1, 0.3);\n    else //(num_0===3 || num_0===5 || num_0===6 || num_0===7 )\n        graph2 = GetNewGraphForThatOne(num_vert_plus_edg, graph1);\n\n    init2(graph2);\n\n    let graphres = ChooseTask();\n    initres(graphres);\n}\n\nfunction GetNewRandomGraph (num:number){ // рандомный граф\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    let edge_num = num - Math.round(num/2);//Math.round((Math.random()*0.15+0.85)*num/2);\n    let vert_num = num - edge_num;\n    let vert_num_help = vert_num;\n\n    while (vert_num!==0){\n        graph.addVertex(new Vertex(`${vert_num}`));\n        vert_num--;\n    }\n\n    while (edge_num!==0){\n        let v1 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+1)}`)[0];\n        let v2 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+1)}`)[0];\n        if(!v1.isAdjacent(graph,v2)){\n            graph.addEdge(new Edge(v1,v2,`${v1.name}+${v2.name}`));\n            edge_num--;\n        }\n    }\n\n    return graph;\n}\n\nfunction GetNewGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>){\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    let edge_num = num - Math.round(num/2);\n    let vert_num = num - edge_num;\n\n    let mins_vert=graph1.vertices.length;\n\n    vert_num+=mins_vert;\n    //edge_num+=graph1.edges.length; vert_num = Math.round(vert_num*percent);\n\n    let vert_num_help = vert_num;\n\n    while (vert_num!==mins_vert){\n        graph.addVertex(new Vertex(`${vert_num}`));\n        vert_num--;\n    }\n\n    while (edge_num!==0){\n        let v1 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+mins_vert)}`)[0];\n        let v2 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+mins_vert)}`)[0];\n        if(v1 && v2 && !v1.isAdjacent(graph,v2)){\n            graph.addEdge(new Edge(v1,v2,`${v1.name}+${v2.name}`));\n            edge_num--;\n        }\n    }\n\n    return graph;\n}\n\nfunction GetNewRandomGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>, percent:number){\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    let edge_num = num - Math.round(num/2);\n    let vert_num = num - edge_num;\n\n    let mins_vert=graph1.vertices.length;\n    mins_vert -= Math.round(mins_vert*percent);\n\n    vert_num+=mins_vert;\n    //edge_num+=graph1.edges.length; vert_num = Math.round(vert_num*percent);\n\n    let vert_num_help = vert_num;\n\n    while (vert_num!==mins_vert){\n        graph.addVertex(new Vertex(`${vert_num}`));\n        vert_num--;\n    }\n\n    while (edge_num!==0){\n        let v1 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+mins_vert)}`)[0];\n        let v2 = graph.getVertex(`${Math.round(Math.random()*(vert_num_help-1)+mins_vert)}`)[0];\n        if(v1 && v2 && !v1.isAdjacent(graph,v2)){\n            graph.addEdge(new Edge(v1,v2,`${v1.name}+${v2.name}`));\n            edge_num--;\n        }\n    }\n\n    return graph;\n}\n\nexport {GraphsInit};","/home/ilya/UIR/Tasks.GraphOperations/src/ForMeVars.tsx",[],{"ruleId":"80","replacedBy":"81"},{"ruleId":"82","replacedBy":"83"},{"ruleId":"84","severity":1,"message":"85","line":1,"column":16,"nodeType":"86","messageId":"87","endLine":1,"endColumn":25},{"ruleId":"84","severity":1,"message":"88","line":2,"column":10,"nodeType":"86","messageId":"87","endLine":2,"endColumn":19},{"ruleId":"84","severity":1,"message":"89","line":5,"column":5,"nodeType":"86","messageId":"87","endLine":5,"endColumn":15},{"ruleId":"84","severity":1,"message":"90","line":8,"column":53,"nodeType":"86","messageId":"87","endLine":8,"endColumn":64},{"ruleId":"84","severity":1,"message":"91","line":8,"column":66,"nodeType":"86","messageId":"87","endLine":8,"endColumn":73},{"ruleId":"84","severity":1,"message":"92","line":8,"column":75,"nodeType":"86","messageId":"87","endLine":8,"endColumn":94},{"ruleId":"84","severity":1,"message":"93","line":10,"column":5,"nodeType":"86","messageId":"87","endLine":10,"endColumn":11},{"ruleId":"84","severity":1,"message":"94","line":11,"column":5,"nodeType":"86","messageId":"87","endLine":11,"endColumn":12},{"ruleId":"84","severity":1,"message":"95","line":13,"column":5,"nodeType":"86","messageId":"87","endLine":13,"endColumn":19},{"ruleId":"84","severity":1,"message":"96","line":16,"column":8,"nodeType":"86","messageId":"87","endLine":16,"endColumn":14},{"ruleId":"84","severity":1,"message":"97","line":18,"column":9,"nodeType":"86","messageId":"87","endLine":18,"endColumn":24},{"ruleId":"84","severity":1,"message":"98","line":23,"column":10,"nodeType":"86","messageId":"87","endLine":23,"endColumn":15},{"ruleId":"84","severity":1,"message":"99","line":23,"column":30,"nodeType":"86","messageId":"87","endLine":23,"endColumn":35},{"ruleId":"84","severity":1,"message":"100","line":23,"column":50,"nodeType":"86","messageId":"87","endLine":23,"endColumn":57},{"ruleId":"84","severity":1,"message":"101","line":23,"column":78,"nodeType":"86","messageId":"87","endLine":23,"endColumn":82},{"ruleId":"84","severity":1,"message":"102","line":24,"column":20,"nodeType":"86","messageId":"87","endLine":24,"endColumn":38},{"ruleId":"84","severity":1,"message":"103","line":24,"column":94,"nodeType":"86","messageId":"87","endLine":24,"endColumn":100},{"ruleId":"84","severity":1,"message":"104","line":25,"column":10,"nodeType":"86","messageId":"87","endLine":25,"endColumn":20},{"ruleId":"84","severity":1,"message":"105","line":29,"column":9,"nodeType":"86","messageId":"87","endLine":29,"endColumn":12},{"ruleId":"106","severity":1,"message":"107","line":165,"column":21,"nodeType":"108","endLine":165,"endColumn":35},{"ruleId":"109","severity":1,"message":"110","line":182,"column":21,"nodeType":"108","endLine":182,"endColumn":102},{"ruleId":"109","severity":1,"message":"110","line":210,"column":21,"nodeType":"108","endLine":210,"endColumn":102},{"ruleId":"84","severity":1,"message":"111","line":6,"column":17,"nodeType":"86","messageId":"87","endLine":6,"endColumn":31},{"ruleId":"80","replacedBy":"112"},{"ruleId":"82","replacedBy":"113"},{"ruleId":"84","severity":1,"message":"114","line":4,"column":9,"nodeType":"86","messageId":"87","endLine":4,"endColumn":18},{"ruleId":"84","severity":1,"message":"102","line":4,"column":20,"nodeType":"86","messageId":"87","endLine":4,"endColumn":38},{"ruleId":"84","severity":1,"message":"111","line":4,"column":47,"nodeType":"86","messageId":"87","endLine":4,"endColumn":61},{"ruleId":"84","severity":1,"message":"115","line":4,"column":63,"nodeType":"86","messageId":"87","endLine":4,"endColumn":72},{"ruleId":"84","severity":1,"message":"116","line":4,"column":74,"nodeType":"86","messageId":"87","endLine":4,"endColumn":92},{"ruleId":"84","severity":1,"message":"114","line":4,"column":9,"nodeType":"86","messageId":"87","endLine":4,"endColumn":18},{"ruleId":"84","severity":1,"message":"102","line":4,"column":20,"nodeType":"86","messageId":"87","endLine":4,"endColumn":38},{"ruleId":"84","severity":1,"message":"111","line":4,"column":47,"nodeType":"86","messageId":"87","endLine":4,"endColumn":61},{"ruleId":"84","severity":1,"message":"115","line":4,"column":63,"nodeType":"86","messageId":"87","endLine":4,"endColumn":72},{"ruleId":"84","severity":1,"message":"116","line":4,"column":74,"nodeType":"86","messageId":"87","endLine":4,"endColumn":92},{"ruleId":"84","severity":1,"message":"103","line":4,"column":94,"nodeType":"86","messageId":"87","endLine":4,"endColumn":100},{"ruleId":"84","severity":1,"message":"117","line":4,"column":102,"nodeType":"86","messageId":"87","endLine":4,"endColumn":117},{"ruleId":"84","severity":1,"message":"118","line":4,"column":124,"nodeType":"86","messageId":"87","endLine":4,"endColumn":136},"no-native-reassign",["119"],"no-negated-in-lhs",["120"],"@typescript-eslint/no-unused-vars","'FormEvent' is defined but never used.","Identifier","unusedVar","'Component' is defined but never used.","'ToolButton' is defined but never used.","'StudentMark' is defined but never used.","'Console' is defined but never used.","'graphActionCreators' is defined but never used.","'IGraph' is defined but never used.","'IVertex' is defined but never used.","'GraphGenerator' is defined but never used.","'styles' is defined but never used.","'WritableAdapter' is defined but never used.","'init1' is defined but never used.","'init2' is defined but never used.","'initres' is defined but never used.","'init' is defined but never used.","'message_0_changing' is defined but never used.","'mark_0' is defined but never used.","'ChooseTask' is defined but never used.","'log' is defined but never used.","react/jsx-pascal-case","Imported JSX component T_s_shawing must be in PascalCase or SCREAMING_SNAKE_CASE","JSXOpeningElement","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","'num_0_changing' is defined but never used.",["119"],["120"],"'message_0' is defined but never used.","'message_1' is defined but never used.","'message_1_changing' is defined but never used.","'mark_0_changing' is defined but never used.","'k_s_changing' is defined but never used.","no-global-assign","no-unsafe-negation"]