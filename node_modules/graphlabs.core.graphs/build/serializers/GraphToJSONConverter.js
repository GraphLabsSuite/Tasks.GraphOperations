"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var VertexToJSONConverter_1 = require("./VertexToJSONConverter");
var EdgeToJSONConverter_1 = require("./EdgeToJSONConverter");
var DirectedWeightedGraph_1 = require("../main/DirectedWeightedGraph");
var DirectedGraph_1 = require("../main/DirectedGraph");
var UndirectedGraph_1 = require("../main/UndirectedGraph");
var GraphToJSONConverter = /** @class */ (function () {
    function GraphToJSONConverter() {
    }
    GraphToJSONConverter.convert = function (graph) {
        return {
            isDirected: graph.isDirected,
            weighted: graph instanceof DirectedWeightedGraph_1.DirectedWeightedGraph,
            vertices: graph.vertices.map(function (v) { return VertexToJSONConverter_1.VertexToJSONConverter.convert(v); }),
            edges: graph.edges.map(function (e) { return EdgeToJSONConverter_1.EdgeToJSONConverter.convert(e); })
        };
    };
    GraphToJSONConverter.convertBack = function (graph) {
        var result;
        if (graph.isDirected) {
            if (graph.weighted) {
                result = new DirectedWeightedGraph_1.DirectedWeightedGraph();
            }
            else {
                result = new DirectedGraph_1.DirectedGraph();
            }
        }
        else {
            result = new UndirectedGraph_1.UndirectedGraph();
        }
        graph.vertices.forEach(function (v) { return result.addVertex(VertexToJSONConverter_1.VertexToJSONConverter.convertBack(v, result)); });
        graph.edges.forEach(function (e) { return result.addEdge(EdgeToJSONConverter_1.EdgeToJSONConverter.convertBack(e, result)); });
        return result;
    };
    return GraphToJSONConverter;
}());
exports.GraphToJSONConverter = GraphToJSONConverter;
//# sourceMappingURL=GraphToJSONConverter.js.map