"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Checker of the two graphs isomorphism
 */
var IsomorphismChecker = /** @class */ (function () {
    function IsomorphismChecker() {
    }
    //Not sure this is the right way to emulate generators working
    IsomorphismChecker.permute = function (vertices, pre) {
        if (pre === void 0) { pre = []; }
        var result = [];
        if (vertices.length == 0)
            return pre;
        var _loop_1 = function (i) {
            var tmp_vertices = [];
            vertices.forEach(function (v) {
                if (!v.equals(vertices[i]))
                    tmp_vertices.push(v);
            });
            var tmpParams = [];
            pre.forEach(function (v) { return tmpParams.push(v); });
            tmpParams.push([vertices[i]]);
            for (var _i = 0, _a = this_1.permute(tmp_vertices, tmpParams); _i < _a.length; _i++) {
                var y = _a[_i];
                result.push(y);
            }
        };
        var this_1 = this;
        for (var i = 0; i < vertices.length; i++) {
            _loop_1(i);
        }
        return result;
    };
    IsomorphismChecker.updateBijection = function (verticesOne, verticesTwo) {
        IsomorphismChecker.bijection = {};
        verticesTwo.forEach(function (a) {
            verticesOne.map(function (b) {
                IsomorphismChecker.bijection[a.name] = b.name;
            });
        });
    };
    IsomorphismChecker.compareHelper = function (vertexOne, vertexTwo) {
        return vertexOne.name == IsomorphismChecker.bijection[vertexTwo.name];
    };
    IsomorphismChecker.directCompare = function (graphOne, graphTwo) {
        var equals = 0;
        var count = graphOne.edges.length;
        for (var i = 0; i < count; i++)
            for (var j = 0; j < count; j++)
                if (IsomorphismChecker.compareHelper(graphOne.edges[i].vertexOne, graphTwo.edges[j].vertexOne) &&
                    IsomorphismChecker.compareHelper(graphOne.edges[i].vertexTwo, graphTwo.edges[j].vertexTwo) ||
                    (IsomorphismChecker.compareHelper(graphOne.edges[i].vertexTwo, graphTwo.edges[j].vertexOne) &&
                        IsomorphismChecker.compareHelper(graphOne.edges[i].vertexOne, graphTwo.edges[j].vertexTwo))) {
                    equals++;
                    break;
                }
        return equals == count;
    };
    IsomorphismChecker.checkIsomorphism = function (graphOne, graphTwo) {
        if (graphOne.vertices.length != graphTwo.vertices.length || graphOne.edges.length != graphTwo.edges.length)
            return false;
        IsomorphismChecker.permute(graphOne.vertices).forEach(function (perm) {
            IsomorphismChecker.updateBijection(perm, graphTwo.vertices);
            if (IsomorphismChecker.directCompare(graphOne, graphTwo))
                return true;
        });
        return false;
    };
    return IsomorphismChecker;
}());
exports.IsomorphismChecker = IsomorphismChecker;
//# sourceMappingURL=IsomorphismChecker.js.map