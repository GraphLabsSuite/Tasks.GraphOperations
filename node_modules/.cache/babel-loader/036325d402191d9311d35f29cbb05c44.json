{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar State_1 = require(\"../util/State\");\n\nvar CheckSet_1 = require(\"../util/CheckSet\");\n\nvar StateColor_1 = require(\"../enums/StateColor\");\n/**\r\n * @classdesc\r\n * Minimal dominating sets evaluator\r\n */\n\n\nvar MinDSEvaluator =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   * @param graph\r\n   */\n  function MinDSEvaluator(graph) {\n    this._minDs = [];\n    this._delta = 0;\n    this._n = graph.vertices.length;\n    var tempDs = [];\n\n    for (var i = 0; i < this._n; i++) {\n      tempDs.push(graph.vertices[i]);\n      var tempDelta = 0;\n\n      for (var j = 0; j < this._n; j++) {\n        if (graph.vertices[i].isAdjacent(graph, graph.vertices[j])) tempDelta++;\n      }\n\n      if (tempDelta > this._delta) this._delta = tempDelta;\n    }\n\n    this._minDs.push(tempDs);\n  }\n\n  MinDSEvaluator.prototype.evaluate = function (graph, flag) {\n    var firstStep = new State_1.State(graph);\n    this.process(firstStep, graph, flag);\n    return this._minDs;\n  };\n  /**\r\n   * Checks whether there are vertices could not be covered by red vertex in this context\r\n   * @param vertex\r\n   * @param state\r\n   * @returns {boolean}\r\n   */\n\n\n  MinDSEvaluator.prototype.canVertexBeCovered = function (vertex, state) {\n    var neighbors = state.vertexNeighbors(vertex);\n    var vertDomNum = state.vertexPossibleDominatingNumber(vertex);\n    if (vertDomNum == 0) return false;\n    if (neighbors != null) for (var _i = 0, neighbors_1 = neighbors; _i < neighbors_1.length; _i++) {\n      var neigh = neighbors_1[_i];\n      var neighVertDomNum = state.vertexPossibleDominatingNumber(neigh);\n      if (neighVertDomNum == 0) return false;\n    }\n    return true;\n  };\n  /**\r\n   * Checks whether all vertices can be dominated by anyone\r\n   * @param state\r\n   * @returns {boolean}\r\n   */\n\n\n  MinDSEvaluator.prototype.canVerticesBeCovered = function (state) {\n    for (var _i = 0, _a = state.vertexPossibleDominatingNumberValues(); _i < _a.length; _i++) {\n      var value = _a[_i];\n      if (value == 0) return false;\n    }\n\n    return true;\n  };\n\n  MinDSEvaluator.prototype.recountNDominated = function (state) {\n    var result = 0;\n\n    for (var _i = 0, _a = state.vertexDominatedNumberValues(); _i < _a.length; _i++) {\n      var value = _a[_i];\n      if (value > 0) result++;\n    }\n\n    return result;\n  };\n\n  MinDSEvaluator.prototype.blueVertexRecount = function (state, givenVertex) {\n    var neighbors = state.vertexNeighbors(givenVertex);\n    state.decrementVertexPossibleDominatingNumber(givenVertex);\n    if (neighbors != []) for (var _i = 0, neighbors_2 = neighbors; _i < neighbors_2.length; _i++) {\n      var vertex = neighbors_2[_i];\n      state.decrementVertexPossibleDominatingNumber(vertex);\n    }\n  };\n\n  MinDSEvaluator.prototype.redVertexRecount = function (state, givenVertex) {\n    state.incrementVertexPossibleDominatingNumber(givenVertex);\n    state.incrementVertexDominatedNumber(givenVertex);\n\n    for (var _i = 0, _a = state.vertexNeighbors(givenVertex); _i < _a.length; _i++) {\n      var vertex = _a[_i];\n      state.incrementVertexPossibleDominatingNumber(vertex);\n      state.incrementVertexDominatedNumber(vertex);\n    }\n\n    state.nDominated = this.recountNDominated(state);\n  };\n\n  MinDSEvaluator.prototype.process = function (givenState, graph, flag) {\n    var _this = this;\n\n    if (givenState.level == this._n) {\n      var isAllVerticesCovered = this.canVerticesBeCovered(givenState);\n\n      if (isAllVerticesCovered) {\n        if (flag) {\n          if (this._minDs[0].length > givenState.tempDs.length) {\n            this._minDs.forEach(function (d) {\n              return _this._minDs.pop();\n            });\n\n            this._minDs.push(givenState.tempDs);\n\n            return;\n          }\n\n          if (this._minDs[0].length == givenState.tempDs.length) {\n            this._minDs.push(givenState.tempDs);\n\n            return;\n          }\n        } else {\n          var checker = new CheckSet_1.CheckSet();\n\n          if (checker.isMinimal(givenState.tempDs, graph)) {\n            this._minDs.push(givenState.tempDs);\n          }\n        }\n      }\n    } else {\n      var givenVertex = graph.vertices[givenState.level];\n      givenState.setVertexColor(givenVertex, StateColor_1.StateColor.BLUE);\n      this.blueVertexRecount(givenState, givenVertex);\n      var isVertexCovered = this.canVertexBeCovered(givenVertex, givenState);\n\n      if (isVertexCovered) {\n        var newState = givenState.clone();\n        newState.level++;\n        this.process(newState, graph, flag);\n      }\n\n      givenState.setVertexColor(givenVertex, StateColor_1.StateColor.RED);\n      givenState.tempDs.push(givenVertex);\n      this.redVertexRecount(givenState, givenVertex);\n\n      if (givenState.nDominated == this._n) {\n        if (flag) {\n          if (this._minDs[0].length > givenState.tempDs.length) {\n            this._minDs.forEach(function (d) {\n              return _this._minDs.pop();\n            });\n\n            this._minDs.push(givenState.tempDs);\n\n            return;\n          }\n\n          if (this._minDs[0].length == givenState.tempDs.length) {\n            this._minDs.push(givenState.tempDs);\n\n            return;\n          }\n        } else {\n          var checker = new CheckSet_1.CheckSet();\n          if (checker.isMinimal(givenState.tempDs, graph)) this._minDs.push(givenState.tempDs);\n        }\n      } else {\n        if (flag) {\n          var nExtra = (this._n - givenState.nDominated) / (this._delta + 1);\n          if (nExtra + givenState.tempDs.length > this._minDs[0].length) return;else {\n            var newState = givenState.clone();\n            newState.level++;\n            this.process(newState, graph, flag);\n            return;\n          }\n        } else {\n          var newState = givenState.clone();\n          newState.level++;\n          this.process(newState, graph, flag);\n          return;\n        }\n      }\n    }\n  };\n\n  return MinDSEvaluator;\n}();\n\nexports.MinDSEvaluator = MinDSEvaluator;","map":{"version":3,"sources":["../../src/algorithms/MinDSEvaluator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar State_1 = require(\"../util/State\");\r\nvar CheckSet_1 = require(\"../util/CheckSet\");\r\nvar StateColor_1 = require(\"../enums/StateColor\");\r\n/**\r\n * @classdesc\r\n * Minimal dominating sets evaluator\r\n */\r\nvar MinDSEvaluator = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     * @param graph\r\n     */\r\n    function MinDSEvaluator(graph) {\r\n        this._minDs = [];\r\n        this._delta = 0;\r\n        this._n = graph.vertices.length;\r\n        var tempDs = [];\r\n        for (var i = 0; i < this._n; i++) {\r\n            tempDs.push(graph.vertices[i]);\r\n            var tempDelta = 0;\r\n            for (var j = 0; j < this._n; j++) {\r\n                if (graph.vertices[i].isAdjacent(graph, graph.vertices[j]))\r\n                    tempDelta++;\r\n            }\r\n            if (tempDelta > this._delta)\r\n                this._delta = tempDelta;\r\n        }\r\n        this._minDs.push(tempDs);\r\n    }\r\n    MinDSEvaluator.prototype.evaluate = function (graph, flag) {\r\n        var firstStep = new State_1.State(graph);\r\n        this.process(firstStep, graph, flag);\r\n        return this._minDs;\r\n    };\r\n    /**\r\n     * Checks whether there are vertices could not be covered by red vertex in this context\r\n     * @param vertex\r\n     * @param state\r\n     * @returns {boolean}\r\n     */\r\n    MinDSEvaluator.prototype.canVertexBeCovered = function (vertex, state) {\r\n        var neighbors = state.vertexNeighbors(vertex);\r\n        var vertDomNum = state.vertexPossibleDominatingNumber(vertex);\r\n        if (vertDomNum == 0)\r\n            return false;\r\n        if (neighbors != null)\r\n            for (var _i = 0, neighbors_1 = neighbors; _i < neighbors_1.length; _i++) {\r\n                var neigh = neighbors_1[_i];\r\n                var neighVertDomNum = state.vertexPossibleDominatingNumber(neigh);\r\n                if (neighVertDomNum == 0)\r\n                    return false;\r\n            }\r\n        return true;\r\n    };\r\n    /**\r\n     * Checks whether all vertices can be dominated by anyone\r\n     * @param state\r\n     * @returns {boolean}\r\n     */\r\n    MinDSEvaluator.prototype.canVerticesBeCovered = function (state) {\r\n        for (var _i = 0, _a = state.vertexPossibleDominatingNumberValues(); _i < _a.length; _i++) {\r\n            var value = _a[_i];\r\n            if (value == 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    MinDSEvaluator.prototype.recountNDominated = function (state) {\r\n        var result = 0;\r\n        for (var _i = 0, _a = state.vertexDominatedNumberValues(); _i < _a.length; _i++) {\r\n            var value = _a[_i];\r\n            if (value > 0)\r\n                result++;\r\n        }\r\n        return result;\r\n    };\r\n    MinDSEvaluator.prototype.blueVertexRecount = function (state, givenVertex) {\r\n        var neighbors = state.vertexNeighbors(givenVertex);\r\n        state.decrementVertexPossibleDominatingNumber(givenVertex);\r\n        if (neighbors != [])\r\n            for (var _i = 0, neighbors_2 = neighbors; _i < neighbors_2.length; _i++) {\r\n                var vertex = neighbors_2[_i];\r\n                state.decrementVertexPossibleDominatingNumber(vertex);\r\n            }\r\n    };\r\n    MinDSEvaluator.prototype.redVertexRecount = function (state, givenVertex) {\r\n        state.incrementVertexPossibleDominatingNumber(givenVertex);\r\n        state.incrementVertexDominatedNumber(givenVertex);\r\n        for (var _i = 0, _a = state.vertexNeighbors(givenVertex); _i < _a.length; _i++) {\r\n            var vertex = _a[_i];\r\n            state.incrementVertexPossibleDominatingNumber(vertex);\r\n            state.incrementVertexDominatedNumber(vertex);\r\n        }\r\n        state.nDominated = this.recountNDominated(state);\r\n    };\r\n    MinDSEvaluator.prototype.process = function (givenState, graph, flag) {\r\n        var _this = this;\r\n        if (givenState.level == this._n) {\r\n            var isAllVerticesCovered = this.canVerticesBeCovered(givenState);\r\n            if (isAllVerticesCovered) {\r\n                if (flag) {\r\n                    if (this._minDs[0].length > givenState.tempDs.length) {\r\n                        this._minDs.forEach(function (d) { return _this._minDs.pop(); });\r\n                        this._minDs.push(givenState.tempDs);\r\n                        return;\r\n                    }\r\n                    if (this._minDs[0].length == givenState.tempDs.length) {\r\n                        this._minDs.push(givenState.tempDs);\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    var checker = new CheckSet_1.CheckSet();\r\n                    if (checker.isMinimal(givenState.tempDs, graph)) {\r\n                        this._minDs.push(givenState.tempDs);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var givenVertex = graph.vertices[givenState.level];\r\n            givenState.setVertexColor(givenVertex, StateColor_1.StateColor.BLUE);\r\n            this.blueVertexRecount(givenState, givenVertex);\r\n            var isVertexCovered = this.canVertexBeCovered(givenVertex, givenState);\r\n            if (isVertexCovered) {\r\n                var newState = givenState.clone();\r\n                newState.level++;\r\n                this.process(newState, graph, flag);\r\n            }\r\n            givenState.setVertexColor(givenVertex, StateColor_1.StateColor.RED);\r\n            givenState.tempDs.push(givenVertex);\r\n            this.redVertexRecount(givenState, givenVertex);\r\n            if (givenState.nDominated == this._n) {\r\n                if (flag) {\r\n                    if (this._minDs[0].length > givenState.tempDs.length) {\r\n                        this._minDs.forEach(function (d) { return _this._minDs.pop(); });\r\n                        this._minDs.push(givenState.tempDs);\r\n                        return;\r\n                    }\r\n                    if (this._minDs[0].length == givenState.tempDs.length) {\r\n                        this._minDs.push(givenState.tempDs);\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    var checker = new CheckSet_1.CheckSet();\r\n                    if (checker.isMinimal(givenState.tempDs, graph))\r\n                        this._minDs.push(givenState.tempDs);\r\n                }\r\n            }\r\n            else {\r\n                if (flag) {\r\n                    var nExtra = (this._n - givenState.nDominated) / (this._delta + 1);\r\n                    if ((nExtra + givenState.tempDs.length) > this._minDs[0].length)\r\n                        return;\r\n                    else {\r\n                        var newState = givenState.clone();\r\n                        newState.level++;\r\n                        this.process(newState, graph, flag);\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    var newState = givenState.clone();\r\n                    newState.level++;\r\n                    this.process(newState, graph, flag);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return MinDSEvaluator;\r\n}());\r\nexports.MinDSEvaluator = MinDSEvaluator;\r\n//# sourceMappingURL=MinDSEvaluator.js.map"]},"metadata":{},"sourceType":"script"}