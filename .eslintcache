[{"/home/ilya/UIR/Tasks.GraphOperations/src/index.tsx":"1","/home/ilya/UIR/Tasks.GraphOperations/src/reportWebVitals.ts":"2","/home/ilya/UIR/Tasks.GraphOperations/src/App.tsx":"3","/home/ilya/UIR/Tasks.GraphOperations/src/ForMyGraphModel.ts":"4","/home/ilya/UIR/Tasks.GraphOperations/src/ForMeVars.ts":"5","/home/ilya/UIR/Tasks.GraphOperations/src/Ops.ts":"6","/home/ilya/UIR/Tasks.GraphOperations/src/CheckAnswer.ts":"7","/home/ilya/UIR/Tasks.GraphOperations/src/GraphsInit.ts":"8"},{"size":500,"mtime":1612041338314,"results":"9","hashOfConfig":"10"},{"size":425,"mtime":1612041338322,"results":"11","hashOfConfig":"10"},{"size":8376,"mtime":1615498513867,"results":"12","hashOfConfig":"10"},{"size":1060,"mtime":1612104314915,"results":"13","hashOfConfig":"10"},{"size":450,"mtime":1615497526441,"results":"14","hashOfConfig":"10"},{"size":15007,"mtime":1615483329664,"results":"15","hashOfConfig":"10"},{"size":3015,"mtime":1612416283995,"results":"16","hashOfConfig":"10"},{"size":631,"mtime":1615481714693,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"zzjyth",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"32"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"/home/ilya/UIR/Tasks.GraphOperations/src/index.tsx",[],["37","38"],"/home/ilya/UIR/Tasks.GraphOperations/src/reportWebVitals.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/App.tsx",["39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56"],"/home/ilya/UIR/Tasks.GraphOperations/src/ForMyGraphModel.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/ForMeVars.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/Ops.ts",["57"],"import './App.css';\nimport {  IGraph, IVertex, IEdge, Vertex, Edge, GraphGenerator } from \"graphlabs.core.graphs\";\nimport 'graphlabs.core.template/dist/main.css';\n\nimport { /*initres, graphModelres, init, graphModel, init1,*/ graphModel1, init2, graphModel2 } from './ForMyGraphModel';\nimport { num_0, num_0_changing, message_0_changing } from './ForMeVars';\n\nfunction ChooseTask(){\n    //num_0_changing(1);//Math.round(Math.random() * 100)%7);\n    switch (num_0) {\n        case 0:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\");\n            return Uni(graphModel1,graphModel2);\n        case 1:\n            message_0_changing(\"Постройте граф, являющийся результатом соединения двух графов.\");\n            return Joint(graphModel1,graphModel2);\n        case 2:\n            message_0_changing(\"Постройте граф, являющийся результатом произведения двух графов.\");\n            return Product(graphModel1,graphModel2);\n        case 3:\n            message_0_changing(\"Постройте граф, являющийся результатом композиции двух графов.\");\n            return Composition(graphModel1,graphModel2);\n        case 4:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения по Зыкову двух графов.\");// Объединение по Зыкову\n            return Uni_Z(graphModel1,graphModel2);\n        case 5:\n            message_0_changing(\"Постройте граф, являющийся результатом пересечения двух графов.\");// Пересечение\n            return Cross(graphModel1,graphModel2);\n        case 6:\n            message_0_changing(\"Постройте граф, являющийся дополнением графа.\"); // Дополнение\n            return Addition(graphModel1);\n        case 7:\n            message_0_changing(\"Постройте граф, являющийся результатом декартового произведения двух графов.\");// Декартово произведение\n            return Cartesian_Product(graphModel1,graphModel2);\n        default:\n            message_0_changing(\"Постройте граф, являющийся результатом объединения двух графов.\");\n            return Uni(graphModel1,graphModel2);\n    }\n}\n\nfunction GetNewRandomGraph (num:number){ // рандомный граф\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    var arr = [];\n    for(var i = 0; i<num; i++ ){\n        arr.push(Math.round(Math.random()));\n        if(arr[i]===1){\n            let vert = new Vertex(`${i}`);\n            graph.addVertex(vert);\n        }\n    }\n    for(var k=0;k<num-1;k++){\n        if(arr[k]===1) {\n            for(var j = k+1;j<num;j++){\n                if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge k+j\n                    let edge = new Edge(graph.getVertex(`${k}`)[0],graph.getVertex(`${j}`)[0],`${k}+${j}`);\n                    graph.addEdge(edge);\n                }\n            }\n        }\n    }\n    return graph;\n}\n\nfunction GetNewRandomGraphForThatOne (num:number, graph1:IGraph<IVertex, IEdge>){ // рандомный, не имеющий общих вершин с первым\n    let graph: IGraph<IVertex, IEdge>;\n    graph = GraphGenerator.generate(0);\n    var arr = [];\n    let length = graph1.vertices.length+1;\n    for(var i = 0; i<num; i++ ){\n        arr.push(Math.round(Math.random()));\n        if(arr[i]===1){\n            let vert = new Vertex(`${i+length}`);\n            graph.addVertex(vert);\n        }\n    }\n    for(var k=0;k<num-1;k++){\n        if(arr[k]===1) {\n            for(var j = k+1;j<num;j++){\n                if(arr[j]===1 && Math.random()>0.45 ){ // 55% chance what is edge k+j\n                    let edge = new Edge(graph.getVertex(`${k+length}`)[0],graph.getVertex(`${j+length}`)[0],`${k+length}+${j+length}`);\n                    graph.addEdge(edge);\n                }\n            }\n        }\n    }\n    return graph;\n}\n\nfunction Uni(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach((v:any)=>{\n        graphres.addVertex(v);\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.vertices.forEach((v: any)=>{\n        if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n            graphres.addVertex(v);\n        }\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph1.edges.forEach((e: any)=> {\n        let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n        let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n        let e_new: IEdge;\n        e_new = new Edge(vv1,vv2);\n        graphres.addEdge(e_new);\n    });\n    graph2.edges.forEach((e: any)=> {\n        let vv1 = graphres.getVertex(`${e.vertexOne.name}`)[0];\n        let vv2 = graphres.getVertex(`${e.vertexTwo.name}`)[0];\n\n        let e_new: IEdge;\n        e_new = new Edge(vv1,vv2);\n        graphres.addEdge(e_new);\n    });\n    return graphres;\n}\n\nfunction Joint(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // соединение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach(v=>{\n        graphres.addVertex(v);\n        graph2.vertices.forEach(v1=>{\n            if(!(graphres.getVertex(`${v1.name}`).length>0))\n                graphres.addVertex(v1);\n            let e: IEdge;\n            e = new Edge(v,v1);\n            graphres.addEdge(e);\n        });\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    return graphres;\n}\n\nfunction Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Произведение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name||u2.name!==v2.name){\n                        if((u1.name===v1.name)&&(v2.isAdjacent(graph2,u2))){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if((u2.name===v2.name)&&(v1.isAdjacent(graph1,u1))){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nfunction Composition(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Композиция !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name || u2.name!==v2.name){\n                        //let e_0: IEdge;\n                        //e_0=new Edge(v1,v2)\n                        if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if(v1.isAdjacent(graph1,u1)){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nfunction Uni_Z(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // объединение по Зыкову\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n    graph1.vertices.forEach((v:any)=>{\n        graphres.addVertex(v);\n    });\n    graph1.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph2.vertices.forEach((v: any)=>{\n        if(!(graphres.getVertex(`${v.name}`).length>0)){ // если нет таких же по имени вершин\n            graphres.addVertex(v);\n        }\n    });\n    graph2.edges.forEach((e:any)=>{\n        graphres.addEdge(e);\n    });\n    graph1.vertices.forEach((v1: any)=> {\n        graph2.vertices.forEach((v2: any)=> {\n            if (!(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                let vv1 = graphres.getVertex(`${v1.name}`)[0];\n                let vv2 = graphres.getVertex(`${v2.name}`)[0];\n\n                let e: IEdge;\n                e = new Edge(vv1,vv2);\n                graphres.addEdge(e);\n            }\n        });\n    });\n    return graphres;\n}\n\nfunction Cross(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Пересечение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            if (v1.name === v2.name){\n                let v_res: IVertex;\n                v_res = new Vertex(`${v1.name}`);\n                graphres.addVertex(v_res);\n            }\n        });\n    });\n\n    graph1.edges.forEach(u1=>{\n        graph2.edges.forEach(u2=>{\n            if ((u1.vertexOne.name === u2.vertexOne.name && u1.vertexTwo.name === u2.vertexTwo.name) || (u1.vertexOne.name === u2.vertexTwo.name && u1.vertexTwo.name === u2.vertexOne.name)){\n                let v1 = graphres.getVertex(`${u1.vertexOne.name}`);\n                let v2 = graphres.getVertex(`${u1.vertexTwo.name}`);\n\n                let e: IEdge;\n                e = new Edge(v1[0],v2[0]);\n                graphres.addEdge(e);\n            }\n        });\n    });\n\n    return graphres;\n}\n\nfunction Addition(graph1: IGraph<IVertex, IEdge>){ // Дополнение\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v1=>{\n        let v_res: IVertex;\n        v_res = new Vertex(`${v1.name}`);\n        graphres.addVertex(v_res);\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph1.vertices.forEach(v2=>{\n            let vv1 = v1.name;\n            let vv2 = v2.name;\n            if (v1.name !== v2.name && !(v1.isAdjacent(graph1,v2)) && !(graphres.getVertex(v1.name)[0].isAdjacent(graphres,graphres.getVertex(v2.name)[0]))){\n                let v1 = graphres.getVertex(`${vv1}`);\n                let v2 = graphres.getVertex(`${vv2}`);\n\n                let e: IEdge;\n                e = new Edge(v1[0],v2[0]);\n                graphres.addEdge(e);\n            }\n        });\n    });\n\n    let graph2: IGraph<IVertex, IEdge>;\n    graph2 = GetNewRandomGraph(0);\n    init2(graph2);\n\n\n    return graphres;\n}\n\nfunction Cartesian_Product(graph1: IGraph<IVertex, IEdge>,graph2: IGraph<IVertex, IEdge>){ // Декартово произведение !!!!! без пересечения вершин !!!!!\n    let graphres: IGraph<IVertex, IEdge>;\n    graphres = GraphGenerator.generate(0);\n\n    graph1.vertices.forEach(v=>{\n        graph2.vertices.forEach(v1=>{\n            let v_res: IVertex;\n            v_res = new Vertex(`${v.name}${v1.name}`); // ???????????????\n            graphres.addVertex(v_res);\n            //v_res = new Vertex(`${v.name},${v1.name}`,graphres); // ???????????????\n            //graphres.addVertex(v_res);\n\n        });\n    });\n\n    graph1.vertices.forEach(v1=>{\n        graph2.vertices.forEach(v2=>{\n            graph1.vertices.forEach(u1=>{\n                graph2.vertices.forEach(u2=>{\n                    if(u1.name!==v1.name || u2.name!==v2.name){\n                        //let e_0: IEdge;\n                        //e_0=new Edge(v1,v2)\n                        if((u1.name===v1.name) && v2.isAdjacent(graph2,u2)){//graph2.getEdge(v2,u2).length>0 ){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n\n                        else if(v1.isAdjacent(graph1,u1)){\n                            let vv1 = graphres.getVertex(`${v1.name}${v2.name}`);\n                            let vv2 = graphres.getVertex(`${u1.name}${u2.name}`);\n\n                            let e: IEdge;\n                            e = new Edge(vv1[0],vv2[0]);\n                            graphres.addEdge(e);\n                        }\n                    }\n\n                });\n            });\n        });\n    });\n\n    return graphres;\n}\n\nexport { GetNewRandomGraph, GetNewRandomGraphForThatOne, ChooseTask };",["58","59"],"/home/ilya/UIR/Tasks.GraphOperations/src/CheckAnswer.ts",[],"/home/ilya/UIR/Tasks.GraphOperations/src/GraphsInit.ts",[],{"ruleId":"60","replacedBy":"61"},{"ruleId":"62","replacedBy":"63"},{"ruleId":"64","severity":1,"message":"65","line":1,"column":16,"nodeType":"66","messageId":"67","endLine":1,"endColumn":25},{"ruleId":"64","severity":1,"message":"68","line":5,"column":5,"nodeType":"66","messageId":"67","endLine":5,"endColumn":15},{"ruleId":"64","severity":1,"message":"69","line":8,"column":53,"nodeType":"66","messageId":"67","endLine":8,"endColumn":64},{"ruleId":"64","severity":1,"message":"70","line":8,"column":66,"nodeType":"66","messageId":"67","endLine":8,"endColumn":73},{"ruleId":"64","severity":1,"message":"71","line":8,"column":75,"nodeType":"66","messageId":"67","endLine":8,"endColumn":94},{"ruleId":"64","severity":1,"message":"72","line":9,"column":48,"nodeType":"66","messageId":"67","endLine":9,"endColumn":54},{"ruleId":"64","severity":1,"message":"73","line":9,"column":56,"nodeType":"66","messageId":"67","endLine":9,"endColumn":63},{"ruleId":"64","severity":1,"message":"74","line":9,"column":72,"nodeType":"66","messageId":"67","endLine":9,"endColumn":86},{"ruleId":"64","severity":1,"message":"75","line":10,"column":8,"nodeType":"66","messageId":"67","endLine":10,"endColumn":14},{"ruleId":"64","severity":1,"message":"76","line":12,"column":9,"nodeType":"66","messageId":"67","endLine":12,"endColumn":24},{"ruleId":"64","severity":1,"message":"77","line":15,"column":10,"nodeType":"66","messageId":"67","endLine":15,"endColumn":15},{"ruleId":"64","severity":1,"message":"78","line":15,"column":30,"nodeType":"66","messageId":"67","endLine":15,"endColumn":35},{"ruleId":"64","severity":1,"message":"79","line":15,"column":50,"nodeType":"66","messageId":"67","endLine":15,"endColumn":57},{"ruleId":"64","severity":1,"message":"80","line":15,"column":78,"nodeType":"66","messageId":"67","endLine":15,"endColumn":82},{"ruleId":"64","severity":1,"message":"81","line":16,"column":20,"nodeType":"66","messageId":"67","endLine":16,"endColumn":38},{"ruleId":"64","severity":1,"message":"82","line":17,"column":10,"nodeType":"66","messageId":"67","endLine":17,"endColumn":27},{"ruleId":"64","severity":1,"message":"83","line":17,"column":29,"nodeType":"66","messageId":"67","endLine":17,"endColumn":56},{"ruleId":"64","severity":1,"message":"84","line":17,"column":58,"nodeType":"66","messageId":"67","endLine":17,"endColumn":68},{"ruleId":"64","severity":1,"message":"85","line":6,"column":17,"nodeType":"66","messageId":"67","endLine":6,"endColumn":31},{"ruleId":"60","replacedBy":"86"},{"ruleId":"62","replacedBy":"87"},"no-native-reassign",["88"],"no-negated-in-lhs",["89"],"@typescript-eslint/no-unused-vars","'FormEvent' is defined but never used.","Identifier","unusedVar","'ToolButton' is defined but never used.","'StudentMark' is defined but never used.","'Console' is defined but never used.","'graphActionCreators' is defined but never used.","'IGraph' is defined but never used.","'IVertex' is defined but never used.","'GraphGenerator' is defined but never used.","'styles' is defined but never used.","'WritableAdapter' is defined but never used.","'init1' is defined but never used.","'init2' is defined but never used.","'initres' is defined but never used.","'init' is defined but never used.","'message_0_changing' is defined but never used.","'GetNewRandomGraph' is defined but never used.","'GetNewRandomGraphForThatOne' is defined but never used.","'ChooseTask' is defined but never used.","'num_0_changing' is defined but never used.",["88"],["89"],"no-global-assign","no-unsafe-negation"]