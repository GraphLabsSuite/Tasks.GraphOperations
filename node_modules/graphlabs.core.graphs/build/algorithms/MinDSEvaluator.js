"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var State_1 = require("../util/State");
var CheckSet_1 = require("../util/CheckSet");
var StateColor_1 = require("../enums/StateColor");
/**
 * @classdesc
 * Minimal dominating sets evaluator
 */
var MinDSEvaluator = /** @class */ (function () {
    /**
     * @constructor
     * @param graph
     */
    function MinDSEvaluator(graph) {
        this._minDs = [];
        this._delta = 0;
        this._n = graph.vertices.length;
        var tempDs = [];
        for (var i = 0; i < this._n; i++) {
            tempDs.push(graph.vertices[i]);
            var tempDelta = 0;
            for (var j = 0; j < this._n; j++) {
                if (graph.vertices[i].isAdjacent(graph, graph.vertices[j]))
                    tempDelta++;
            }
            if (tempDelta > this._delta)
                this._delta = tempDelta;
        }
        this._minDs.push(tempDs);
    }
    MinDSEvaluator.prototype.evaluate = function (graph, flag) {
        var firstStep = new State_1.State(graph);
        this.process(firstStep, graph, flag);
        return this._minDs;
    };
    /**
     * Checks whether there are vertices could not be covered by red vertex in this context
     * @param vertex
     * @param state
     * @returns {boolean}
     */
    MinDSEvaluator.prototype.canVertexBeCovered = function (vertex, state) {
        var neighbors = state.vertexNeighbors(vertex);
        var vertDomNum = state.vertexPossibleDominatingNumber(vertex);
        if (vertDomNum == 0)
            return false;
        if (neighbors != null)
            for (var _i = 0, neighbors_1 = neighbors; _i < neighbors_1.length; _i++) {
                var neigh = neighbors_1[_i];
                var neighVertDomNum = state.vertexPossibleDominatingNumber(neigh);
                if (neighVertDomNum == 0)
                    return false;
            }
        return true;
    };
    /**
     * Checks whether all vertices can be dominated by anyone
     * @param state
     * @returns {boolean}
     */
    MinDSEvaluator.prototype.canVerticesBeCovered = function (state) {
        for (var _i = 0, _a = state.vertexPossibleDominatingNumberValues(); _i < _a.length; _i++) {
            var value = _a[_i];
            if (value == 0)
                return false;
        }
        return true;
    };
    MinDSEvaluator.prototype.recountNDominated = function (state) {
        var result = 0;
        for (var _i = 0, _a = state.vertexDominatedNumberValues(); _i < _a.length; _i++) {
            var value = _a[_i];
            if (value > 0)
                result++;
        }
        return result;
    };
    MinDSEvaluator.prototype.blueVertexRecount = function (state, givenVertex) {
        var neighbors = state.vertexNeighbors(givenVertex);
        state.decrementVertexPossibleDominatingNumber(givenVertex);
        if (neighbors != [])
            for (var _i = 0, neighbors_2 = neighbors; _i < neighbors_2.length; _i++) {
                var vertex = neighbors_2[_i];
                state.decrementVertexPossibleDominatingNumber(vertex);
            }
    };
    MinDSEvaluator.prototype.redVertexRecount = function (state, givenVertex) {
        state.incrementVertexPossibleDominatingNumber(givenVertex);
        state.incrementVertexDominatedNumber(givenVertex);
        for (var _i = 0, _a = state.vertexNeighbors(givenVertex); _i < _a.length; _i++) {
            var vertex = _a[_i];
            state.incrementVertexPossibleDominatingNumber(vertex);
            state.incrementVertexDominatedNumber(vertex);
        }
        state.nDominated = this.recountNDominated(state);
    };
    MinDSEvaluator.prototype.process = function (givenState, graph, flag) {
        var _this = this;
        if (givenState.level == this._n) {
            var isAllVerticesCovered = this.canVerticesBeCovered(givenState);
            if (isAllVerticesCovered) {
                if (flag) {
                    if (this._minDs[0].length > givenState.tempDs.length) {
                        this._minDs.forEach(function (d) { return _this._minDs.pop(); });
                        this._minDs.push(givenState.tempDs);
                        return;
                    }
                    if (this._minDs[0].length == givenState.tempDs.length) {
                        this._minDs.push(givenState.tempDs);
                        return;
                    }
                }
                else {
                    var checker = new CheckSet_1.CheckSet();
                    if (checker.isMinimal(givenState.tempDs, graph)) {
                        this._minDs.push(givenState.tempDs);
                    }
                }
            }
        }
        else {
            var givenVertex = graph.vertices[givenState.level];
            givenState.setVertexColor(givenVertex, StateColor_1.StateColor.BLUE);
            this.blueVertexRecount(givenState, givenVertex);
            var isVertexCovered = this.canVertexBeCovered(givenVertex, givenState);
            if (isVertexCovered) {
                var newState = givenState.clone();
                newState.level++;
                this.process(newState, graph, flag);
            }
            givenState.setVertexColor(givenVertex, StateColor_1.StateColor.RED);
            givenState.tempDs.push(givenVertex);
            this.redVertexRecount(givenState, givenVertex);
            if (givenState.nDominated == this._n) {
                if (flag) {
                    if (this._minDs[0].length > givenState.tempDs.length) {
                        this._minDs.forEach(function (d) { return _this._minDs.pop(); });
                        this._minDs.push(givenState.tempDs);
                        return;
                    }
                    if (this._minDs[0].length == givenState.tempDs.length) {
                        this._minDs.push(givenState.tempDs);
                        return;
                    }
                }
                else {
                    var checker = new CheckSet_1.CheckSet();
                    if (checker.isMinimal(givenState.tempDs, graph))
                        this._minDs.push(givenState.tempDs);
                }
            }
            else {
                if (flag) {
                    var nExtra = (this._n - givenState.nDominated) / (this._delta + 1);
                    if ((nExtra + givenState.tempDs.length) > this._minDs[0].length)
                        return;
                    else {
                        var newState = givenState.clone();
                        newState.level++;
                        this.process(newState, graph, flag);
                        return;
                    }
                }
                else {
                    var newState = givenState.clone();
                    newState.level++;
                    this.process(newState, graph, flag);
                    return;
                }
            }
        }
    };
    return MinDSEvaluator;
}());
exports.MinDSEvaluator = MinDSEvaluator;
//# sourceMappingURL=MinDSEvaluator.js.map